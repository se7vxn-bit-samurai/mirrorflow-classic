<!DOCTYPE html>

<!-- MF:CHANGELOG (Phase F Harden) -->
<!-- Phase F Hardening & Deduplication (Event Storm Control) -->
<!-- Changes applied: -->
<!-- 1) Added canonical Phase F block header with [MF:OWNER:PHASE_F_SCHEDULER] marker -->
<!-- 2) Consolidated all heavy recompute through ONE scheduler: mainHeavyRecomputePipeline -->
<!-- 3) Enforced SINGLE wiring location per input (agent/customer/notes) -->
<!-- 4) Added [MF:PHASE-F][OWNER:INPUT_*] markers for future audit trails -->
<!-- 5) Converted legacy debouncedRecomputeMlcxState to NO-OP wrapper (prevents duplicate scheduling) -->
<!-- 6) Updated wireLiveUpdates() to LIGHT only (no heavy listener attachment) -->
<!-- 7) Consolidated duplicate blur handlers on agentInput (blurAgentBubble + Phase F coordinated) -->
<!-- 8) Added comprehensive Phase F audit checklist for regression detection -->
<!-- 9) All state: window.__mf_isComposing, window.__mf_recomputeTimer, window.__mf_lastTextSnapshot, window.__mf_pendingReason -->
<!-- 10) Debounce: 160ms trailing on input; 0ms (immediate) on blur/commit -->
<!-- Result: NO EVENT STORM. Heavy analysis runs ONLY via canonical scheduler, guarded by IME composition. -->

<html lang="en-GB">
<head>
<meta charset="utf-8"/>
<title>MirrorFlow</title>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<script>
  // Phase D: Dev Lab feature flags (UI only). Flip to true to re-enable later.
  // Buttons are hidden, not removed; subviews still initialise in the background.
  window.__DEVLAB_SHOW_DICTIONARIES = false;
  window.__DEVLAB_SHOW_LIBRARY_EDITOR = false;
</script>

<style>
    :root {
      --panel-border: #27344a;
      --text-main: #f7f9ff;
      --text-muted: #a7b3cf;

            --focus-ring: #38bdf8;
      --scrollbar-thumb: rgba(148, 163, 184, 0.9);
      --scrollbar-track: rgba(15, 23, 42, 0.8);
      --highlight-colour: #facc15;

/* DARK COLOURWAYS (chat body + bubbles) */
      --cw-classic-bg: radial-gradient(circle at top, #120A1C 0, #000000 60%);
      --cw-classic-customer: #FF4A1C;
      --cw-classic-customer-border: #FFB06A;

      --cw-teal-bg: radial-gradient(circle at top, #156669 0, #020617 60%);
      --cw-teal-customer: #0a7d42;
      --cw-teal-customer-border: #6fd19f;

      --cw-sahara-bg: radial-gradient(circle at top, #2B2431 0, #120F18 60%);
      --cw-sahara-customer: #A78BC3;
      --cw-sahara-customer-border: #D9BB65;

      --cw-sunburst-bg: radial-gradient(circle at top, #3b0f0f 0, #020617 60%);
      --cw-sunburst-customer: #f97316;
      --cw-sunburst-customer-border: #fdba74;

            --cw-crown-bg: radial-gradient(circle at top, #021526 0, #020617 60%);
      --cw-crown-customer: #e11d48;
      --cw-crown-customer-border: #fb7185;

      /* AURORA COLOURWAY (purple) */
      --cw-aurora-bg: radial-gradient(circle at top, #271049 0, #020617 60%);
      --cw-aurora-customer: #8b5cf6;
      --cw-aurora-customer-border: #c084fc;

      /* Aurora light variant */
      --cw-aurora-light-bg: radial-gradient(circle at top, #f5f3ff 0, #ede9fe 35%, #f5f3ff 80%);
      --cw-aurora-light-customer: #c4b5fd;
      --cw-aurora-light-customer-border: #a78bfa;

/* LIGHT COLOURWAYS (chat body + bubbles) */
      --cw-classic-light-bg: radial-gradient(circle at top, #e5ecff 0, #eef2ff 35%, #dbeafe 80%);
      --cw-classic-light-customer: #2563eb;
      --cw-classic-light-customer-border: #1d4ed8;

      --cw-teal-light-bg: radial-gradient(circle at top, #ccfbf1 0, #ecfeff 35%, #e0f2fe 80%);
      --cw-teal-light-customer: #0f766e;
      --cw-teal-light-customer-border: #0d9488;

      --cw-sahara-light-bg: radial-gradient(circle at top, #fef9c3 0, #fefce8 35%, #ffedd5 80%);
      --cw-sahara-light-customer: #a16207;
      --cw-sahara-light-customer-border: #ca8a04;

      --cw-sunburst-light-bg: radial-gradient(circle at top, #ffedd5 0, #fef3c7 35%, #fee2e2 80%);
      --cw-sunburst-light-customer: #c2410c;
      --cw-sunburst-light-customer-border: #ea580c;
      --cw-crown-light-bg: radial-gradient(circle at top, #eef2ff 0, #dbeafe 35%, #fee2e2 80%);
      --cw-crown-light-customer: #b91c1c;
      --cw-crown-light-customer-border: #ef4444;

/* === Dev Lab Redesign Additions ===
   These styles create a dark, card‑based interface for the dictionary and library editors.  They
   adopt the same palette used in the JADO preview while keeping the messenger panel untouched. */
    .devlab-editor-container,
    #dictGrid,
    #dict2Grid {
      background: radial-gradient(circle at top, #120a1c 0, #020617 60%);
      border-radius: 8px;
      padding: 12px;
    }

    .devlab-editor-left,
    .devlab-editor-middle,
    .devlab-editor-right,
    #dictIndex,
    #dictListPanel,
    #dictDetailPanel,
    #dict2Index,
    #dict2ListPanel,
    #dict2DetailPanel {
      background: rgba(17, 24, 39, 0.7);
      border: 1px solid var(--panel-border);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 12px;
    }

    .devlab-editor-left h3,
    .devlab-editor-middle h3,
    .devlab-editor-right h3,
    #dictTitle,
    #dict2Title {
      color: var(--text-main);
    }

    /* Restrict form styling to Dev Lab only to avoid affecting messenger UI */
    body[data-layout="dev"] .editor-title,
    body[data-layout="dev"] .editor-group,
    body[data-layout="dev"] .editor-stock,
    body[data-layout="dev"] .editor-text,
    body[data-layout="dev"] .lib-search,
    body[data-layout="dev"] .lib-group-filter,
    body[data-layout="dev"] select,
    body[data-layout="dev"] input[type='text'],
    body[data-layout="dev"] textarea {
      background-color: rgba(30, 41, 59, 0.8);
      border: 1px solid rgba(51, 65, 85, 0.6);
      color: var(--text-main);
      border-radius: 4px;
      padding: 6px 8px;
    }

    body[data-layout="dev"] .editor-stock {
      margin-bottom: 12px;
      width: 100%;
    }


      /* LOW-POLY SVG PALETTE (outer background) – defaults */
      --bg-c1: #111827;
      --bg-c2: #1f2937;
      --bg-c3: #374151;
      --bg-c4: #6b7280;
    }

    * {
      box-sizing: border-box;
    }

    body {
      transition: opacity 0.18s ease-out;
      margin: 0;
      min-height: 100vh;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background-color: #050816;
      background-image: radial-gradient(circle at top, #1c2840 0, #050816 45%);
      background-size: cover;
      background-repeat: no-repeat;
      background-position: center;
      background-attachment: fixed;
      color: var(--text-main);
      display: flex;
      justify-content: center;
      padding: 20px;
      transition: background-image 0.25s ease, background-color 0.25s ease, opacity 180ms cubic-bezier(.2,.8,.2,1), transform 220ms cubic-bezier(.2,.8,.2,1), filter 220ms cubic-bezier(.2,.8,.2,1);
      position: relative;
      overflow-x: hidden;
      will-change: opacity, transform, filter;
    }

    body.mf-preload {
      opacity: 0;
      transform: scale(0.992) translateY(6px);
      filter: blur(2px) saturate(1.05);
      pointer-events: none;
    }


    /* Low-poly SVG full-screen background */
    .lowpoly-bg {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: -2;
      pointer-events: none;
    }

    .lowpoly-bg polygon.c1 { fill: var(--bg-c1); }
    .lowpoly-bg polygon.c2 { fill: var(--bg-c2); }
    .lowpoly-bg polygon.c3 { fill: var(--bg-c3); }
    .lowpoly-bg polygon.c4 { fill: var(--bg-c4); }

    /* Soft overlay for vignette / contrast */
    .bg-overlay {
      position: fixed;
      inset: 0;
      z-index: -1;
      pointer-events: none;
      background:
        radial-gradient(circle at top left, rgba(255,255,255,0.08), transparent 55%),
        radial-gradient(circle at bottom right, rgba(15,23,42,0.85), #020617 80%);
      mix-blend-mode: soft-light;
    }

    /* Ensure a uniform font across editor and phone bubbles */
    .textarea-shell textarea,
    .agent-textarea,
    .locked-textarea,
    .chat-bubble {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      line-height: 1.35;
      word-wrap: break-word;
      overflow-wrap: anywhere;
}
    /* Ensure highlighted text remains readable across themes:
       any inline background-colour applied by the editor (execCommand hiliteColor/backColor)
       will also force a dark text colour for contrast. This affects both the main editor
       and the phone preview bubbles. */
    .agent-textarea span[style*="background-color"],
    .agent-textarea font[style*="background-color"] {
      color: #020617;
    }
    .chat-bubble span[style*="background-color"],
    .chat-bubble font[style*="background-color"] {
      color: #020617;
    }


/* Light theme adjustments (keep text colours as in original) */
body[data-theme="light"] {
      color: #111827;
      background-color: #f9fafb;
      background-image: radial-gradient(circle at top, #e0f2fe 0, #f9fafb 40%, #e5ecff 90%);
    }

    body[data-theme="lunar"] {
      color: #111827;
      background-color: #e5e7eb;
      background-image: radial-gradient(circle at top, #f3f4f6 0, #e5e7eb 40%, #d1d5db 90%);
    }


    /* dynamic outer background gradient by colourway (SVG handles pattern) */
    body[data-colour="classic"] {
      background-image: radial-gradient(circle at top, #1c2840 0, #050816 45%);
    }
    body[data-colour="teal"] {
      background-image: radial-gradient(circle at top, #022c22 0, #020617 45%);
    }
    body[data-colour="sahara"] {
      background-image: radial-gradient(circle at top, #1b4332 0, #020617 45%);
    }
    body[data-colour="sunburst"] {
      background-image: radial-gradient(circle at top, #7c2d12 0, #020617 45%);
    }
    body[data-colour="crown"] {
      background-image: radial-gradient(circle at top, #0b1f4b 0, #020617 45%);
    }

    body[data-colour="aurora"] {
      background-image: radial-gradient(circle at top, #3b0764 0, #020617 45%);
    }
    /* Focus ring + scrollbar tint per colourway */
    body[data-colour="classic"] {
      --focus-ring: #38bdf8;
      --scrollbar-thumb: rgba(59, 130, 246, 0.95);
      --highlight-colour: #bfdbfe;
    }
    body[data-colour="teal"] {
      --focus-ring: #2dd4bf;
      --scrollbar-thumb: rgba(45, 212, 191, 0.95);
      --highlight-colour: #99f6e4;
    }
    body[data-colour="sahara"] {
      --focus-ring: #eab308;
      --scrollbar-thumb: rgba(234, 179, 8, 0.95);
      --highlight-colour: #fef3c7;
    }
    body[data-colour="sunburst"] {
      --focus-ring: #fb923c;
      --scrollbar-thumb: rgba(249, 115, 22, 0.95);
      --highlight-colour: #fed7aa;
    }
    body[data-colour="crown"] {
      --focus-ring: #e11d48;
      --scrollbar-thumb: rgba(244, 63, 94, 0.95);
      --highlight-colour: #ffe4e6;
    }
    body[data-colour="aurora"] {
      --focus-ring: #a855f7;
      --scrollbar-thumb: rgba(168, 85, 247, 0.95);
      --highlight-colour: #e9d5ff;
    }



COLOURWAY */

    /* Dark – Rift – Shadowfire */
    body[data-theme="dark"][data-colour="classic"] {
      --bg-c1: #02010A;  /* near-black base */
      --bg-c2: #1a1020;  /* void-purple shadow */
      --bg-c3: #7C3AED;  /* ember vein */
      --bg-c4: #F97316;  /* flame gold */
    }

    /* Dark – The Crown – SA Flag Night */
    body[data-theme="dark"][data-colour="crown"] {
      --bg-c1: #020308;  /* night sky / black */
      --bg-c2: #002395;  /* flag blue */
      --bg-c3: #DE3831;  /* flag red */
      --bg-c4: #007A4D;  /* flag green */
    }

    /* Dark – The Grove – Baobab Forest */
    body[data-theme="dark"][data-colour="teal"] {
      --bg-c1: #022c22;  /* deep forest floor */
      --bg-c2: #14532d;  /* shaded leaves */
      --bg-c3: #0f766e;  /* deep grove trunk */
      --bg-c4: #b45309;  /* baobab bark / warm earth */
    }

    /* Dark – Echo – Rift Glass */
    body[data-theme="dark"][data-colour="sahara"] {
      --bg-c1: #020617;  /* deep void */
      --bg-c2: #0f172a;  /* midnight indigo */
      --bg-c3: #4f46e5;  /* echo violet */
      --bg-c4: #22d3ee;  /* neon cyan */
    }

    /* Dark – Sunburst */
    body[data-theme="dark"][data-colour="sunburst"] {
      --bg-c1: #3b0f0f;
      --bg-c2: #7c2d12;
      --bg-c3: #ea580c;
      --bg-c4: #fdba74;
    }

    /* Dark – Aurora */
    body[data-theme="dark"][data-colour="aurora"] {
      --bg-c1: #271049;
      --bg-c2: #4c1d95;
      --bg-c3: #7c3aed;
      --bg-c4: #c084fc;
    }

    /* Light – Rift – Fractured Dawn */
    body[data-theme="light"][data-colour="classic"] {
      --bg-c1: #FEF3C7;  /* deep rift sky */
      --bg-c2: #FED7AA;  /* softened void purple */
      --bg-c3: #7C3AED;  /* warm dawn ember */
      --bg-c4: #F97316;  /* bright flame edge */
    }

    /* Light – The Crown */
    body[data-theme="light"][data-colour="crown"] {
      --bg-c1: #f3f4ff;
      --bg-c2: #e5ecff;
      --bg-c3: #1d4ed8;
      --bg-c4: #e11d48;
    }

    /* Light – The Grove – Baobab Woodland */
    body[data-theme="light"][data-colour="teal"] {
      --bg-c1: #fef3c7;  /* warm canopy light */
      --bg-c2: #ecfccb;  /* sunlit leaves */
      --bg-c3: #22c55e;  /* fresh green */
      --bg-c4: #b45309;  /* baobab trunk accent */
    }

    /* Light – Echo – Shimmerfield */
    body[data-theme="light"][data-colour="sahara"] {
      --bg-c1: #eef2ff;
      --bg-c2: #e0f2fe;
      --bg-c3: #38bdf8;
      --bg-c4: #6366f1;
    }

    /* Light – Sunburst */
    body[data-theme="light"][data-colour="sunburst"] {
      --bg-c1: #ffedd5;
      --bg-c2: #fed7aa;
      --bg-c3: #f97316;
      --bg-c4: #c2410c;
    }
    /* Light – Aurora */
    body[data-theme="light"][data-colour="aurora"] {
      --bg-c1: #f5f3ff;
      --bg-c2: #ddd6fe;
      --bg-c3: #c4b5fd;
      --bg-c4: #a78bfa;
    }

    
    /* Lunar – midtone neutral / softened variants */

    /* Lunar – Aurora */
    body[data-theme="lunar"][data-colour="aurora"] {
      --bg-c1: #0a0f24;  /* deep night base */
      --bg-c2: #4c1d95;  /* aurora violet */
      --bg-c3: #0ea5e9;  /* bright cyan ribbon */
      --bg-c4: #22c55e;  /* emerald aurora edge */
    }

    /* Lunar – Rift – Ember Afterglow */
    body[data-theme="lunar"][data-colour="classic"] {
      --bg-c1: #120A1C;  /* ember afterglow base */
      --bg-c2: #1B1024;  /* rift haze */
      --bg-c3: #C084FC;  /* violet echo */
      --bg-c4: #FF4A1C;  /* stray ember */
    }

    /* Lunar – Crown – OUT Purple & Green */
    body[data-theme="lunar"][data-colour="crown"] {
      --bg-c1: #36185A;  /* OUT purple base */
      --bg-c2: #4A227A;  /* deeper OUT purple */
      --bg-c3: #732282;  /* OUT accent purple */
      --bg-c4: #8DC63F;  /* OUT accent green */
    }

    /* Lunar – Echo */
    body[data-theme="lunar"][data-colour="sahara"] {
      --bg-c1: #020617;
      --bg-c2: #1e293b;
      --bg-c3: #22d3ee;
      --bg-c4: #c4b5fd;
    }

    /* Lunar – Sunburst */
    body[data-theme="lunar"][data-colour="sunburst"] {
      --bg-c1: #1f2937;  /* deep neutral */
      --bg-c2: #b45309;  /* warm gold */
      --bg-c3: #3b82f6;  /* subtle blue accent */
      --bg-c4: #fed7aa;  /* soft highlight */
    }

    /* Lunar – The Grove – Moonlit Canopy */
    body[data-theme="lunar"][data-colour="teal"] {
      --bg-c1: #022c22;  /* forest at night */
      --bg-c2: #14532d;  /* deep shadowed leaves */
      --bg-c3: #16a34a;  /* bioluminescent green */
      --bg-c4: #facc15;  /* golden moonlit bark */
    }
.app {
      display: flex;
      position: relative;
      gap: 20px;
      /* FIXED CARD SIZE */
      width: 1200px;
      min-width: 1200px;
      max-width: 1200px;

      flex-wrap: nowrap;
      align-items: stretch;
      padding: 18px;
      border-radius: 26px;
      border: 1px solid var(--panel-border);
      background: radial-gradient(circle at top, #020617 0, #020617 45%, #020617 100%);
      box-shadow: 0 24px 60px rgba(15, 23, 42, 0.9);
      overflow-x: hidden;
      overflow-y: visible;
    }

    /* Full text 'notepad' mode hides phone + customer message */

    body[data-layout="mlcx"] .preview-panel {
      display: none;
    }
    body[data-layout="mlcx"] .panel {
      display: none;
    }
    body[data-layout="mlcx"] .phone-text-size-row {
      display: none;
    }
    /* In MLCX layout we show only the dedicated MLCX coaching panel */
    .mlcx-panel {
      display: none;
      flex: 1 1 auto;
      height: 100%;
      max-height: 100%;
      min-height: 0;
      padding: 20px 22px 18px;
      overflow: hidden;
      flex-direction: column;
    }
    body[data-layout="mlcx"] .mlcx-panel {
      display: flex;
      flex: 1 1 auto;
      height: 100%;
      max-height: 100%;
      min-height: 0;
      padding: 20px 22px 18px;
      overflow: hidden;
      flex-direction: column;
    }

    body[data-layout="notepad"] .preview-panel {
      display: none;
    }
    body[data-layout="notepad"] .draft-column:first-of-type {
      display: none;
    }
    body[data-layout="notepad"] .phone-text-size-row {
      display: none;
    }
    body[data-layout="notepad"] #repliesBtn,
    body[data-layout="notepad"] #phrasesBtn,
    body[data-layout="notepad"] #repliesPanel,
    body[data-layout="notepad"] #phrasesPanel,
    body[data-layout="notepad"] .char-count-row {
      display: none;
    }
    body[data-layout="notepad"] #agentInput,
    body[data-layout="notepad"] .locked-textarea {
      display: none !important;
    }

    .notepad-shell {
      display: none;
      margin-top: 16px;
    }

    body[data-layout="notepad"] .notepad-shell {
      display: block;
    }

    body[data-layout="notepad"] .panel {
      flex: 1 1 100%;
    }

    body[data-layout="notepad"] .draft-column.agent-column > .field-label {
      display: none;
    }

    .app-title--notepad {
      display: none;
    }

    body[data-layout="mlcx"] .app-title--split {
      display: inline;
    }

    body[data-layout="split"] .app-title--notepad {
      display: none;
    }

    body[data-layout="notepad"] .app-title--split {
      display: none;
    }

    body[data-layout="notepad"] .app-title--notepad {
      display: inline;
    }

    .view-toggle-btn {
      position: absolute;
      top: 10px;
      right: 14px;
      z-index: 10;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.92);
      color: #e5e7eb;
      font-size: 0.72rem;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      cursor: pointer;
      box-shadow: 0 10px 30px rgba(15, 23, 42, 0.85);
    }
    body[data-theme="light"] .view-toggle-btn,
    body[data-theme="lunar"] .view-toggle-btn {
      background: rgba(248, 250, 252, 0.98);
      color: #111827;
      box-shadow: 0 12px 30px rgba(148, 163, 184, 0.7);
    }
    .view-toggle-btn-icon {
      font-size: 0.86rem;
      line-height: 1;
    }

    .view-toggle-btn-label {
      display: none;
    }

    body[data-theme="light"] .app {
      border-color: #d4d4d8;
      background: radial-gradient(circle at top, #e5e7f5 0, #eef2f7 40%, #e5e7eb 100%);
      box-shadow: 0 24px 60px rgba(148, 163, 184, 0.58);
    }

    body[data-theme="lunar"] .app {
      border-color: #9ca3af;
      background: radial-gradient(circle at top, #f3f4f6 0, #d4d4d8 45%, #111827 100%);
      box-shadow: 0 24px 60px rgba(15, 23, 42, 0.8);
    }

    /* Phase 19.2: Dev Lab panel - unified sizing with messenger/notepad/mlcx
       All four layout modes (split, notepad, mlcx, dev) now share identical outer panel dimensions.
       Dev Lab uses the same .panel base class and body[data-layout="dev"] visibility control.
       Internal .dev-container structure mirrors .mlcx-og-container (same gap, flex proportions, scroll).
       No custom .app width overrides - all layouts use the standard 1200px fixed card size. */
    .dev-panel {
      display: none;
      flex: 1 1 480px;
      min-height: 600px;
      max-height: none;
      background: rgba(100, 110, 120, 0.15);
      border-radius: 24px;
      padding: 20px 22px 18px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      box-shadow: 0 18px 60px rgba(15, 23, 42, 0.15);
      position: relative;
      overflow: auto;
      flex-direction: column;
      gap: 10px;
      color: #e5e7eb;
    }
    
    /* Hide dev panel in all non-dev layouts */
    body[data-layout="split"] .dev-panel,
    body[data-layout="notepad"] .dev-panel,
    body[data-layout="mlcx"] .dev-panel {
      display: none !important;
    }
    
    /* Dev layout mode - show only dev panel, hide others */
    body[data-layout="dev"] .dev-panel {
      display: flex;
      background: rgba(15,23,42,0.92) !important; /* solid dark slate for readability */
      backdrop-filter: none !important;
      -webkit-backdrop-filter: none !important;
    }
    body[data-layout="dev"] .dev-panel .dev-demo-block,
    body[data-layout="dev"] .dev-panel .dev-editor-item,
    body[data-layout="dev"] .dev-panel .dev-editor-section-header,
    body[data-layout="dev"] .dev-panel .dev-editor-item-preview,
    body[data-layout="dev"] .dev-panel .dev-editor-item-meta,
    body[data-layout="dev"] .dev-panel .dev-view-mlcx,
    body[data-layout="dev"] .dev-panel .dev-view-editor {
      background: rgba(30,41,59,0.85) !important;
      box-shadow: none;
    }
    body[data-layout="dev"] .dev-panel .dev-editor-item.is-selected {
      background: rgba(51,65,85,0.85) !important;
    }
    body[data-layout="dev"] .panel:not(.dev-panel) {
      display: none;
    }
    body[data-layout="dev"] .preview-panel {
      display: none;
    }
    body[data-layout="dev"] .phone-text-size-row {
      display: none;
    }
    body[data-layout="dev"] .cx-drawer-overlay {
      display: none !important;
    }
    body[data-layout="dev"] .cx-notch {
      display: none !important;
    }
    
    /* Phase 19.2: Dev Lab container matching MLCX notepad structure */
    .dev-container {
      display: flex;
      gap: 24px;
      height: 100%;
      overflow: hidden;
    }
    .dev-left {
      flex: 1.4;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      padding-right: 10px;
    }
    .dev-right {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 14px;
      overflow-y: auto;
      padding-left: 10px;
      border-left: 1px solid rgba(148, 163, 184, 0.25);
    }
    .dev-header {
      margin-bottom: 16px;
    }
    .dev-title {
      font-size: 1.125rem;
      font-weight: 600;
      color: #e5e7eb;
      margin-bottom: 8px;
      letter-spacing: 0.05em;
    }
    .dev-desc {
      font-size: 0.875rem;
      line-height: 1.5;
      color: #94a3b8;
      margin-bottom: 6px;
    }
    .dev-textarea,
    .dev-pre {
      width: 100%;
      min-height: 140px;
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      background: rgba(30, 41, 59, 0.95);
      color: #e5e7eb;
      font-family: "JetBrains Mono", "Fira Code", "Courier New", monospace;
      font-size: 0.74rem;
      line-height: 1.5;
      resize: vertical;
      overflow-y: auto;
      margin-bottom: 14px;
      scrollbar-width: thin;
    }
    .dev-pre {
      white-space: pre-wrap;
      word-wrap: break-word;
      max-height: 240px;
    }
    .dev-card {
      padding: 14px 16px;
      border-radius: 10px;
      background: rgba(30, 41, 59, 0.95);
      border: 1px solid rgba(148, 163, 184, 0.4);
      box-shadow: 0 2px 8px rgba(15, 23, 42, 0.08);
    }
    .dev-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      font-size: 0.78rem;
      font-weight: 600;
      color: #e5e7eb;
      letter-spacing: 0.05em;
    }
    .dev-card p {
      font-size: 0.74rem;
      line-height: 1.5;
      color: #cbd5e1;
      margin-bottom: 8px;
    }
    .dev-card ul {
      margin: 0;
      padding-left: 18px;
      font-size: 0.72rem;
      line-height: 1.6;
      color: #94a3b8;
    }
    .dev-card li {
      margin-bottom: 4px;
    }

    /* Phase E: Dev Lab internal health check */
    .dev-health-badge{
      font-size: 0.68rem;
      padding: 2px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.45);
      background: rgba(59, 130, 246, 0.12);
      color: #e5e7eb;
      letter-spacing: 0.04em;
    }
    .dev-health-badge.is-warn{ background: rgba(245, 158, 11, 0.14); }
    .dev-health-badge.is-bad{ background: rgba(239, 68, 68, 0.14); }
    .dev-health-grid{
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
      margin-top: 8px;
    }
    .dev-health-item{
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(15, 23, 42, 0.20);
    }
    .dev-health-label{
      font-size: 0.66rem;
      color: #94a3b8;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      margin-bottom: 4px;
    }
    .dev-health-value{
      font-size: 0.78rem;
      color: #e5e7eb;
      font-weight: 600;
      line-height: 1.2;
      word-break: break-word;
    }
    .dev-health-actions{
      display:flex;
      gap:8px;
      margin-top: 12px;
    }
    .dev-health-actions .fmt-btn{ flex: 1; }
    .dev-health-errors{
      margin-top: 10px;
      font-family: "JetBrains Mono", "Fira Code", "Courier New", monospace;
      font-size: 0.70rem;
      line-height: 1.35;
      color: #cbd5e1;
      max-height: 140px;
      overflow: auto;
      white-space: pre-wrap;
      border-radius: 10px;
      padding: 10px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(15, 23, 42, 0.25);
    }

    .dev-demo-block {
      margin-bottom: 10px;
      padding: 10px 12px;
      border-radius: 8px;
      background: rgba(30, 41, 59, 0.95);
      border: 1px solid rgba(148, 163, 184, 0.4);
    }
    .dev-demo-label {
      font-size: 0.72rem;
      font-weight: 500;
      margin-bottom: 6px;
      color: #e5e7eb;
    }
    .dev-demo-btn {
      margin-top: 6px;
      padding: 5px 12px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      background: rgba(59, 130, 246, 0.1);
      color: #1e293b;
      font-size: 0.7rem;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 500;
    }
    .dev-demo-btn:hover {
      background: rgba(59, 130, 246, 0.2);
      border-color: rgba(59, 130, 246, 0.6);
      transform: translateY(-1px);
      box-shadow: 0 2px 6px rgba(59, 130, 246, 0.2);
    }
    
    /* Dev Lab light/lunar theme support */
    body[data-theme="light"] .dev-panel,
    body[data-theme="lunar"] .dev-panel {
      color: #111827;
    }
    body[data-theme="light"] .dev-textarea,
    body[data-theme="lunar"] .dev-textarea,
    body[data-theme="light"] .dev-pre,
    body[data-theme="lunar"] .dev-pre {
      background: rgba(248, 250, 252, 0.6);
      border-color: rgba(148, 163, 184, 0.5);
      color: #111827;
    }
    body[data-theme="light"] .dev-card,
    body[data-theme="lunar"] .dev-card {
      background: rgba(255, 255, 255, 0.5);
      border-color: rgba(148, 163, 184, 0.4);
    }
    body[data-theme="light"] .dev-demo-block,
    body[data-theme="lunar"] .dev-demo-block {
      background: rgba(248, 250, 252, 0.6);
      border-color: rgba(148, 163, 184, 0.4);
    }
    body[data-theme="light"] .dev-demo-btn,
    body[data-theme="lunar"] .dev-demo-btn {
      background: rgba(255, 255, 255, 0.8);
      border-color: rgba(148, 163, 184, 0.6);
      color: #111827;
    }
    body[data-theme="light"] .dev-demo-btn:hover,
    body[data-theme="lunar"] .dev-demo-btn:hover {
      background: rgba(248, 250, 252, 0.95);
    }
    body[data-theme="light"] .dev-right,
    body[data-theme="lunar"] .dev-right {
      border-left-color: rgba(148, 163, 184, 0.4);
    }

    /* Phase 19.4: Dev Lab view switching (MLCX Debug / Library Editor) */
    .dev-view-toggle-btn {
      padding: 5px 12px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(15, 23, 42, 0.6);
      color: var(--text-muted);
      font-size: 0.72rem;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .dev-view-toggle-btn:hover {
      background: rgba(31, 41, 55, 0.8);
      color: var(--text-main);
    }
    .dev-panel[data-dev-view="mlcx"] .dev-view-toggle-btn[data-target-view="mlcx"],
    .dev-panel[data-dev-view="editor"] .dev-view-toggle-btn[data-target-view="editor"] {
      background: var(--focus-ring);
      color: #0f172a;
      font-weight: 600;
      border-color: var(--focus-ring);
    }
    .dev-panel[data-dev-view="mlcx"] .dev-view-mlcx {
      display: block;
    }
    .dev-panel[data-dev-view="mlcx"] .dev-view-editor {
      display: none !important;
    }
    .dev-panel[data-dev-view="editor"] .dev-view-mlcx {
      display: none !important;
    }
    .dev-panel[data-dev-view="editor"] .dev-view-editor {
      display: block;
    }

    /* Library Editor Layout */
    .dev-editor-controls {
      display: flex;
      align-items: center;
      padding: 12px 16px;
      background: rgba(15, 23, 42, 0.5);
      border-radius: 10px;
      margin-bottom: 16px;
      border: 1px solid rgba(148, 163, 184, 0.3);
    }
    .dev-editor-layout {
      display: grid;
      grid-template-columns: 180px 1fr 1fr;
      gap: 16px;
      height: calc(100% - 70px);
      overflow: hidden;
    }
    .dev-editor-nav {
      display: flex;
      flex-direction: column;
      gap: 8px;
      background: rgba(15, 23, 42, 0.4);
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 10px;
      padding: 12px;
      overflow-y: auto;
    }
    .dev-editor-nav-title {
      font-size: 0.68rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
      margin-bottom: 4px;
    }
    .dev-editor-nav-btn {
      padding: 10px 12px;
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 0.74rem;
      font-weight: 500;
      text-align: left;
      cursor: pointer;
      transition: all 0.15s ease;
    }
    .dev-editor-nav-btn:hover {
      background: rgba(31, 41, 55, 0.8);
      border-color: rgba(148, 163, 184, 0.4);
    }
    .dev-editor-nav-btn.is-active {
      background: rgba(56, 189, 248, 0.15);
      border-color: var(--focus-ring);
      color: var(--focus-ring);
    }
    .dev-editor-nav-btn.is-disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    .dev-editor-search-bar {
      position: relative;
      margin-bottom: 12px;
    }
    .dev-editor-search-bar input {
      width: 100%;
      padding: 8px 10px;
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 0.74rem;
      outline: none;
    }
    .dev-editor-search-bar input:focus {
      border-color: var(--focus-ring);
      box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.15);
    }
    .dev-editor-add-new {
      width: 100%;
      padding: 8px 12px;
      background: rgba(34, 197, 94, 0.2);
      border: 1px solid rgba(34, 197, 94, 0.5);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 0.74rem;
      font-weight: 500;
      cursor: pointer;
      margin-bottom: 12px;
      transition: all 0.15s ease;
    }
    .dev-editor-add-new:hover {
      background: rgba(34, 197, 94, 0.3);
      border-color: rgba(34, 197, 94, 0.7);
    }
    .dev-editor-lists {
      display: flex;
      flex-direction: column;
      gap: 0;
      overflow: hidden;
    }
    .dev-editor-section {
      background: rgba(15, 23, 42, 0.4);
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 10px;
      padding: 12px;
      margin-bottom: 12px;
      display: flex;
      flex-direction: column;
    }
    .dev-editor-section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
      cursor: pointer;
      user-select: none;
    }
    .dev-editor-section-title {
      font-size: 0.76rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-main);
      margin: 0;
    }
    .dev-editor-section-toggle {
      font-size: 0.9rem;
      color: var(--text-muted);
      transition: transform 0.2s ease;
    }
    .dev-editor-section.is-collapsed .dev-editor-section-toggle {
      transform: rotate(-90deg);
    }
    .dev-editor-section.is-collapsed .dev-editor-section-content {
      display: none;
    }
    .dev-editor-section-content {
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-height: 300px;
      overflow-y: auto;
      margin-bottom: 10px;
    }
    .dev-editor-bulk-actions {
      display: flex;
      gap: 6px;
      padding-top: 8px;
      border-top: 1px solid rgba(148, 163, 184, 0.2);
    }
    .dev-editor-bulk-btn {
      flex: 1;
      padding: 6px 8px;
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 6px;
      color: var(--text-main);
      font-size: 0.68rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s ease;
    }
    .dev-editor-bulk-btn:hover {
      background: rgba(31, 41, 55, 0.8);
      border-color: rgba(148, 163, 184, 0.5);
    }
    .dev-editor-bulk-btn.is-delete {
      background: rgba(220, 38, 38, 0.2);
      border-color: rgba(220, 38, 38, 0.4);
    }
    .dev-editor-bulk-btn.is-delete:hover {
      background: rgba(220, 38, 38, 0.3);
      border-color: rgba(220, 38, 38, 0.6);
    }
    .dev-editor-list-section {
      background: rgba(15, 23, 42, 0.4);
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 10px;
      padding: 12px;
      height: 100%;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .dev-editor-list-title {
      font-size: 0.76rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-main);
      margin: 0 0 10px 0;
    }
    .dev-editor-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      flex: 1;
      overflow-y: auto;
    }
    .dev-editor-item {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      padding: 8px 10px;
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.15s ease;
    }
    .dev-editor-item:hover {
      background: rgba(31, 41, 55, 0.8);
      border-color: rgba(148, 163, 184, 0.4);
    }
    .dev-editor-item.is-selected {
      background: rgba(56, 189, 248, 0.15);
      border-color: var(--focus-ring);
    }
    .dev-editor-item.is-archived {
      opacity: 0.5;
    }
    .dev-editor-item.is-archived .dev-editor-item-preview {
      font-style: italic;
      text-decoration: line-through;
    }
    .dev-editor-item-checkbox {
      flex-shrink: 0;
      margin-top: 2px;
    }
    .dev-editor-item-content {
      flex: 1;
      min-width: 0;
    }
    .dev-editor-item-preview {
      font-size: 0.74rem;
      color: var(--text-main);
      line-height: 1.4;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      -webkit-box-orient: vertical;
    }
    .dev-editor-item-meta {
      font-size: 0.68rem;
      color: var(--text-muted);
      margin-top: 3px;
    }
    .dev-editor-detail {
      display: flex;
      flex-direction: column;
      background: rgba(15, 23, 42, 0.4);
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 10px;
      padding: 12px;
    }

    body[data-theme="light"] .dev-view-toggle-btn,
    body[data-theme="lunar"] .dev-view-toggle-btn {
      background: rgba(248, 250, 252, 0.8);
      color: #4b5563;
      border-color: rgba(148, 163, 184, 0.6);
    }
    body[data-theme="light"] .dev-editor-controls,
    body[data-theme="lunar"] .dev-editor-controls,
    body[data-theme="light"] .dev-editor-list-section,
    body[data-theme="lunar"] .dev-editor-list-section,
    body[data-theme="light"] .dev-editor-detail,
    body[data-theme="lunar"] .dev-editor-detail,
    body[data-theme="light"] .dev-editor-nav,
    body[data-theme="lunar"] .dev-editor-nav,
    body[data-theme="light"] .dev-editor-section,
    body[data-theme="lunar"] .dev-editor-section {
      background: rgba(255, 255, 255, 0.6);
      border-color: rgba(148, 163, 184, 0.5);
    }
    body[data-theme="light"] .dev-editor-item,
    body[data-theme="lunar"] .dev-editor-item,
    body[data-theme="light"] .dev-editor-nav-btn,
    body[data-theme="lunar"] .dev-editor-nav-btn {
      background: rgba(248, 250, 252, 0.8);
      border-color: rgba(148, 163, 184, 0.4);
    }

    .panel {
      flex: 1 1 480px;
      background:
        radial-gradient(circle at top left, rgba(148, 163, 184, 0.18), transparent 55%),
        linear-gradient(145deg, #020617, #020617 40%, #020818 100%);
      border-radius: 24px;
      padding: 20px 22px 18px;
      border: 1px solid #1f2937;
      box-shadow: 0 18px 60px rgba(15, 23, 42, 0.9);
      position: relative;
      overflow: visible;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    /* Phase 19.20: Apply height constraints only to notepad layout where full-height is needed */
    body[data-layout="notepad"] .panel {
      min-height: 700px;
      max-height: 85vh;
    }

    /* Theme-specific CV sheet styling for better legibility */
    body[data-theme="day"] .cv-inner,
    body[data-theme="lunar"] .cv-inner {
      background:
        radial-gradient(circle at top, rgba(248, 250, 252, 0.98), rgba(229, 231, 235, 0.98));
      border-color: rgba(148, 163, 184, 0.85);
      box-shadow:
        0 24px 60px rgba(15, 23, 42, 0.22),
        0 0 0 1px rgba(148, 163, 184, 0.7);
      color: #0f172a;
    }

    body[data-theme="day"] .cv-title,
    body[data-theme="lunar"] .cv-title {
      color: #0f172a;
    }

    body[data-theme="day"] .cv-subtitle,
    body[data-theme="lunar"] .cv-subtitle {
      color: #4b5563;
    }

    body[data-theme="day"] .cv-block-title,
    body[data-theme="lunar"] .cv-block-title {
      color: #111827;
    }

    body[data-theme="day"] .cv-ghost,
    body[data-theme="lunar"] .cv-ghost {
      color: #4b5563;
    }

    body[data-theme="day"] .cv-chip,
    body[data-theme="lunar"] .cv-chip {
      border-color: rgba(148, 163, 184, 0.9);
    }

    .panel-title-row {
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 6px;
    }

    .panel-title {
      font-size: 0.98rem;
      font-weight: 600;
      letter-spacing: 0.03em;
    }

    .agent-tag {
      font-size: 0.74rem;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: #e5e7eb;
      background: radial-gradient(circle at top left, rgba(37, 99, 235, 0.35), transparent 65%);
    }

    .agent-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.35);
    }
    .agent-pill-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      border-radius: 999px;
      margin-left: 2px;
      font-size: 0.6rem;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: rgba(15, 23, 42, 0.98);
      background: radial-gradient(circle at top, #e5e7eb, #cbd5f5);
      box-shadow:
        0 0 0 1px rgba(15, 23, 42, 0.7),
        0 0 0 4px rgba(148, 163, 184, 0.4);
    }
    body[data-theme="dark"] .agent-pill-icon,
    body[data-theme="lunar"] .agent-pill-icon {
      color: #020617;
    }
    .agent-pill-icon-mlcx {
      font-size: 0.58rem;
    }



    .agent-tag span {
      opacity: 0.92;
    }

    .draft-layout {
      display: flex;
      flex-direction: column;
      gap: 14px;
      flex: 1;
    }

    .field-label {
      font-size: 0.76rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--text-muted);
      margin-bottom: 6px;
    }

    .draft-column {
      display: flex;
      flex-direction: column;
    }

    .draft-column.agent-column {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    .draft-column.agent-column .textarea-shell {
      flex: none;
      min-height: 0;
      position: relative;
    }
    /* ChatFlow commit buttons (Phase A) */
    /* ChatFlow timeline mode: hide legacy 2-bubble preview blocks so we don't duplicate */
    .chatflow-enabled .chat-section.customer,
    .chatflow-enabled .chat-section.agent{
      display:none !important;
    }
    
    .commit-btn{
      position:absolute;
      right:10px;
      bottom:10px;
      width:30px;
      height:30px;
      border-radius:999px;
      border:1px solid rgba(148,163,184,0.55);
      background: rgba(2,6,23,0.25);
      color: rgba(226,232,240,0.85);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      opacity:0.18;
      transform: translateY(1px);
      transition: opacity 0.18s ease, transform 0.18s ease, background 0.18s ease, border-color 0.18s ease;
      z-index:5;
    }
    .textarea-shell:hover .commit-btn{ opacity:0.9; transform: translateY(0); }
    .commit-btn:hover{
      background: rgba(2,6,23,0.62);
      border-color: rgba(249,115,22,0.85);
      color:#fff;
    }
    .commit-btn:active{ transform: translateY(1px) scale(0.98); }
    .commit-btn--customer{ border-color: rgba(99,102,241,0.55); }
    body[data-colour="teal"] .commit-btn--customer{ border-color: rgba(20,184,166,0.7); }
    body[data-colour="sahara"] .commit-btn--customer{ border-color: rgba(234,179,8,0.75); }
    body[data-colour="sunburst"] .commit-btn--customer{ border-color: rgba(251,146,60,0.75); }
    body[data-colour="crown"] .commit-btn--customer{ border-color: rgba(225,29,72,0.75); }


    .textarea-shell {
      position: relative;
      display: flex;
      flex-direction: column;
    }

    .textarea-shell textarea {
      width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.98), #020617 52%);
      color: var(--text-main);
      padding: 8px 10px;
      font-size: 0.78rem;
      line-height: 1.6;
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.95);
      resize: none;
      min-height: 110px;
    }

    .textarea-shell textarea::placeholder {
      color: rgba(148, 163, 184, 0.8);
    }

    .textarea-shell textarea:focus {
      outline: none;
      border-color: var(--focus-ring);
      box-shadow: 0 0 0 1px var(--focus-ring), 0 18px 40px rgba(8, 47, 73, 0.9);
    }

    .agent-textarea:focus {
      outline: none;
      border-color: var(--focus-ring);
      box-shadow: 0 0 0 1px var(--focus-ring), 0 18px 40px rgba(8, 47, 73, 0.9);
    }

    /* agent rich text box */
.agent-textarea {
  width: 100%;
  border-radius: 12px;
  border: 1px solid rgba(148, 163, 184, 0.4);
  background: radial-gradient(circle at top, rgba(15, 23, 42, 0.98), #020617 52%);
  color: var(--text-main);
  padding: 8px 10px;
  font-size: 0.78rem;
  line-height: 1.4;
  box-shadow: 0 12px 30px rgba(15, 23, 42, 0.95);

  /* Fixed height with internal scroll */
  min-height: 540px;
  height: 540px;
  max-height: 540px;
  overflow-y: auto;

  /* NEW: keep the box size fixed and wrap text */
  overflow-x: hidden;
  white-space: normal;
  word-wrap: break-word;
  overflow-wrap: break-word;
  overflow-wrap: anywhere;

  outline: none;
}

    .agent-textarea p {
      margin: 0 0 10px 0;
    }
    .agent-textarea p:last-child {
      margin-bottom: 0;
    }
    /* Empty state placeholder */
    .agent-textarea:empty:before {
      content: attr(data-placeholder);
      color: rgba(148, 163, 184, 0.65);
      pointer-events: none;
      font-style: normal;
    }
    body[data-theme="light"] .agent-textarea:empty:before {
      color: rgba(100, 116, 139, 0.6);
    }
    body[data-theme="dark"] .agent-textarea:empty:before,
    body[data-theme="lunar"] .agent-textarea:empty:before {
      color: rgba(203, 213, 225, 0.75);
    }
.agent-textarea .uk-issue {
      border-bottom: 1px dashed #1d4ed8; /* deeper blue: UK spelling suggestion */
      color: #1e3a8a;
      cursor: help;
    }
.agent-textarea .spell-issue {
      border-bottom: 1px dotted #166534; /* darker green for flags */
      color: #14532d;
      cursor: help;
    }



    body[data-theme="light"] .agent-textarea {
      background: #f3f4f6; /* softer light grey instead of pure white */
      border-color: rgba(148, 163, 184, 0.45);
      color: #111827;
      box-shadow: 0 16px 40px rgba(148, 163, 184, 0.55);
    }

    /* locked customer box */
    .locked-textarea {
      resize: none !important;
      height: 110px;
      overflow-y: auto;
    }
    /* Slim glowing scrollbars for text areas + phone chat */
    .agent-textarea::-webkit-scrollbar,
    .locked-textarea::-webkit-scrollbar,
    .chat-body::-webkit-scrollbar,
    .mlcx-notes-input::-webkit-scrollbar,
    .mlcx-training-panel::-webkit-scrollbar,
    .mlcx-pills-row::-webkit-scrollbar {
      width: 6px;
    }

    .agent-textarea::-webkit-scrollbar-track,
    .locked-textarea::-webkit-scrollbar-track,
    .chat-body::-webkit-scrollbar-track,
    .mlcx-notes-input::-webkit-scrollbar-track,
    .mlcx-training-panel::-webkit-scrollbar-track,
    .mlcx-pills-row::-webkit-scrollbar-track {
      background: transparent;
    }

    .agent-textarea::-webkit-scrollbar-thumb,
    .locked-textarea::-webkit-scrollbar-thumb,
    .chat-body::-webkit-scrollbar-thumb,
    .mlcx-notes-input::-webkit-scrollbar-thumb,
    .mlcx-training-panel::-webkit-scrollbar-thumb,
    .mlcx-pills-row::-webkit-scrollbar-thumb {
      border-radius: 999px;
      background: var(--scrollbar-thumb);
      box-shadow: 0 0 10px rgba(15, 23, 42, 0.9);
    }


    .toolbar {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      margin-bottom: 6px;
      gap: 4px;
      flex-wrap: nowrap;
    }

    .toolbar-left {
      display: flex;
      flex-wrap: nowrap;
      gap: 4px;
    }

    .notepad-tools {
      display: none;
      align-items: center;
      gap: 4px;
      margin-left: 10px;
      padding-left: 10px;
      border-left: 1px solid rgba(148, 163, 184, 0.35);
    }

    body[data-layout="notepad"] .notepad-tools {
      display: flex;
      flex-wrap: nowrap;
    }

    .notepad-editor {
      display: none;
      width: 100%;
      min-height: 560px;
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background:
        linear-gradient(145deg, rgba(15, 23, 42, 0.96), rgba(2, 6, 23, 0.88)),
        radial-gradient(circle at top, rgba(30, 64, 175, 0.18), transparent 55%);
      color: var(--text-main);
      padding: 18px 20px;
      font-size: 0.95rem;
      line-height: 1.65;
      box-shadow: 0 24px 65px rgba(15, 23, 42, 0.9);
      overflow-y: auto;
      overflow-x: hidden;
      white-space: normal;
      word-break: break-word;
      outline: none;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    body[data-layout="notepad"] .notepad-editor {
      display: block;
    }

    .notepad-editor:focus {
      border-color: var(--focus-ring);
      box-shadow: 0 0 0 1px var(--focus-ring), 0 28px 70px rgba(8, 47, 73, 0.85);
    }

    .notepad-editor:empty:before {
      content: attr(data-placeholder);
      color: rgba(148, 163, 184, 0.65);
      pointer-events: none;
    }

    body[data-theme="light"] .notepad-editor {
      background:
        linear-gradient(160deg, rgba(255, 255, 255, 0.98), rgba(241, 245, 249, 0.92));
      border-color: rgba(148, 163, 184, 0.5);
      color: #0f172a;
      box-shadow: 0 28px 60px rgba(148, 163, 184, 0.65);
    }

    body[data-theme="light"] .notepad-editor:empty:before {
      color: rgba(100, 116, 139, 0.6);
    }

    .notepad-footer {
      display: none;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      padding: 10px 18px;
      background: rgba(15, 23, 42, 0.65);
      border-top: 1px solid rgba(148, 163, 184, 0.18);
      backdrop-filter: blur(8px);
      font-size: 0.76rem;
      gap: 16px;
      border-radius: 0 0 18px 18px;
      margin-top: auto;
    }

    body[data-layout="notepad"] .notepad-footer {
      display: flex;
    }

    .np-stats span {
      margin-right: 14px;
      color: var(--text-muted);
      white-space: nowrap;
    }

    .np-stats span + span::before {
      content: "\2022";
      margin: 0 6px;
      opacity: 0.45;
      font-size: 0.8em;
    }

    .np-stats {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 6px;
    }

    .np-tools,
    .np-copy-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .np-copy-actions {
      justify-content: flex-end;
    t: center;
    }

    .np-pill {
      padding: 4px 12px;
      border-radius: 999px;
      background: rgba(30, 41, 59, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.4);
      color: var(--text-main);
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.16s ease;
    }

    .np-pill:hover {
      border-color: rgba(148, 163, 184, 0.9);
      background: rgba(51, 65, 85, 0.75);
    }

    .np-pill:focus-visible {
      outline: 2px solid var(--focus-ring);
      outline-offset: 2px;
    }

    .np-drawer-overlay {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 58;
      pointer-events: none;
    }

    .np-drawer-overlay.is-open {
      display: block;
      pointer-events: auto;
    }

    .np-dim {
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top left, rgba(15, 23, 42, 0.7), rgba(15, 23, 42, 0.9));
      opacity: 0;
      transition: opacity 0.2s ease-out;
    }

    .np-drawer-overlay.is-open .np-dim {
      opacity: 1;
    }

    .np-drawer {
      position: absolute;
      top: 0;
      left: 0;
      width: 360px;
      max-width: 86vw;
      height: 100%;
      background:
        radial-gradient(circle at top left, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.98)),
        linear-gradient(180deg, rgba(15, 23, 42, 1), rgba(15, 23, 42, 0.92));
      border-right: 1px solid rgba(148, 163, 184, 0.25);
      box-shadow:
        0 18px 40px rgba(0, 0, 0, 0.9),
        0 0 0 1px rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(18px);
      padding: 18px 22px 16px;
      overflow-y: auto;
      transform: translateX(-100%);
      transition: transform 0.22s ease-out;
      color: var(--text-main);
      display: flex;
      flex-direction: column;
    }

    .np-drawer-overlay.is-open .np-drawer {
      transform: translateX(0);
    }

    /* Messenger Writer Insights drawer (panel scoped) */
    /* Writer Insights role toggle (Messenger) */
    .ms-writer-role-row{
      margin-top: 10px;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .ms-writer-role-toggle{
      display:inline-flex;
      align-items:center;
      gap: 6px;
      padding: 4px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(15,23,42,0.35);
      backdrop-filter: blur(10px);
    }
    body[data-theme="light"] .ms-writer-role-toggle,
    body[data-theme="lunar"] .ms-writer-role-toggle{
      background: rgba(241,245,249,0.7);
      border-color: rgba(148,163,184,0.55);
    }
    .ms-writer-role-btn{
      appearance:none;
      border: 1px solid transparent;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 0.72rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      cursor:pointer;
      color: rgba(226,232,240,0.95);
      background: rgba(30,41,59,0.45);
      transition: transform 0.12s ease-out, box-shadow 0.16s ease-out, border-color 0.16s ease-out, background 0.16s ease-out;
    }
    body[data-theme="light"] .ms-writer-role-btn,
    body[data-theme="lunar"] .ms-writer-role-btn{
      color: rgba(15,23,42,0.9);
      background: rgba(226,232,240,0.75);
    }
    .ms-writer-role-btn:hover{
      transform: translateY(-0.5px);
      border-color: rgba(148,163,184,0.55);
      box-shadow: 0 6px 16px rgba(0,0,0,0.25);
    }
    .ms-writer-role-btn.active{
      border-color: rgba(96,165,250,0.65);
      background: rgba(59,130,246,0.22);
      box-shadow: 0 0 0 1px rgba(59,130,246,0.14), 0 10px 18px rgba(0,0,0,0.25);
    }
    body[data-theme="light"] .ms-writer-role-btn.active,
    body[data-theme="lunar"] .ms-writer-role-btn.active{
      background: rgba(59,130,246,0.16);
    }
    .ms-writer-role-hint{
      font-size: 0.72rem;
      color: rgba(203,213,225,0.92);
      letter-spacing: 0.02em;
      white-space: nowrap;
    }
    body[data-theme="light"] .ms-writer-role-hint,
    body[data-theme="lunar"] .ms-writer-role-hint{
      color: rgba(71,85,105,0.92);
      font-weight: 500;
    }

    .ms-drawer-overlay {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 58;
      pointer-events: none;
    }

    body[data-layout="split"] .ms-drawer-overlay {
      display: block;
    }

    .ms-drawer-overlay.is-open {
      pointer-events: auto;
    }

    .ms-dim {
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top left, rgba(15, 23, 42, 0.7), rgba(15, 23, 42, 0.9));
      opacity: 0;
      transition: opacity 0.2s ease-out;
      border-radius: 18px;
    }

    .ms-drawer-overlay.is-open .ms-dim {
      opacity: 1;
    }

    .ms-drawer {
      position: absolute;
      top: 0;
      left: 0;
      width: 340px;
      max-width: calc(100% - 26px);
      height: 100%;
      background:
        radial-gradient(circle at top right, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.98)),
        linear-gradient(180deg, rgba(15, 23, 42, 1), rgba(15, 23, 42, 0.92));
      border-right: 1px solid rgba(148, 163, 184, 0.25);
      box-shadow:
        0 18px 40px rgba(0, 0, 0, 0.9),
        0 0 0 1px rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(18px);
      padding: 18px 22px 16px;
      overflow: hidden;
      transform: translateX(-100%);
      transition: transform 0.22s ease-out;
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      border-radius: 0 18px 18px 0;
    }

    .ms-drawer-overlay.is-open .ms-drawer {
      transform: translateX(0);
    }

    .np-drawer-header {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 4px;
      margin-bottom: 14px;
      padding-right: 36px;
      position: relative;
    }

    /* Drawer body: keeps header fixed and provides internal scrolling */
    .np-drawer-body{
      flex: 1 1 auto;
      overflow-y: auto;
      padding-right: 4px; /* room for scrollbar without shifting content */
      scrollbar-width: thin;
      scrollbar-color: rgba(148,163,184,0.55) rgba(15,23,42,0.35);
    }
    .np-drawer-body::-webkit-scrollbar{ width: 10px; }
    .np-drawer-body::-webkit-scrollbar-track{
      background: rgba(15,23,42,0.25);
      border-radius: 12px;
    }
    .np-drawer-body::-webkit-scrollbar-thumb{
      background: linear-gradient(180deg, rgba(148,163,184,0.72), rgba(148,163,184,0.38));
      border-radius: 12px;
      border: 2px solid rgba(15,23,42,0.18);
    }
    .np-drawer-body::-webkit-scrollbar-thumb:hover{
      background: linear-gradient(180deg, rgba(226,232,240,0.78), rgba(148,163,184,0.52));
    }

    .np-drawer-header h2 {
      font-size: 0.92rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      margin: 0;
    }

    .np-drawer-header p {
      margin: 2px 0 0;
      font-size: 0.78rem;
      color: rgba(226, 232, 240, 0.85);
    }

    .np-summary-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 6px;
      font-size: 0.72rem;
    }

    .np-summary-chip {
      padding: 3px 7px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.65);
      background:
        radial-gradient(circle at top, rgba(148, 163, 184, 0.24), transparent 55%),
        linear-gradient(135deg, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.86));
      color: #e5f3ff;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      white-space: nowrap;
      opacity: 0.9;
    }

    .np-summary-chip--ok {
      border-color: rgba(74, 222, 128, 0.9);
    }

    .np-summary-chip--warn {
      border-color: rgba(250, 204, 21, 0.9);
    }

    .np-summary-chip--high {
      border-color: rgba(248, 113, 113, 0.95);
    }

    .np-lidcv-coaching strong {
      color: rgba(250, 204, 21, 1);
    }

    .np-drawer-close-btn {
      position: absolute;
      top: 0;
      right: 0;
      border: none;
      border-radius: 999px;
      width: 26px;
      height: 26px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.1rem;
      line-height: 1;
      background: rgba(15, 23, 42, 0.9);
      color: var(--text-main);
      cursor: pointer;
      box-shadow: 0 0 0 1px rgba(148, 163, 184, 0.4);
    }

    .np-drawer-close-btn:hover {
      box-shadow:
        0 0 0 1px rgba(56, 189, 248, 0.8),
        0 0 18px rgba(15, 23, 42, 0.9);
    }

    .np-drawer-section {
      margin-bottom: 14px;
      padding: 14px;
      border-radius: 16px;
      background: rgba(15, 23, 42, 0.88);
      border: 1px solid rgba(148, 163, 184, 0.28);
      min-height: 80px;
      font-size: 0.82rem;
      line-height: 1.45;
      color: rgba(226, 232, 240, 0.95);
    }

    
    /* Writer Insights text wrapping + overflow safety (prevents text escaping cards) */
    .np-drawer-section {
      overflow: hidden; /* keep rounded corners clean */
    }
    .np-drawer-section p,
    .np-drawer-section li,
    .np-drawer-section span,
    .np-drawer-section strong,
    .np-drawer-section em {
      max-width: 100%;
      white-space: normal;
      overflow-wrap: anywhere;
      word-break: break-word;
    }
    .np-drawer-section ul,
    .np-drawer-section ol {
      max-width: 100%;
      padding-left: 18px;
      margin: 8px 0 0;
    }
    .np-drawer-section p { margin: 0; }
    .np-drawer-section p + p { margin-top: 8px; }
.np-drawer-section:empty:after {
      content: "Insights will appear here.";
      color: rgba(255, 255, 255, 0.6);
      font-size: 0.78rem;
    }

    .np-notch {
      display: none;
      position: fixed;
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
      z-index: 59;
      align-items: center;
      justify-content: center;
      padding: 6px 10px;
      min-width: 44px;
      border-radius: 4px 14px 14px 4px;
      background:
        linear-gradient(135deg, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.86)),
        radial-gradient(circle at top right, rgba(148, 163, 184, 0.3), transparent 60%);
      border: 1px solid rgba(148, 163, 184, 0.85);
      box-shadow:
        0 0 0 1px rgba(15, 23, 42, 0.95),
        0 10px 26px rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(18px);
      color: #e5f3ff;
      cursor: pointer;
      font-size: 0.9rem;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      overflow: hidden;
      transition:
        transform 160ms ease-out,
        box-shadow 180ms ease-out,
        border-color 160ms ease-out,
        background 180ms ease-out;
    }

    body[data-layout="notepad"] .np-notch {
      display: inline-flex;
    }

    .np-notch::before {
      content: "";
      position: absolute;
      inset: -30%;
      background:
        linear-gradient(120deg, rgba(148, 163, 184, 0.3), transparent 40%),
        linear-gradient(300deg, rgba(56, 189, 248, 0.4), transparent 55%);
      opacity: 0.4;
      mix-blend-mode: soft-light;
      pointer-events: none;
    }

    .np-notch:hover {
      transform: translateY(-50%) translateX(2px);
      box-shadow:
        0 0 0 1px rgba(56, 189, 248, 0.8),
        0 14px 30px rgba(15, 23, 42, 0.95);
      border-color: rgba(56, 189, 248, 0.95);
    }

    .np-notch:active {
      transform: translateY(-50%) translateX(1px) scale(0.98);
    }

    .np-notch.is-hot {
      border-color: rgba(96, 165, 250, 0.95);
    }

    .ms-notch {
      display: none;
      position: fixed;
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
      z-index: 59;
      align-items: center;
      justify-content: center;
      padding: 6px 10px;
      min-width: 44px;
      border-radius: 4px 14px 14px 4px;
      background:
        linear-gradient(135deg, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.86)),
        radial-gradient(circle at top right, rgba(148, 163, 184, 0.3), transparent 60%);
      border: 1px solid rgba(148, 163, 184, 0.85);
      box-shadow:
        0 0 0 1px rgba(15, 23, 42, 0.95),
        0 10px 26px rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(18px);
      color: #e5f3ff;
      cursor: pointer;
      font-size: 0.9rem;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      overflow: hidden;
      transition:
        transform 160ms ease-out,
        box-shadow 180ms ease-out,
        border-color 160ms ease-out,
        background 180ms ease-out;
    }

    body[data-layout="split"] .ms-notch {
      display: inline-flex;
    }

    .ms-notch::before {
      content: "";
      position: absolute;
      inset: -30%;
      background:
        linear-gradient(120deg, rgba(148, 163, 184, 0.3), transparent 40%),
        linear-gradient(300deg, rgba(56, 189, 248, 0.4), transparent 55%);
      opacity: 0.4;
      mix-blend-mode: soft-light;
      pointer-events: none;
    }

    .ms-notch:hover {
      transform: translateY(-50%) translateX(2px);
      box-shadow:
        0 0 0 1px rgba(56, 189, 248, 0.8),
        0 14px 30px rgba(15, 23, 42, 0.95);
      border-color: rgba(56, 189, 248, 0.95);
    }

    .ms-notch:active {
      transform: translateY(-50%) translateX(1px) scale(0.98);
    }

    .ms-notch.is-hot {
      border-color: rgba(96, 165, 250, 0.95);
    }

    .fmt-btn {
      border: none;
      outline: none;
      background: rgba(15, 23, 42, 0.9);
      color: var(--text-muted);
      font-size: 0.7rem;
      padding: 0.28rem 0.70rem;
      min-height: 32px;
      border-radius: 999px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.06), 0 10px 22px rgba(0,0,0,0.25);
      transition: transform 0.16s ease, box-shadow 0.16s ease, background 0.16s ease, color 0.16s ease, border-color 0.16s ease;
    }
    .fmt-btn.active {
      background: radial-gradient(circle at top, var(--focus-ring), rgba(15, 23, 42, 0.98));
      color: #e5e7eb;
      box-shadow: 0 0 0 1px var(--focus-ring), 0 0 14px rgba(15, 23, 42, 0.9);
      border-color: rgba(148, 163, 184, 0.65);
    }


    .fmt-btn:hover {
      background: rgba(31, 41, 55, 0.95);
      color: #e5e7eb;
    }
    .fmt-btn:active {
      transform: translateY(0px) scale(0.98);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.04), 0 8px 18px rgba(0,0,0,0.22);
    }
    /* Highlight colour palette bubble (appears when clicking Highlight) */
    .highlight-palette {
      position: absolute;
      z-index: 60;
      min-width: 170px;
      padding: 6px 8px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.98);
      border: 1px solid rgba(148, 163, 184, 0.7);
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.9);
      display: none;
      align-items: center;
      gap: 4px;
      font-size: 10px;
      white-space: nowrap;
    }
    .highlight-palette.visible {
      display: inline-flex;
    }
    .highlight-swatch {
      border: none;
      outline: none;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      cursor: pointer;
      padding: 0;
      flex: 0 0 auto;
      box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.85);
    }
    .highlight-swatch:hover {
      box-shadow: 0 0 0 2px var(--focus-ring);
    }
    .highlight-swatch.clear-swatch {
      width: auto;
      padding: 0 8px;
      border-radius: 999px;
      background: transparent;
      color: #e5e7eb;
      border: 1px dashed rgba(148, 163, 184, 0.8);
      font-size: 10px;
    }


    .fmt-btn.clean-btn {
      background: radial-gradient(circle at top, #f97316, #ea580c);
      color: #111827;
      font-weight: 600;
      border-color: rgba(248, 250, 252, 0.3);
    }

    .fmt-btn.clean-btn:hover {
      background: radial-gradient(circle at top, #fb923c, #f97316);
    }

    .char-count-row {
      margin-top: 6px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.74rem;
      color: var(--text-muted);
      gap: 8px;
      flex-wrap: nowrap;
    }

    .char-and-issues {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      flex-wrap: nowrap;
    }

    .issue-counters {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      flex-wrap: nowrap;
    }

    .issue-counter {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 1.5px 7px;
      border-radius: 999px;
      font-size: 0.68rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      white-space: nowrap;
      cursor: pointer;
    }
    .spell-toggle-btn {
      margin-left: 4px;
      padding: 2px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: rgba(15, 23, 42, 0.7);
      color: var(--text-muted);
      font-size: 0.72rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      white-space: nowrap;
      cursor: pointer;
      transition: background 0.18s ease, color 0.18s ease, border-color 0.18s ease, box-shadow 0.18s ease;
    }

    .spell-toggle-btn.is-on {
      background: radial-gradient(circle at top, rgba(56, 189, 248, 0.25), rgba(15, 23, 42, 0.9));
      color: var(--text-main);
      border-color: rgba(56, 189, 248, 0.9);
      box-shadow: 0 0 0 1px rgba(8, 47, 73, 0.7);
    }

    body[data-theme="light"] .spell-toggle-btn {
      background: rgba(248, 250, 252, 0.9);
      color: #475569;
      border-color: rgba(148, 163, 184, 0.9);
    }

    body[data-theme="light"] .spell-toggle-btn.is-on {
      background: radial-gradient(circle at top, rgba(56, 189, 248, 0.18), #eff6ff);
      color: #0f172a;
      border-color: rgba(37, 99, 235, 0.85);
    }



    .issue-counter.uk-counter {
      border: 1px solid rgba(250, 204, 21, 0.7);
      background: radial-gradient(circle at top, rgba(180, 83, 9, 0.85), rgba(30, 64, 175, 0.2));
      color: #fef9c3;
    }

    .issue-counter.spell-counter {
      border: 1px solid rgba(248, 113, 113, 0.85);
      background: radial-gradient(circle at top, rgba(127, 29, 29, 0.85), rgba(15, 23, 42, 0.35));
      color: #fee2e2;
    }

    body[data-theme="light"] .issue-counter.uk-counter {
      border-color: rgba(234, 179, 8, 0.9);
      background: radial-gradient(circle at top, #fef3c7, #facc15);
      color: #78350f;
    }

    body[data-theme="light"] .issue-counter.spell-counter {
      border-color: rgba(220, 38, 38, 0.9);
      background: radial-gradient(circle at top, #fee2e2, #fecaca);
      color: #7f1d1d;
    }

    .char-count-row button {
      border-radius: 999px;
      border: 1px solid rgba(248, 113, 113, 0.5);
      padding: 3px 10px;
      font-size: 0.72rem;
      color: #fecaca;
      background: radial-gradient(circle at top, rgba(127, 29, 29, 0.7), rgba(127, 29, 29, 0.2));
      cursor: pointer;
    }

    .char-count-row button:hover {
      border-color: #fca5a5;
      background: radial-gradient(circle at top, rgba(248, 113, 113, 0.8), rgba(127, 29, 29, 0.4));
    }

    
    .toolbar-right {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: nowrap;
      justify-content: flex-end;
    }


/* === Toolbar refinement: meters, divider, live-dot === */
.mf-sep {
  opacity: 0.55;
  font-weight: 700;
  margin: 0 2px;
  user-select: none;
}

.toolbar-divider {
  width: 1px;
  height: 22px;
  background: linear-gradient(to bottom, rgba(148,163,184,0.12), rgba(148,163,184,0.38), rgba(148,163,184,0.12));
  border-radius: 999px;
  flex: 0 0 1px;
  margin: 0 2px;
}

.mf-live-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  display: inline-block;
  box-shadow: 0 0 0 1px rgba(15,23,42,0.9), 0 0 0 2px rgba(148,163,184,0.18);
  transition: transform 0.16s ease, box-shadow 0.2s ease, filter 0.2s ease, background 0.2s ease;
}
.mf-live-dot.is-idle { background: rgba(148,163,184,0.55); }
.mf-live-dot.is-running { background: rgba(34,197,94,0.85); filter: drop-shadow(0 0 10px rgba(34,197,94,0.35)); }
.mf-live-dot.is-hot { background: rgba(245,158,11,0.9); filter: drop-shadow(0 0 10px rgba(245,158,11,0.35)); }
.mf-live-dot.is-error { background: rgba(239,68,68,0.9); filter: drop-shadow(0 0 10px rgba(239,68,68,0.35)); }

/* Utility: runtime hide (Coaching master toggle) */
.is-hidden{display:none !important;}
/* Coaching master toggle hard-hide (prevents other scripts from re-showing notches) */
body[data-coaching="off"] #cxNotchToggle,
body[data-coaching="off"] #cxNotchCallnotesToggle,
body[data-coaching="off"] .cx-notch,
body[data-coaching="off"] .cx-notch-callnotes,
body[data-coaching="off"] .cx-notch-main,
body[data-coaching="off"] .cx-notch-callnotes-main,
body[data-coaching="off"] #msWriterNotch,
body[data-coaching="off"] .ms-writer-notch,
body[data-coaching="off"] [data-role="writer-insights-notch"]{
  display:none !important;
  visibility:hidden !important;
  opacity:0 !important;
}



.mf-meter-badge {
  padding: 3px 10px;
  border-radius: 999px;
  border: 1px solid rgba(148,163,184,0.38);
  background: rgba(2,6,23,0.35);
  color: rgba(226,232,240,0.82);
  letter-spacing: 0.03em;
  text-transform: none;
  font-weight: 600;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  transition: transform 0.14s ease, box-shadow 0.18s ease, border-color 0.18s ease, filter 0.18s ease, background 0.18s ease;
  white-space: nowrap;
}

/* Make clickable pills feel tactile */
.mf-meter-badge[role="button"],
.mf-action-btn,
.mf-guidance {
  cursor: pointer;
}
.mf-meter-badge[role="button"]:hover,
.mf-action-btn:hover,
.mf-guidance:hover {
  transform: translateY(-1px);
  border-color: rgba(148,163,184,0.62);
  box-shadow: 0 10px 26px rgba(0,0,0,0.28);
  filter: brightness(1.05);
}
.mf-meter-badge[role="button"]:active,
.mf-action-btn:active,
.mf-guidance:active {
  transform: translateY(0px);
  box-shadow: 0 6px 16px rgba(0,0,0,0.22);
  filter: brightness(0.98);
}

/* Guidance toggle states (keeps meaning: OFF = muted highlights) */
#spellToggleBtn.mf-guidance.is-on {
  background: radial-gradient(circle at top, rgba(56, 189, 248, 0.22), rgba(2,6,23,0.6));
  color: rgba(226,232,240,0.95);
  border-color: rgba(56, 189, 248, 0.65);
  box-shadow: 0 0 0 1px rgba(8,47,73,0.65);
}

/* When meters have >0, make them read as "active" */
.mf-meter-badge.is-active {
  border-color: rgba(99,102,241,0.55);
  background: radial-gradient(circle at top, rgba(99,102,241,0.16), rgba(2,6,23,0.45));
  color: rgba(226,232,240,0.95);
  box-shadow: 0 0 0 1px rgba(2,6,23,0.35);
}

/* Day theme: keep toolbar legible */
body[data-theme="light"] .mf-meter-badge {
  background: rgba(248,250,252,0.85);
  color: rgba(15,23,42,0.82);
  border-color: rgba(148,163,184,0.55);
}
body[data-theme="light"] .mf-sep { opacity: 0.6; }
body[data-theme="light"] .toolbar-divider {
  background: linear-gradient(to bottom, rgba(148,163,184,0.18), rgba(148,163,184,0.55), rgba(148,163,184,0.18));
}


    .text-size-inline {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      flex-wrap: nowrap;
    }

    .phone-text-size-row {
      margin-top: 12px;
      display: flex;
      justify-content: center;
    }

    .text-size-inline .text-size-label {
      font-size: 0.74rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-muted);
    }
.font-size-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 8px;
      flex-wrap: nowrap;
      gap: 6px;
      font-size: 0.76rem;
    }

    .colourway-toggle-group {
      display: flex;
      gap: 6px;
      align-items: center;
      flex-wrap: nowrap;
      justify-content: flex-start;
    }

    .colourway-label {
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-muted);
    }

    
    
    .pill-toggle {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      background: radial-gradient(circle at top, rgba(15,23,42,0.82), rgba(15,23,42,0.95));
      box-shadow:
        0 0 0 1px rgba(15,23,42,0.95),
        0 8px 18px rgba(15,23,42,0.75);
    }

    .colourway-current-label {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      font-weight: 500;
      color: rgba(226, 232, 240, 0.9);
      margin-right: 6px;
      white-space: nowrap;
      display: inline-block;
      min-width: 80px; /* lock width to fit 'Sunburst' */
    }

    body[data-theme="light"] .colourway-current-label {
      color: rgba(31, 41, 55, 0.9);
    }

    .pill-button {
      border: none;
      outline: none;
      width: 22px;
      height: 22px;
      padding: 0;
      border-radius: 999px;
      background: transparent;
      cursor: pointer;
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s ease, box-shadow 0.2s ease, transform 0.1s ease;
      font-size: 0;          /* visually hide text labels, keep them for screen readers */
      color: transparent;    /* ensure no text colour bleed */
      white-space: nowrap;
      margin: 0 2px;
    }
/* Phase 4: smooth theme & colourway transitions */
    body,
    .app-shell,
    .chat-body,
    .phone-frame {
      transition:
        background 0.35s cubic-bezier(0.16, 1, 0.3, 1),
        box-shadow 0.35s cubic-bezier(0.16, 1, 0.3, 1),
        border-color 0.35s cubic-bezier(0.16, 1, 0.3, 1),
        color 0.25s ease-out;
    }

    .pill-button {
      transition:
        background 0.25s ease-out,
        color 0.2s ease-out,
        box-shadow 0.25s ease-out,
        transform 0.15s ease-out;
    }

    .pill-button:active {
      transform: translateY(1px) scale(0.98);
    }



    /* Colourway-tinted pills */
    .pill-button[data-colour="classic"] {
      background: linear-gradient(90deg, var(--cw-classic-customer) 0%, transparent 70%);
    }
    .pill-button[data-colour="teal"] {
      background: linear-gradient(90deg, var(--cw-teal-customer) 0%, transparent 70%);
    }
    .pill-button[data-colour="sahara"] {
      background: linear-gradient(90deg, var(--cw-sahara-customer) 0%, transparent 70%);
    }
    .pill-button[data-colour="sunburst"] {
      background: linear-gradient(90deg, var(--cw-sunburst-customer) 0%, transparent 70%);
    }
    .pill-button[data-colour="crown"] {
      background: linear-gradient(90deg, var(--cw-crown-customer) 0%, transparent 70%);
    }
    .pill-button[data-colour="aurora"] {
      background: linear-gradient(90deg, var(--cw-aurora-customer) 0%, transparent 70%);
    }

    .pill-button:hover {
      transform: translateY(-1px);
    }

    .pill-button.active {
      background: radial-gradient(circle at top, #38bdf8 0, #0ea5e9 35%, #1d4ed8 100%);
      color: #0b1220;
      font-weight: 600;
    }

    /* Active colourway pill uses its own primary colours */
    body[data-colour="crown"] .pill-button[data-colour="crown"].active {
      background: radial-gradient(circle at top,
        var(--cw-crown-customer) 0,
        var(--cw-crown-customer-border) 40%,
        #020617 100%);
      color: #0b1120;
    }

    body[data-colour="classic"] .pill-button[data-colour="classic"].active {
      background: radial-gradient(circle at top,
        var(--cw-classic-customer) 0,
        var(--cw-classic-customer-border) 40%,
        #020617 100%);
      color: #0b1120;
    }

    body[data-colour="teal"] .pill-button[data-colour="teal"].active {
      background: radial-gradient(circle at top,
        var(--cw-teal-customer) 0,
        var(--cw-teal-customer-border) 40%,
        #020617 100%);
      color: #0b1120;
    }

    body[data-colour="sunburst"] .pill-button[data-colour="sunburst"].active {
      background: radial-gradient(circle at top,
        var(--cw-sunburst-customer) 0,
        var(--cw-sunburst-customer-border) 40%,
        #020617 100%);
      color: #0b1120;
    }

    body[data-colour="sahara"] .pill-button[data-colour="sahara"].active {
      background: radial-gradient(circle at top,
        var(--cw-sahara-customer) 0,
        var(--cw-sahara-customer-border) 40%,
        #020617 100%);
      color: #0b1120;
    }

    body[data-theme="light"][data-colour="crown"] .pill-button[data-colour="crown"].active {
      background: radial-gradient(circle at top,
        var(--cw-crown-light-customer) 0,
        var(--cw-crown-light-customer-border) 40%,
        #ffffff 100%);
      color: #111827;
    }

    body[data-theme="light"][data-colour="classic"] .pill-button[data-colour="classic"].active {
      background: radial-gradient(circle at top,
        var(--cw-classic-light-customer) 0,
        var(--cw-classic-light-customer-border) 40%,
        #ffffff 100%);
      color: #111827;
    }

    body[data-theme="light"][data-colour="teal"] .pill-button[data-colour="teal"].active {
      background: radial-gradient(circle at top,
        var(--cw-teal-light-customer) 0,
        var(--cw-teal-light-customer-border) 40%,
        #ffffff 100%);
      color: #111827;
    }

    body[data-theme="light"][data-colour="sunburst"] .pill-button[data-colour="sunburst"].active {
      background: radial-gradient(circle at top,
        var(--cw-sunburst-light-customer) 0,
        var(--cw-sunburst-light-customer-border) 40%,
        #ffffff 100%);
      color: #111827;
    }

    body[data-theme="light"][data-colour="sahara"] .pill-button[data-colour="sahara"].active {
      background: radial-gradient(circle at top,
        var(--cw-sahara-light-customer) 0,
        var(--cw-sahara-light-customer-border) 40%,
        #ffffff 100%);
      color: #111827;
    }

    .theme-toggle {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 0;
      border-radius: 999px;
      border: none;
      background: transparent;
    }

    .theme-toggle button {
      border-width: 1px;
      border-style: solid;
      border-color: rgba(148, 163, 184, 0.45);
      outline: none;
      font-size: 0.7rem;
      padding: 4px 9px;
      border-radius: 999px;
      background: transparent;
      color: var(--text-muted);
      cursor: pointer;
      white-space: nowrap;
      transition: background 0.2s, color 0.2s, border-color 0.2s;
    }

    .theme-toggle button.active {
      background: #f9fafb;
      color: #111827;
      font-weight: 600;
    }

    /* Dice shuffle button within the theme toggle */
    .theme-toggle .dice-toggle {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.95), rgba(15, 23, 42, 0.8));
      color: #e5e7eb;
      padding: 4px 9px;
      font-size: 0.8rem;
      min-height: 30px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(15, 23, 42, 0.7);
      transition: transform 0.08s ease, box-shadow 0.1s ease, background 0.2s ease;
    }
    .dice-toggle.is-spinning {
      animation: dice-spin 0.35s ease-in-out;
    }

    @keyframes dice-spin {
      0% {
        transform: rotate(0deg) scale(1);
        filter: brightness(1);
      }
      30% {
        transform: rotate(120deg) scale(1.05);
        filter: brightness(1.2);
      }
      70% {
        transform: rotate(-12deg) scale(1.02);
        filter: brightness(1.1);
      }
      100% {
        transform: rotate(0deg) scale(1);
        filter: brightness(1);
      }
    }
    /* Pulse-glow cue for active controls after shuffle / auto-shuffle */
    .mf-pulse-glow {
      animation: mf-pulse-glow 0.75s ease-out 1;
    }
    @keyframes mf-pulse-glow {
      0% { box-shadow: 0 0 0 0 rgba(255,255,255,0.00), 0 0 0 0 rgba(255,255,255,0.00); filter: brightness(1); }
      35% { box-shadow: 0 0 0 3px rgba(255,255,255,0.18), 0 0 22px 0 rgba(255,255,255,0.18); filter: brightness(1.15); }
      100% { box-shadow: 0 0 0 0 rgba(255,255,255,0.00), 0 0 0 0 rgba(255,255,255,0.00); filter: brightness(1); }
    }


    .theme-toggle .dice-toggle:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(15, 23, 42, 0.85);
    }

    .theme-toggle .dice-toggle:active {
      transform: translateY(0);
      box-shadow: 0 3px 10px rgba(15, 23, 42, 0.7);
    }

    body[data-theme="light"] .theme-toggle .dice-toggle {
      border-color: rgba(148, 163, 184, 0.8);
      background: radial-gradient(circle at top, #e5ecff, #dbeafe);
      color: #1f2937;
      box-shadow: 0 3px 12px rgba(148, 163, 184, 0.7);
    }

    .shuffle-toggle {
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .shuffle-toggle button {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.95), rgba(15, 23, 42, 0.8));
      color: #e5e7eb;
      padding: 4px 9px;
      font-size: 0.9rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(15, 23, 42, 0.7);
      transition: transform 0.08s ease, box-shadow 0.1s ease, background 0.2s ease;
    }

    .shuffle-toggle .dice-icon {
      font-size: 1.05rem;
      line-height: 1;
      display: inline-block;
      transform: translateY(-0.5px);
    }

    .shuffle-toggle button:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(15, 23, 42, 0.85);
    }

    .shuffle-toggle button:active {
      transform: translateY(0);
      box-shadow: 0 3px 10px rgba(15, 23, 42, 0.7);
    }

    body[data-theme="light"] .shuffle-toggle button {
      border-color: rgba(148, 163, 184, 0.8);
      background: radial-gradient(circle at top, #e5ecff, #dbeafe);
      color: #1f2937;
      box-shadow: 0 3px 12px rgba(148, 163, 184, 0.7);
    }

    /* focus outline for keyboard users */
    button:focus-visible,
    .issue-counter:focus-visible,
    .pill-button:focus-visible {
      outline: 2px solid #38bdf8;
      outline-offset: 2px;
    }


    /* MLCX Notepad layout – large notes editor + coaching cards */
    .mlcx-layout {
      display: grid;
      grid-template-columns: 2.1fr 1.3fr;
      gap: 20px;
      align-items: stretch;
      margin-top: 6px;
      min-height: 0;
      height: 100%;
    }

    /* Minimal Call Notes panel styles (scoped) */
    .callnotes-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }
    .callnotes-title {
      font-size: 0.98rem;
      font-weight: 600;
      letter-spacing: 0.03em;
    }
    .callnotes-actions {
      display: none; /* Hidden - use footer toolbar instead */
    }
    .callnotes-container {
      display: flex;
      gap: 12px;
      height: 100%;
      max-height: 100%;
      min-height: 0;
      overflow: hidden;
      width: 100%;
    }
    .callnotes-left {
      flex: 1 1 60%;
      display: flex;
      flex-direction: column;
      gap: 0;
      min-height: 0;
      min-width: 0;
    }
    .callnotes-right {
      flex: 0 0 38%;
      display: flex;
      flex-direction: column;
      min-height: 0;
      max-height: 100%;
      height: 100%;
      min-width: 0;
      overflow: hidden;
    }
    .callnotes-input {
      flex: 1 1 auto;
      width: 100%;
      border-radius: 12px;
      border: 1px solid #E5E5E5; /* soft border */
      background: #ffffff; /* white background */
      color: #0f172a; /* dark readable text */
      caret-color: rgba(56,189,248,0.9);
      padding: 12px;
      font-size: 0.95rem; /* slightly larger for readability */
      line-height: 1.6;   /* more comfortable line height */
      box-shadow: inset 0 1px 0 rgba(0,0,0,0.03); /* subtle inset, similar to Messenger */
      min-height: 0;
      height: 100%;
      resize: none;
      overflow: auto; /* internal scroll */
      transition: border-color 200ms ease, box-shadow 200ms ease;
    }
    .callnotes-input:focus {
      outline: none;
      border-color: rgba(56,189,248,0.5);
      box-shadow: 0 0 0 3px rgba(56,189,248,0.15),
                  0 0 24px rgba(56,189,248,0.25);
    }
    .callnotes-input::placeholder {
      color: rgba(148, 163, 184, 0.9);
    }
    body[data-theme="dark"] .callnotes-input,
    body[data-theme="lunar"] .callnotes-input {
      background:
        radial-gradient(circle at 0 0, rgba(255,255,255,0.08), transparent 55%),
        radial-gradient(circle at 100% 0, rgba(255,255,255,0.06), transparent 60%),
        radial-gradient(circle at top left, #020617, #020617);
      color: var(--text-main);
      box-shadow:
        0 0 0 1px rgba(255,255,255,0.08),
        inset 0 0 0 1px rgba(148, 163, 184, 0.4),
        0 18px 40px rgba(0,0,0,0.45);
    }
    /* Explicit lunar text colour to mirror dark visibility */
    body[data-theme="lunar"] .callnotes-input {
      color: #f7f9ff; /* bright readable text in lunar */
    }
    body[data-theme="dark"] .callnotes-input::placeholder,
    body[data-theme="lunar"] .callnotes-input::placeholder {
      color: rgba(203, 213, 225, 0.9);
    }
    
    /* Unified Call Notes footer layout */
    .callnotes-footer-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.75rem;
      margin-top: 0.5rem;
      margin-bottom: 0.35rem;
      flex-wrap: wrap;
    }
    .callnotes-status.char-count-row {
      padding: 0;
      border: none;
      background: transparent;
    }
    .callnotes-status .char-and-issues {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      font-size: 11px;
      opacity: 0.9;
    }
    .callnotes-toolbar-row {
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    /* Tactile toolbar pills for Call Notes */
    .callnotes-toolbar-row .toolbar-pill {
      padding: 0.25rem 0.75rem;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.08);
      background: radial-gradient(circle at top left,
        rgba(255,255,255,0.12),
        rgba(0,0,0,0.4));
      font-size: 11px;
      letter-spacing: 0.03em;
      text-transform: none;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.35),
                  0 6px 14px rgba(0,0,0,0.4);
      transition: transform 120ms ease, box-shadow 120ms ease, background 120ms ease;
      cursor: pointer;
    }
    .callnotes-toolbar-row .toolbar-pill:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 18px rgba(0,0,0,0.6);
    }
    .callnotes-toolbar-row .toolbar-pill:active {
      transform: translateY(0);
      box-shadow: 0 2px 8px rgba(0,0,0,0.5) inset;
    }
    /* Dark/Lunar mode: greyscale readable styling */
    body[data-theme="dark"] .callnotes-toolbar-row .toolbar-pill,
    body[data-theme="lunar"] .callnotes-toolbar-row .toolbar-pill {
      color: rgba(226,232,240,0.95);
      background: radial-gradient(circle at top left,
        rgba(148,163,184,0.25),
        rgba(30,41,59,0.7));
      border: 1px solid rgba(148,163,184,0.3);
      box-shadow: 0 0 0 1px rgba(15,23,42,0.5),
                  0 6px 14px rgba(0,0,0,0.6);
    }
    body[data-theme="dark"] .callnotes-toolbar-row .toolbar-pill:hover,
    body[data-theme="lunar"] .callnotes-toolbar-row .toolbar-pill:hover {
      background: radial-gradient(circle at top left,
        rgba(148,163,184,0.35),
        rgba(51,65,85,0.8));
      box-shadow: 0 8px 20px rgba(0,0,0,0.7);
    }
    .callnotes-card {
      display: flex;
      flex-direction: column;
      background:
        radial-gradient(circle at 0 0, rgba(255,255,255,0.16), rgba(255,255,255,0.06));
      border-radius: 18px;
      box-shadow:
        0 10px 30px rgba(0,0,0,0.15);
      border: 1px solid rgba(148, 163, 184, 0.25);
      padding: 0;
      min-height: 120px;
      max-height: 33%;
      overflow: hidden; /* header stays, body scrolls */
    }
    body[data-theme="dark"] .callnotes-card,
    body[data-theme="lunar"] .callnotes-card {
      background:
        radial-gradient(circle at 0 0, rgba(255,255,255,0.12), rgba(255,255,255,0.04));
      box-shadow:
        0 10px 30px rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.10);
    }
    .callnotes-card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 14px 6px;
      font-size: 0.72rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: #0f172a;
    }
    body[data-theme="dark"] .callnotes-card-header,
    body[data-theme="lunar"] .callnotes-card-header {
      color: rgba(248, 250, 252, 0.85);
    }
    .callnotes-card-label-pill {
      font-size: 0.62rem;
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(15,23,42,0.08);
      color: rgba(15,23,42,0.55);
      font-weight: 500;
    }
    body[data-theme="dark"] .callnotes-card-label-pill,
    body[data-theme="lunar"] .callnotes-card-label-pill {
      background: rgba(248, 250, 252, 0.12);
      color: rgba(248, 250, 252, 0.65);
    }
    .callnotes-card-body {
      flex: 1 1 auto;
      overflow-y: auto; /* self scroll area */
      overflow-x: hidden; /* prevent sideways scroll */
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-content: flex-start;
      padding: 8px 12px 10px;
      color: #111827;
      font-size: 0.74rem;
      line-height: 1.4;
      border-radius: 16px;
    }
    body[data-theme="dark"] .callnotes-card-body,
    body[data-theme="lunar"] .callnotes-card-body {
      color: rgba(248, 250, 252, 0.9);
    }
    /* Smooth card body scrollbars */
    .callnotes-card-body::-webkit-scrollbar {
      height: 4px;
      width: 4px;
    }
    .callnotes-card-body::-webkit-scrollbar-thumb {
      border-radius: 999px;
      background: rgba(15,23,42,0.22);
    }
    body[data-theme="dark"] .callnotes-card-body::-webkit-scrollbar-thumb,
    body[data-theme="lunar"] .callnotes-card-body::-webkit-scrollbar-thumb {
      background: rgba(148, 163, 184, 0.35);
    }
    .callnotes-chip {
      display: inline-flex;
      align-items: center;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid #E5E5E5;
      background: #ffffff;
      color: #374151;
      font-size: 0.72rem;
      white-space: nowrap;
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;   /* show … instead of pushing layout */
    }
    .callnotes-chip strong {
      margin-right: 6px;
      color: #111827;
    }

    .callnotes-card-footer {
      margin-top: 6px;
      font-size: 0.7rem;
      color: rgba(15, 23, 42, 0.6);
      padding: 0 12px 10px; /* keep subtle spacing consistent with body */
    }
    body[data-theme="dark"] .callnotes-card-footer,
    body[data-theme="lunar"] .callnotes-card-footer {
      color: rgba(248, 250, 252, 0.75);
    }
    body[data-theme="light"] .callnotes-card-footer {
      color: rgba(15, 23, 42, 0.6);
    }

    .mlcx-notes-column,
    .mlcx-train-column {
      display: flex;
      flex-direction: column;
    }

    .mlcx-notes-textarea {
      flex: 1 1 auto;
      min-height: 240px;
      max-height: 100%;
      resize: vertical;
      border-radius: 0.75rem;
      padding: 10px 12px;
      border: none;
      font-family: inherit;
      font-size: 0.95rem;
      line-height: 1.4;
      box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.65);
    }

    .mlcx-notes-actions {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .mlcx-training-panel {
      display: flex;
      flex-direction: column;
      gap: 12px;
      height: 100%;
    }

    .mlcx-training-card h3 {
      margin: 0 0 4px;
      font-size: 0.95rem;
    }

    .mlcx-training-card p {
      margin: 0;
      font-size: 0.85rem;
      opacity: 0.86;
    }

    .mlcx-notes-column,
    .mlcx-train-column {
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    .mlcx-notes-column {
      flex: 3 1 0;
    }
    .mlcx-train-column {
      flex: 2 1 0;
    }
    .mlcx-notes-shell {
      position: relative;
      display: flex;
      flex-direction: column;
      flex: 1 1 auto;
      min-height: 0;
    }
    .mlcx-pills-row {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: flex-start;
      max-height: 90px;
      overflow-y: auto;
      padding-right: 4px;
    }

    .mlcx-notes-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .cv-btn {
      display: none;
      align-items: center;
      gap: 4px;
      padding: 3px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background:
        radial-gradient(circle at top, rgba(15, 23, 42, 0.94), rgba(15, 23, 42, 0.88));
      color: var(--text-main);
      font-size: 0.7rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
      backdrop-filter: blur(10px);
      box-shadow: 0 0 0 0 rgba(56, 189, 248, 0);
      transition:
        background 150ms ease-out,
        box-shadow 150ms ease-out,
        transform 120ms ease-out;
    }
    body[data-theme="light"] .cv-btn {
      background:
        radial-gradient(circle at top, rgba(248, 250, 252, 0.96), rgba(226, 232, 240, 0.92));
      color: #0f172a;
      border-color: rgba(148, 163, 184, 0.9);
    }
    .cv-btn:hover {
      box-shadow: 0 0 10px rgba(56, 189, 248, 0.6);
      transform: translateY(-0.5px);
    }
    .cv-btn:active {
      transform: translateY(0.5px) scale(0.98);
      box-shadow: 0 0 4px rgba(56, 189, 248, 0.5);
    }
    .cv-btn-icon {
      font-size: 0.9rem;
    }

    /* CV overlay dropdown */
    .cv-overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.86), rgba(15, 23, 42, 0.92));
      backdrop-filter: blur(18px);
      z-index: 40;
    }
    body[data-theme="light"] .cv-overlay {
      background: radial-gradient(circle at top, rgba(241, 245, 249, 0.94), rgba(226, 232, 240, 0.96));
    }
    .cv-overlay.is-visible {
      display: flex;
    }
    .cv-inner {
      width: min(560px, 96%);
      max-height: 90%;
      border-radius: 20px;
      padding: 14px 16px 16px;
      background:
        radial-gradient(circle at top, rgba(15, 23, 42, 0.98), rgba(15, 23, 42, 0.96));
      border: 1px solid rgba(148, 163, 184, 0.8);
      box-shadow:
        0 24px 60px rgba(15, 23, 42, 0.85),
        0 0 0 1px rgba(15, 23, 42, 0.9);
      transform: scale(0.94);
      opacity: 0;
      transition:
        transform 160ms cubic-bezier(0.16, 0.9, 0.3, 1),
        opacity 160ms ease-out;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .cv-overlay.is-visible .cv-inner {
      transform: scale(1);
      opacity: 1;
    }
    .cv-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 4px;
    }
    .cv-header-main {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .cv-title {
      font-size: 0.9rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }
    .cv-subtitle {
      font-size: 0.7rem;
      opacity: 0.78;
    }
    .cv-close-btn {
      border: none;
      border-radius: 999px;
      padding: 4px 8px;
      background: rgba(15, 23, 42, 0.7);
      color: var(--text-main);
      cursor: pointer;
      font-size: 0.8rem;
    }
    body[data-theme="light"] .cv-close-btn {
      background: rgba(148, 163, 184, 0.2);
      color: #0f172a;
    }
    .cv-content {
      overflow-y: auto;
      padding-top: 4px;
      padding-right: 4px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .cv-block {
      border-radius: 14px;
      padding: 8px 10px;
      border: 1px solid rgba(148, 163, 184, 0.65);
      background:
        radial-gradient(circle at top, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.92));
      font-size: 0.76rem;
      line-height: 1.4;
    }
    body[data-theme="light"] .cv-block {
      background:
        radial-gradient(circle at top, rgba(248, 250, 252, 0.98), rgba(226, 232, 240, 0.96));
    }
    .cv-block-title {
      font-weight: 600;
      margin-bottom: 2px;
      font-size: 0.78rem;
    }
    .cv-chips-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 4px;
      max-height: 180px;
      overflow-y: auto;
      padding-right: 4px;
    }
    .cv-chip {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      padding: 2px 7px;
      font-size: 0.7rem;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .cv-chip-icon {
      font-size: 0.8rem;
    }
    .cv-ghost {
      font-size: 0.72rem;
      opacity: 0.72;
    }
    .cv-list {
      margin: 4px 0 0;
      padding-left: 16px;
    }
    .cv-list li {
      margin-bottom: 2px;
    }

    /* Compact summary strip inside CV overlay */
    .cv-summary-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 8px;
    }
    .cv-summary-title {
      font-size: 0.78rem;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      opacity: 0.9;
    }
    .cv-summary-band {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 3px 9px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.85);
      font-size: 0.7rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      background:
        radial-gradient(circle at top, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.9));
      box-shadow:
        0 10px 24px rgba(15, 23, 42, 0.85),
        0 0 0 1px rgba(15, 23, 42, 0.85);
    }
    .cv-summary-band-label {
      font-weight: 600;
    }
    .cv-summary-band-count {
      opacity: 0.85;
    }
    .cv-band-low {
      border-color: rgba(34, 197, 94, 0.7);
      box-shadow:
        0 10px 26px rgba(22, 163, 74, 0.36),
        0 0 0 1px rgba(22, 163, 74, 0.75);
    }
    .cv-band-medium {
      border-color: rgba(245, 158, 11, 0.8);
      box-shadow:
        0 10px 26px rgba(245, 158, 11, 0.32),
        0 0 0 1px rgba(217, 119, 6, 0.82);
    }
    .cv-band-high {
      border-color: rgba(239, 68, 68, 0.86);
      box-shadow:
        0 10px 26px rgba(239, 68, 68, 0.38),
        0 0 0 1px rgba(220, 38, 38, 0.9);
    }
    body[data-theme="day"] .cv-summary-band,
    body[data-theme="lunar"] .cv-summary-band {
      background:
        radial-gradient(circle at top, rgba(248, 250, 252, 0.98), rgba(229, 231, 235, 0.98));
      color: #0f172a;
    }
    .mlcx-pill {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 4px 8px;
      font-size: 0.7rem;
      line-height: 1.2;
      border: 1px solid rgba(148, 163, 184, 0.6);
      background:
        radial-gradient(circle at top, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.9));
      color: var(--text-muted);
      white-space: nowrap;
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    body[data-theme="light"] .mlcx-pill {
      background: radial-gradient(circle at top, #f9fafb, #e5e7eb);
      color: #111827;
    }

    .mlcx-notes-input {
      width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.98), #020617 52%);
      color: var(--text-main);
      padding: 10px 11px;
      font-size: 0.8rem;
      line-height: 1.55;
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.95);
      resize: none;
      min-height: 60vh;
      height: 60vh;
      max-height: 60vh;
      overflow-y: auto;
    }
    .mlcx-notes-input::placeholder {
      color: rgba(148, 163, 184, 0.85);
    }
    body[data-theme="light"] .mlcx-notes-input {
      background: #f3f4f6;
      border-color: rgba(148, 163, 184, 0.45);
      color: #111827;
      box-shadow: 0 16px 40px rgba(148, 163, 184, 0.55);
    }
    .mlcx-notes-input:focus {
      outline: none;
      border-color: var(--focus-ring);
      box-shadow: 0 0 0 1px var(--focus-ring), 0 18px 40px rgba(8, 47, 73, 0.9);
    }

    .mlcx-training-panel {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 10px 11px;
      border-radius: 12px;
      max-height: 100%;
      overflow-y: auto;
      border: 1px solid rgba(148, 163, 184, 0.5);
      background:
        radial-gradient(circle at top left, rgba(148, 163, 184, 0.16), transparent 55%),
        linear-gradient(145deg, #020617, #020617 40%, #020818 100%);
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.9);
      font-size: 0.76rem;
      color: var(--text-muted);
    }
    body[data-theme="light"] .mlcx-training-panel {
      background:
        radial-gradient(circle at top left, rgba(148, 163, 184, 0.16), transparent 55%),
        linear-gradient(145deg, #f9fafb, #e5e7eb 40%, #e5e7eb 100%);
      box-shadow: 0 16px 40px rgba(148, 163, 184, 0.55);
    }
    .mlcx-training-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
      font-size: 0.74rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }
    .mlcx-training-pill {
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.55);
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.85));
      font-size: 0.68rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }
    .mlcx-card {
      border-radius: 10px;
      padding: 7px 9px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.9));
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    body[data-theme="light"] .mlcx-card {
      background: radial-gradient(circle at top, #f9fafb, #e5e7eb);
    }
    .mlcx-card-title-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 2px;
    }
    .mlcx-card-title {
      font-size: 0.74rem;
      font-weight: 500;
    }
    .mlcx-card-tag {
      font-size: 0.64rem;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      opacity: 0.8;
    }
    /* Phase 12: MLCX / CiVC category colour tags */
    .mlcx-pill[class*="mlcx-pill--"],
    .mlcx-card-tag[class*="mlcx-tag--"],
    .mlcv-chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .mlcx-tag-icon {
      font-size: 0.8rem;
    }

    /* Emotional / MLCX categories */
    .mlcx-tag--frustration,
    .mlcx-pill--frustration {
      border-color: rgba(248, 113, 113, 0.95);
      color: #fecaca;
    }
    .mlcx-tag--confusion,
    .mlcx-pill--confusion {
      border-color: rgba(96, 165, 250, 0.9);
      color: #bfdbfe;
    }
    .mlcx-tag--anxiety,
    .mlcx-pill--anxiety {
      border-color: rgba(251, 191, 36, 0.95);
      color: #facc15;
    }
    .mlcx-tag--urgency,
    .mlcx-pill--urgency {
      border-color: rgba(250, 204, 21, 0.95);
      color: #fef9c3;
    }
    .mlcx-tag--cost,
    .mlcx-pill--cost {
      border-color: rgba(234, 179, 8, 0.95);
      color: #fef3c7;
    }
    .mlcx-tag--routing,
    .mlcx-pill--routing {
      border-color: rgba(192, 132, 252, 0.95);
      color: #e9d5ff;
    }

    /* CiVC categories */
    .civc-tag--financial {
      border-color: rgba(234, 179, 8, 0.95);
      color: #fef3c7;
    }
    .civc-tag--mental {
      border-color: rgba(244, 114, 182, 0.9);
      color: #fbcfe8;
    }
    .civc-tag--safeguarding {
      border-color: rgba(248, 113, 113, 0.98);
      color: #fee2e2;
    }
    .civc-tag--disability {
      border-color: rgba(52, 211, 153, 0.95);
      color: #d1fae5;
    }
    .civc-tag--bereavement {
      border-color: rgba(148, 163, 184, 0.9);
      color: #e5e7eb;
    }
    .civc-tag--language {
      border-color: rgba(56, 189, 248, 0.95);
      color: #cffafe;
    }
    .civc-tag--digital {
      border-color: rgba(129, 140, 248, 0.95);
      color: #e0e7ff;
    }

    /* Vulnerability severity pill styling */
    .mlcx-vuln-line {
      margin-bottom: 4px;
      font-size: 0.85rem;
    }

    .mlcx-vuln-pill {
      display: inline-block;
      margin-left: 6px;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    /* Neutral baseline */
    .mlcx-vuln-pill--none {
      border: 1px solid rgba(255, 255, 255, 0.16);
      background: rgba(255, 255, 255, 0.04);
    }

    /* Subtle traffic-light-style emphasis */
    .mlcx-vuln-pill--low {
      border: 1px solid rgba(120, 200, 120, 0.4);
      background: rgba(120, 200, 120, 0.12);
    }

    .mlcx-vuln-pill--medium {
      border: 1px solid rgba(230, 190, 120, 0.5);
      background: rgba(230, 190, 120, 0.16);
    }

    .mlcx-vuln-pill--high {
      border: 1px solid rgba(230, 120, 120, 0.7);
      background: rgba(230, 120, 120, 0.22);
    }

    .mlcx-card-body {
      font-size: 0.72rem;
      line-height: 1.4;
    }
    .mlcx-card-body ul {
      padding-left: 1.1em;
      margin: 2px 0 0;
    }
    .mlcx-card-body li {
      margin: 1px 0;
    }
    @media (max-width: 1100px) {
      .mlcx-layout {
      display: grid;
      grid-template-columns: 2.1fr 1.3fr;
      gap: 16px;
      align-items: stretch;
      margin-top: 6px;
      min-height: 0;
      height: 100%;
    }
      .mlcx-notes-input {
        min-height: 200px;
        height: 200px;
      }
    }

    .preview-panel {
      flex: 0 1 440px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: center;
      justify-content: flex-start;
    }

    .preview-badges {
      display: flex;
      justify-content: center;
      width: 100%;
      /* Push the badge downward so it aligns closer to the phone's top bezel */
      margin-top: 10px;
      margin-bottom: 4px;
      font-size: 0.7rem;
      pointer-events: none;
    }

    .badge-pill {
      padding: 4px 12px;
      border-radius: 999px;
      border: 1px solid rgba(191, 219, 254, 0.75);
      background: radial-gradient(circle at top, rgba(129, 140, 248, 0.95), rgba(15, 23, 42, 0.95));
      font-size: 0.65rem;
      color: #e5e7eb;
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }

    .text-size-row {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
      font-size: 0.7rem;
    }

    .text-size-label {
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #9ca3af;
    }

    .text-size-buttons {
      display: flex;
      gap: 4px;
    }

    .text-size-btn {
      min-width: 46px;
      padding: 3px 9px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: rgba(15, 23, 42, 0.9);
      color: #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 0.70rem;
    }

    /* Keep all bottom controls visually aligned (same pill height/shape) */
    .issue-counter,
    .text-size-btn,
    .char-actions button {
      border-radius: 999px;
      min-height: 24px;
    }

    .text-size-btn span {
      line-height: 1;
    }

    .text-size-btn[data-size="xs"] span { font-size: 0.58rem; }
    .text-size-btn[data-size="sm"] span { font-size: 0.66rem; }
    .text-size-btn[data-size="md"] span { font-size: 0.74rem; }
    .text-size-btn[data-size="lg"] span { font-size: 0.82rem; }

    .text-size-btn.is-active {
      border-color: var(--cw-classic-customer-border);
      background: var(--cw-classic-customer);
      color: #f9fafb;
    }

    body[data-colour="teal"] .text-size-btn.is-active {
      border-color: var(--cw-teal-customer-border);
      background: var(--cw-teal-customer);
    }

    body[data-colour="sahara"] .text-size-btn.is-active {
      border-color: var(--cw-sahara-customer-border);
      background: var(--cw-sahara-customer);
    }

    body[data-colour="sunburst"] .text-size-btn.is-active {
      border-color: var(--cw-sunburst-customer-border);
      background: var(--cw-sunburst-customer);
    }

    body[data-colour="crown"] .text-size-btn.is-active {
      border-color: var(--cw-crown-customer-border);
      background: var(--cw-crown-customer);
    }

    body[data-colour="aurora"] .text-size-btn.is-active {
      border-color: var(--cw-aurora-customer-border);
      background: var(--cw-aurora-customer);
    }

    .phone-frame {
      margin: 4px auto 0;
      width: 380px;
      max-width: 100%;
      aspect-ratio: 9 / 19;
      border-radius: 2.3rem;
      background: #111827;
      padding: 5px;
      border: 2px solid #111827;
      box-shadow: 0 26px 60px rgba(0, 0, 0, 0.9);
      position: relative;
      display: flex;
      flex-direction: column;
      overflow: visible;
      /* make sure the phone never grows taller than the viewport */
      max-height: calc(100vh - 80px);
    }

    /* colourway tint for phone frame – theme-adaptive glow */
    /* Rift */
    body[data-colour="classic"] .phone-frame {
      border-color: #1d4ed8;
    }
    body[data-theme="dark"][data-colour="classic"] .phone-frame {
      box-shadow: 0 26px 60px rgba(37, 99, 235, 0.60);
    }
    body[data-theme="lunar"][data-colour="classic"] .phone-frame {
      box-shadow: 0 22px 52px rgba(37, 99, 235, 0.46);
    }
    body[data-theme="light"][data-colour="classic"] .phone-frame {
      box-shadow: 0 18px 40px rgba(37, 99, 235, 0.30);
    }

    /* The Grove (teal) */
    body[data-colour="teal"] .phone-frame {
      border-color: #0f766e;
    }
    body[data-theme="dark"][data-colour="teal"] .phone-frame {
      box-shadow: 0 26px 60px rgba(13, 148, 136, 0.65);
    }
    body[data-theme="lunar"][data-colour="teal"] .phone-frame {
      box-shadow: 0 22px 52px rgba(13, 148, 136, 0.50);
    }
    body[data-theme="light"][data-colour="teal"] .phone-frame {
      box-shadow: 0 18px 40px rgba(13, 148, 136, 0.32);
    }

    /* Sahara */
    body[data-colour="sahara"] .phone-frame {
      border-color: #a16207;
    }
    body[data-theme="dark"][data-colour="sahara"] .phone-frame {
      box-shadow: 0 26px 60px rgba(234, 179, 8, 0.55);
    }
    body[data-theme="lunar"][data-colour="sahara"] .phone-frame {
      box-shadow: 0 22px 52px rgba(234, 179, 8, 0.44);
    }
    body[data-theme="light"][data-colour="sahara"] .phone-frame {
      box-shadow: 0 18px 40px rgba(234, 179, 8, 0.30);
    }

    /* Sunburst */
    body[data-colour="sunburst"] .phone-frame {
      border-color: #c2410c;
    }
    body[data-theme="dark"][data-colour="sunburst"] .phone-frame {
      box-shadow: 0 26px 60px rgba(249, 115, 22, 0.60);
    }
    body[data-theme="lunar"][data-colour="sunburst"] .phone-frame {
      box-shadow: 0 22px 52px rgba(249, 115, 22, 0.48);
    }
    body[data-theme="light"][data-colour="sunburst"] .phone-frame {
      box-shadow: 0 18px 40px rgba(249, 115, 22, 0.32);
    }

    /* The Crown – keep light mode close to original glow */
    body[data-colour="crown"] .phone-frame {
      border-color: #e11d48;
    }
    body[data-theme="dark"][data-colour="crown"] .phone-frame {
      box-shadow: 0 26px 60px rgba(244, 63, 94, 0.65);
    }
    body[data-theme="lunar"][data-colour="crown"] .phone-frame {
      box-shadow: 0 22px 52px rgba(244, 63, 94, 0.52);
    }
    body[data-theme="light"][data-colour="crown"] .phone-frame {
      box-shadow: 0 26px 60px rgba(244, 63, 94, 0.55);
    }

    /* Aurora */
    body[data-colour="aurora"] .phone-frame {
      border-color: #7c3aed;
    }
    body[data-theme="dark"][data-colour="aurora"] .phone-frame {
      box-shadow: 0 26px 60px rgba(129, 140, 248, 0.62);
    }
    body[data-theme="lunar"][data-colour="aurora"] .phone-frame {
      box-shadow: 0 22px 52px rgba(129, 140, 248, 0.50);
    }
    body[data-theme="light"][data-colour="aurora"] .phone-frame {
      box-shadow: 0 18px 40px rgba(129, 140, 248, 0.32);
    }
.phone-frame::before,
    .phone-frame::after {
      content: "";
      position: absolute;
      left: -3px;
      background: #151f36;
      border-radius: 999px;
    }

    .phone-frame::before {
      top: 25%;
      width: 4px;
      height: 60px;
    }

    .phone-frame::after {
      top: 43%;
      width: 4px;
      height: 30px;
    }

    .phone-notch {
      position: absolute;
      top: 4px;
      left: 50%;
      transform: translateX(-50%);
      width: 120px;
      height: 14px;
      border-radius: 999px;
      background: #111827;
      box-shadow:
        0 0 0 1px rgba(15, 23, 42, 1),
        0 6px 12px rgba(0, 0, 0, 0.8);
      z-index: 2;
    }

    .phone-speaker {
      position: absolute;
      top: 6px;
      left: 50%;
      transform: translateX(-50%);
      width: 54px;
      height: 4px;
      border-radius: 999px;
      background: #020617;
      box-shadow: 0 0 0 1px rgba(31, 41, 55, 0.95);
    }

    .phone-camera {
      position: absolute;
      top: 4px;
      right: 27%;
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 30%, #1f2937, #020617 70%);
      box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.95);
    }

    .phone-inner {
      position: relative;
      z-index: 1;
      flex: 1;
      border-radius: 2rem;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      background: radial-gradient(circle at top, #020617, #020617 60%, #000);
      border: 1px solid rgba(15, 23, 42, 0.95);
    }

    /* Per-colourway phone inner gradients (dark theme) */
    body[data-colour="classic"] .phone-inner {
      background: radial-gradient(circle at 25% 0,
        #1e293b 0,
        #020617 55%,
        #000 100%);
    }

    body[data-colour="teal"] .phone-inner {
      background: radial-gradient(circle at 25% 0,
        #0f766e 0,
        #022c22 45%,
        #020617 85%);
    }

    body[data-colour="sunburst"] .phone-inner {
      background: radial-gradient(circle at 20% 0,
        #f97316 0,
        #7c2d12 35%,
        #020617 85%);
    }

    body[data-colour="sahara"] .phone-inner {
      background: radial-gradient(circle at 20% 0,
        #facc15 0,
        #854d0e 35%,
        #020617 85%);
    }

    body[data-colour="crown"] .phone-inner {
      background: radial-gradient(circle at 25% 0,
        #e11d48 0,
        #4c0519 38%,
        #020617 85%);
    }

    body[data-colour="aurora"] .phone-inner {
      background: radial-gradient(circle at 20% 0,
        #a855f7 0,
        #312e81 38%,
        #020617 85%);
    }

    /* Lunar theme: plum-toned phone background */
    body[data-theme="lunar"] .phone-inner {
      background: radial-gradient(circle at 22% 0,
        #4c1d95 0,
        #1f1435 40%,
        #020617 90%);
    }

    /* Subtle mesh-style texture inside the phone */
    .phone-inner::before {
      content: "";
      position: absolute;
      inset: 0;
      background-image:
        linear-gradient(120deg, rgba(148, 163, 184, 0.45) 1px, transparent 1px),
        linear-gradient(60deg, rgba(148, 163, 184, 0.45) 1px, transparent 1px);
      background-size: 26px 26px;
      mix-blend-mode: soft-light;
      opacity: 0.35; /* MAX PREVIEW – dial this down later if needed */
      pointer-events: none;
      z-index: 0;
    }
    /* Colourway-adaptive mesh tint inside the phone */
    body[data-colour="classic"] .phone-inner::before {
      background-image:
        linear-gradient(120deg, rgba(255, 74, 28, 0.45) 1px, transparent 1px),   /* ember vein */
        linear-gradient(60deg,  rgba(192, 132, 252, 0.40) 1px, transparent 1px); /* void-violet echo */
    }
    body[data-colour="crown"] .phone-inner::before {
      background-image:
        linear-gradient(120deg, rgba(29, 78, 216, 0.42) 1px, transparent 1px),
        linear-gradient(60deg, rgba(239, 68, 68, 0.32) 1px, transparent 1px);
    }
    /* Crown – Dark: SA flag mesh inside phone */
    body[data-theme="dark"][data-colour="crown"] .phone-inner::before {
      background-image:
        linear-gradient(120deg, rgba(222, 56, 49, 0.46) 1px, transparent 1px),  /* flag red */
        linear-gradient(60deg,  rgba(0, 122, 77, 0.42) 1px,  transparent 1px); /* flag green */
    }

    /* Crown – Lunar: OUT purple × green mesh inside phone */
    body[data-theme="lunar"][data-colour="crown"] .phone-inner::before {
      background-image:
        linear-gradient(120deg, rgba(115, 34, 130, 0.44) 1px, transparent 1px), /* OUT purple */
        linear-gradient(60deg,  rgba(141, 198, 63, 0.40) 1px,  transparent 1px); /* OUT green */
    }

    body[data-colour="sunburst"] .phone-inner::before {
      background-image:
        linear-gradient(120deg, rgba(249, 115, 22, 0.45) 1px, transparent 1px),
        linear-gradient(60deg, rgba(252, 211, 77, 0.35) 1px, transparent 1px);
    }
    body[data-colour="nighttide"] .phone-inner::before {
      background-image:
        linear-gradient(120deg, rgba(22, 163, 74, 0.42) 1px, transparent 1px),
        linear-gradient(60deg,  rgba(45, 212, 191, 0.34) 1px, transparent 1px);
    }

    /* Grove – phone mesh: leaf green × baobab bark */
    body[data-colour="teal"] .phone-inner::before {
      background-image:
        linear-gradient(120deg, rgba(34, 197, 94, 0.42) 1px, transparent 1px),   /* leaf green */
        linear-gradient(60deg,  rgba(180, 83, 9, 0.36) 1px,  transparent 1px);  /* baobab bark */
    }
    body[data-colour="sahara"] .phone-inner::before {
      background-image:
        linear-gradient(120deg, rgba(234, 88, 12, 0.45) 1px, transparent 1px),
        linear-gradient(60deg, rgba(250, 204, 21, 0.34) 1px, transparent 1px);
    }
    body[data-colour="aurora"] .phone-inner::before {
      background-image:
        linear-gradient(120deg, rgba(124, 58, 237, 0.42) 1px, transparent 1px),
        linear-gradient(60deg, rgba(56, 189, 248, 0.34) 1px, transparent 1px);
    }


    /* Theme-adaptive mesh opacity inside the phone */
    body[data-theme="dark"] .phone-inner::before {
      opacity: 0.40;
    }
    body[data-theme="lunar"] .phone-inner::before {
      opacity: 0.30;
    }
    body[data-theme="light"] .phone-inner::before {
      opacity: 0.18;
    }



    .phone-top-bar {
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 4px 10px 0 10px;
      font-size: 0.7rem;
      color: #e5e7eb;
      background: linear-gradient(to bottom, rgba(15, 23, 42, 0.98), rgba(15, 23, 42, 0.85));
    }

    .phone-status {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .phone-time {
      font-weight: 500;
      letter-spacing: 0.04em;
    }

    .phone-icons {
      display: flex;
      align-items: center;
      gap: 3px;
    }

    .status-pill {
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.9), rgba(15, 23, 42, 0.6));
      font-size: 0.65rem;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: #22c55e;
    }

    .signal-bars {
      display: inline-flex;
      align-items: flex-end;
      gap: 1px;
    }

    .signal-bars span {
      width: 2px;
      border-radius: 999px;
      background: #e5e7eb;
    }

    .signal-bars span:nth-child(1) { height: 5px; opacity: 0.6; }
    .signal-bars span:nth-child(2) { height: 7px; opacity: 0.7; }
    .signal-bars span:nth-child(3) { height: 9px; opacity: 0.8; }
    .signal-bars span:nth-child(4) { height: 11px; opacity: 1; }

    .battery {
      width: 16px;
      height: 8px;
      border-radius: 2px;
      border: 1px solid #e5e7eb;
      position: relative;
      margin-left: 3px;
    }

    .battery::after {
      content: "";
      position: absolute;
      right: -3px;
      top: 2px;
      width: 2px;
      height: 4px;
      border-radius: 1px;
      background: #e5e7eb;
    }

    .battery-level {
      position: absolute;
      inset: 1px;
      border-radius: 1px;
      background: linear-gradient(to right, #22c55e, #4ade80);
    }

    .chat-header {
      padding: 6px 10px 6px;
      display: flex;
      align-items: center;
      gap: 8px;
      background: linear-gradient(to bottom, rgba(15, 23, 42, 0.98), rgba(15, 23, 42, 0.9));
      border-bottom: 1px solid rgba(15, 23, 42, 0.95);
      color: #f9fafb;
    }

    .chat-header-left {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .back-btn {
      width: 22px;
      height: 22px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      font-size: 0; /* hide the literal "<" character */
      color: #e5e7eb;
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.95), rgba(15, 23, 42, 0.7));
    }

    .back-btn::before {
      content: "";
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.9);
      display: block;
    }

    .avatar {
      width: 26px;
      height: 26px;
      border-radius: 999px;
      background: radial-gradient(circle at top, #f97316, #ea580c);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.72rem;
      color: #0b1120;
      font-weight: 700;
      box-shadow: 0 0 0 2px rgba(15, 23, 42, 1);
    }

    .chat-header-text {
      display: flex;
      flex-direction: column;
      gap: 1px;
    }

    .chat-title {
      font-size: 0.8rem;
      font-weight: 600;
    }

    .chat-subtitle {
      font-size: 0.7rem;
      color: #9ca3af;
    }

    .chat-header-right {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.7rem;
      color: #9ca3af;
    }

    .chat-header-right span {
      display: inline-flex;
      align-items: center;
      gap: 3px;
    }

    .chat-header-dot {
      width: 4px;
      height: 4px;
      border-radius: 999px;
      background: #22c55e;
    }

    /* Make the chat-body itself a single scrollable area (Phone-like) */
    .chat-body {
      flex: 1;
      padding: 10px 10px 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 0.88rem;
      position: relative;
      background: var(--cw-classic-bg); /* default */
      transition: background 0.25s ease;
      overflow-y: auto; /* enable natural phone scrolling through the whole conversation */
      -webkit-overflow-scrolling: touch;
    }

    .chat-section-label {
      font-size: 0.68rem;
      letter-spacing: 0.12em;
      color: rgba(148, 163, 184, 0.95);
      margin-bottom: 2px;
    }

    .chat-section.customer,
    .chat-section.agent {
      flex: 0 0 auto;
      display: flex;
      flex-direction: column;
    }

    .chat-scroll {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding-right: 4px;
    }
    /* ChatFlow timeline (Phase B) */
    .chat-scroll.timeline{
      display:flex;
      flex-direction:column;
      gap:10px;
      padding: 12px 12px 16px;
      max-height: 100%;
      overflow-y: auto;
    }
    .chat-bubble.is-draggable{ cursor: grab; }
    .chat-bubble.is-dragging{ opacity:0.65; }
    .chat-bubble.is-drop-target{ box-shadow: 0 0 0 2px rgba(249,115,22,0.28); }


    /* Remove small separate scroller for customer so messages flow naturally */
    .chat-scroll.customer {
      max-height: none;
      overflow-y: visible;
    }

    .chat-scroll.agent {
      max-height: none;
      overflow-y: visible;
      align-items: flex-end;
    }

    /* PHONE CHAT BUBBLES – base size + spacing */
    .chat-bubble {
      border-radius: 1.1rem;
      padding: 7px 10px;
      font-size: 0.86rem;            /* middle ground vs WhatsApp + old UI */
      line-height: 1.6;
      letter-spacing: 0.01em;
      max-width: 80%;
      word-wrap: break-word;
      white-space: normal;
      border-width: 1mm;
      border-style: solid;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.35);
      overflow: visible; /* allow bubble to grow so outer chat-body handles scrolling */
      max-height: none;
    }

    /* Text-size presets (applied via body[data-textsize]) */
    body[data-textsize="xs"] .chat-bubble,
    body[data-textsize="xs"] .agent-textarea,
    body[data-textsize="xs"] .textarea-shell textarea,
    body[data-textsize="xs"] .locked-textarea {
      font-size: 0.78rem;
      line-height: 1.45;
    }

    body[data-textsize="sm"] .chat-bubble,
    body[data-textsize="sm"] .agent-textarea,
    body[data-textsize="sm"] .textarea-shell textarea,
    body[data-textsize="sm"] .locked-textarea {
      font-size: 0.84rem;
      line-height: 1.52;
    }

    body[data-textsize="md"] .chat-bubble,
    body[data-textsize="md"] .agent-textarea,
    body[data-textsize="md"] .textarea-shell textarea,
    body[data-textsize="md"] .locked-textarea {
      font-size: 0.90rem;
      line-height: 1.6;
    }

    body[data-textsize="lg"] .chat-bubble,
    body[data-textsize="lg"] .agent-textarea,
    body[data-textsize="lg"] .textarea-shell textarea,
    body[data-textsize="lg"] .locked-textarea {
      font-size: 0.98rem;
      line-height: 1.45;
    }

.chat-bubble.customer {
      align-self: flex-start;
      margin-right: auto;
      background: var(--cw-classic-customer);
      border-color: var(--cw-classic-customer-border);
      color: #f9fafb;
    }

    .chat-bubble.agent {
      align-self: flex-end;
      margin-left: auto;
      margin-right: 0;
      background: linear-gradient(135deg, #111827, #020617);
      border-color: rgba(51, 65, 85, 0.9);
      color: #f9fafb;
      font-size: inherit;            /* follow the text-size scale */
    }

    /* Agent bubble border tint per colourway (the "fire border" vibe) */
    body[data-colour="classic"] .chat-bubble.agent {
      border-color: #4b5563;
    }
    body[data-colour="teal"] .chat-bubble.agent {
      border-color: #14b8a6;
    }
    body[data-colour="sahara"] .chat-bubble.agent {
      border-color: #eab308;
    }
    body[data-colour="sunburst"] .chat-bubble.agent {
      border-color: #fb923c;
    }
    body[data-colour="crown"] .chat-bubble.agent {
      border-color: #e11d48;
    }

    /* === ChatFlow Typing Indicator (small UX cue) === */
.chat-bubble.typing{
  padding: 10px 14px;
  min-width: 58px;
  width: fit-content;
}
.chat-bubble.typing .typing-dots{
  display: inline-flex;
  gap: 6px;
  align-items: center;
  justify-content: center;
  height: 14px;
}
.chat-bubble.typing .typing-dots span{
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: rgba(226,232,240,0.85);
  transform: translateY(0);
  animation: mfTypingBounce 1.05s infinite ease-in-out;
}
.chat-bubble.typing .typing-dots span:nth-child(2){ animation-delay: 0.15s; opacity: 0.9; }
.chat-bubble.typing .typing-dots span:nth-child(3){ animation-delay: 0.30s; opacity: 0.75; }

@keyframes mfTypingBounce{
  0%, 60%, 100% { transform: translateY(0); }
  30% { transform: translateY(-5px); }
}

/* Light/Lunar: keep dots visible on lighter bubble text colours */
/* Light theme: customer typing bubble is lighter, so use darker dots for contrast.
   Agent bubbles remain dark even in light theme, so keep the default (light) dots there. */
body[data-theme="light"] .chat-bubble.customer.typing .typing-dots span,
body[data-theme="lunar"] .chat-bubble.customer.typing .typing-dots span{
  background: rgba(15,23,42,0.55);
}

/* Safety: ensure agent typing dots stay visible */
.chat-bubble.agent.typing .typing-dots span{
  background: rgba(255,255,255,0.92);
}

.chat-bubble p { margin: 0 0 10px 0; }
    .chat-bubble br { line-height: inherit; }
    .chat-bubble p:last-child { margin-bottom: 0; }

    
    .chat-input-bar {
      padding: 8px 18px 10px;
      background: #020617;
      border-top: 1px solid rgba(15, 23, 42, 0.95);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .chat-input-shell {
      flex: 1;
      max-width: 100%;
      border-radius: 999px;
      background: #111827;
      border: 1px solid rgba(55, 65, 81, 0.95);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 12px;
      gap: 10px;
      font-size: 0.78rem;
    }
    /* Shared micro-transitions for key UI elements */
    .panel,
    .pill-button,
    .fmt-btn,
    .spell-toggle-btn,
    .text-size-btn,
    .phone-frame,
    .chat-bubble,
    .chat-input-shell {
      transition:
        background 0.2s ease,
        border-color 0.2s ease,
        color 0.2s ease,
        box-shadow 0.2s ease,
        transform 0.1s ease;
    }

    .chat-input-placeholder {
      flex: 1;
      color: #9ca3af;
      opacity: 0.95;
      overflow: hidden;
    }

    .chat-input-icons {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      font-size: 0.9rem;
      color: #9ca3af;
    }

    .chat-input-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      opacity: 0.9;
    }

    .chat-input-icon:last-child {
      width: 24px;
      height: 24px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: rgba(15, 23, 42, 0.95);
    }
    .tip-text {
      position: relative;
      opacity: 1;
      transition: opacity 0.26s ease, transform 0.26s ease;
    }

    .tip-fade-in {
      opacity: 1;
      transform: translateY(0);
    }

    .tip-fade-out {
      opacity: 0;
      transform: translateY(4px);
    }

    .chat-input-send {
      width: 28px;
      height: 28px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--cw-classic-customer-border);
      background: radial-gradient(circle at 30% 0,
        #e5e7eb 0,
        var(--cw-classic-customer) 40%,
        var(--cw-classic-customer-border) 100%);
      box-shadow:
        0 0 0 1px rgba(15, 23, 42, 0.95),
        0 0 14px rgba(15, 23, 42, 0.9);
      font-size: 0; /* arrow is drawn via ::before */
      color: #020617;
      font-weight: 600;
      cursor: default;
    }

    .chat-input-send::before {
      content: "";
      border-left: 7px solid #020617;
      border-top: 4px solid transparent;
      border-bottom: 4px solid transparent;
    }

    /* Colourway tints for the send button (match customer bubble / text-size accent) */
    body[data-colour="teal"] .chat-input-send {
      border-color: var(--cw-teal-customer-border);
      background: radial-gradient(circle at 30% 0,
        #e5fffb 0,
        var(--cw-teal-customer) 40%,
        var(--cw-teal-customer-border) 100%);
    }

    body[data-colour="sahara"] .chat-input-send {
      border-color: var(--cw-sahara-customer-border);
      background: radial-gradient(circle at 30% 0,
        #fffbeb 0,
        var(--cw-sahara-customer) 40%,
        var(--cw-sahara-customer-border) 100%);
    }

    body[data-colour="sunburst"] .chat-input-send {
      border-color: var(--cw-sunburst-customer-border);
      background: radial-gradient(circle at 30% 0,
        #fff7ed 0,
        var(--cw-sunburst-customer) 40%,
        var(--cw-sunburst-customer-border) 100%);
    }

    body[data-colour="crown"] .chat-input-send {
      border-color: var(--cw-crown-customer-border);
      background: radial-gradient(circle at 30% 0,
        #fef2f2 0,
        var(--cw-crown-customer) 40%,
        var(--cw-crown-customer-border) 100%);
    }

    body[data-colour="aurora"] .chat-input-send {
      border-color: var(--cw-aurora-customer-border);
      background: radial-gradient(circle at 30% 0,
        #f5f3ff 0,
        var(--cw-aurora-customer) 40%,
        var(--cw-aurora-customer-border) 100%);
    }


    body[data-theme="light"] .chat-input-bar {
      background: #e5ecff;
      border-top-color: rgba(148, 163, 184, 0.5);
    }

    body[data-theme="light"] .chat-input-shell {
      background: #ffffff;
      border-color: rgba(148, 163, 184, 0.7);
      color: #111827;
    }

    body[data-theme="light"] .chat-input-placeholder {
      color: #6b7280;
    }

    body[data-theme="light"] .chat-input-icons {
      color: #6b7280;
    }


.home-bar {
      height: 18px;
      display: flex;
      justify-content: center;
      align-items: center;
      padding-top: 2px;
      background: linear-gradient(to top, rgba(0, 0, 0, 0.9), transparent);
    }

    .home-pill {
      width: 90px;
      height: 4px;
      border-radius: 999px;
      background: linear-gradient(to right, #4b5563, #9ca3af);
      opacity: 0.9;
    }

    /* LIGHT THEME OVERRIDES (unchanged except backgrounds) */
    body[data-theme="light"] .panel {
      background:
        radial-gradient(circle at top left, rgba(129, 140, 248, 0.16), transparent 55%),
        linear-gradient(145deg, #f9fafb, #eef2ff);
      border-color: #e5e7eb;
      box-shadow: 0 20px 50px rgba(148, 163, 184, 0.5);
    }

    body[data-theme="lunar"] .panel {
      background:
        radial-gradient(circle at top left, rgba(148, 163, 184, 0.24), transparent 55%),
        linear-gradient(145deg, #111827, #020617);
      border-color: #4b5563;
      box-shadow: 0 22px 55px rgba(15, 23, 42, 0.8);
    }

    body[data-theme="lunar"] .panel-title {
      color: #e5e7eb;
    }

    body[data-theme="lunar"] .agent-tag {
      border-color: #4b5563;
      background: rgba(31, 41, 55, 0.85);
      color: #e5e7eb;
    }

    body[data-theme="light"] .panel-title { color: #020617; }

    body[data-theme="light"] .agent-tag {
      border-color: rgba(37, 99, 235, 0.25);
      color: #1f2937;
      background: radial-gradient(circle at top left, rgba(59, 130, 246, 0.18), rgba(191, 219, 254, 0.95));
    }

    body[data-theme="light"] .agent-dot {
      box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.35);
    }

    body[data-theme="light"] .colourway-label {
      color: #4b5563;
    }

    body[data-theme="light"] .pill-toggle {
      background: rgba(248, 250, 252, 0.95);
      border-color: rgba(148, 163, 184, 0.35);
    }

    body[data-theme="light"] .pill-button { color: #4b5563; }
    body[data-theme="light"] .pill-button.active { color: #020617; }

    body[data-theme="light"] .theme-toggle {
      background: rgba(248, 250, 252, 0.95);
      border-color: rgba(148, 163, 184, 0.4);
    }

    body[data-theme="light"] .theme-toggle button { color: #4b5563; }
    body[data-theme="light"] .theme-toggle button.active {
      background: #020617;
      color: #f9fafb;
    }

    body[data-theme="light"] .textarea-shell textarea {
      background: #f9fafb;
      border-color: rgba(148, 163, 184, 0.4);
      color: #111827;
      box-shadow: 0 16px 40px rgba(148, 163, 184, 0.55);
    }

    body[data-theme="light"] .textarea-shell textarea::placeholder { color: #9ca3af; }

    body[data-theme="light"] .fmt-btn {
      background: #f9fafb;
      color: #6b7280;
      border-color: rgba(148, 163, 184, 0.4);
    }

    body[data-theme="light"] .fmt-btn.clean-btn { color: #111827; }

    body[data-theme="light"] .char-count-row span { color: #6b7280; }

    body[data-theme="light"] .char-count-row button {
      border-color: rgba(248, 113, 113, 0.8);
      color: #7f1d1d;
      background: radial-gradient(circle at top, #fecaca, #fee2e2);
    }

    body[data-theme="light"] .phone-inner {
      background: radial-gradient(circle at top, #e5ecff, #e5ecff 40%, #dbeafe 80%);
      border-color: rgba(191, 219, 254, 0.9);
    }

    body[data-theme="light"][data-colour="classic"] .phone-inner {
      background: radial-gradient(circle at 20% 0,
        #e5ecff 0,
        #dbeafe 45%,
        #bfdbfe 85%);
    }

    body[data-theme="light"][data-colour="teal"] .phone-inner {
      background: radial-gradient(circle at 20% 0,
        #ccfbf1 0,
        #a7f3d0 40%,
        #99f6e4 80%);
    }

    body[data-theme="light"][data-colour="sunburst"] .phone-inner {
      background: radial-gradient(circle at 18% 0,
        #ffedd5 0,
        #fed7aa 40%,
        #fed7aa 80%);
    }

    body[data-theme="light"][data-colour="sahara"] .phone-inner {
      background: radial-gradient(circle at 18% 0,
        #fef9c3 0,
        #fef3c7 40%,
        #fde68a 80%);
    }

    body[data-theme="light"][data-colour="crown"] .phone-inner {
      background: radial-gradient(circle at 20% 0,
        #ffe4e6 0,
        #fecaca 40%,
        #fecdd3 80%);
    }

    body[data-theme="light"][data-colour="aurora"] .phone-inner {
      background: radial-gradient(circle at 22% 0,
        #fdfcff 0,
        #f5f3ff 30%,
        #e9d5ff 60%,
        #c4b5fd 90%);
    }


    body[data-theme="light"] .phone-top-bar {
      background: linear-gradient(to bottom, #1e293b, #0f172a);
    }

    body[data-theme="light"] .chat-header {
      background: linear-gradient(to bottom, #0f172a, #020617);
      border-bottom-color: rgba(15, 23, 42, 1);
      color: #f9fafb;
    }

    body[data-theme="light"] .chat-title { color: #f9fafb; }
    body[data-theme="light"] .chat-subtitle { color: #e5e7eb; }

    body[data-theme="light"] .chat-header-right { color: #e5e7eb; }

    body[data-theme="light"] .chat-body { color: #020617; }
    body[data-theme="light"] .chat-section-label { color: #6b7280; }

    body[data-theme="light"] .back-btn {
      border-color: rgba(148, 163, 184, 0.7);
      background: radial-gradient(circle at top, #f9fafb, #e5e7eb);
      color: #111827;
    }

    body[data-theme="light"] .avatar { box-shadow: 0 0 0 2px #f9fafb; }

    body[data-theme="light"] .chat-bubble.agent { color: #f9fafb; }

    /* COLOURWAY-SPECIFIC CHAT BACKGROUNDS – DARK THEME */
    body[data-theme="dark"][data-colour="classic"] .chat-body {
      background: var(--cw-classic-bg);
    }
    body[data-theme="dark"][data-colour="classic"] .chat-bubble.customer {
      background: var(--cw-classic-customer);
      border-color: var(--cw-classic-customer-border);
    }

    body[data-theme="dark"][data-colour="teal"] .chat-body {
      background: var(--cw-teal-bg);
    }
    body[data-theme="dark"][data-colour="teal"] .chat-bubble.customer {
      background: var(--cw-teal-customer);
      border-color: var(--cw-teal-customer-border);
    }

    body[data-theme="dark"][data-colour="sahara"] .chat-body {
      background: var(--cw-sahara-bg);
    }
    body[data-theme="dark"][data-colour="sahara"] .chat-bubble.customer {
      background: var(--cw-sahara-customer);
      border-color: var(--cw-sahara-customer-border);
    }

    body[data-theme="dark"][data-colour="sunburst"] .chat-body {
      background: var(--cw-sunburst-bg);
    }
    body[data-theme="dark"][data-colour="sunburst"] .chat-bubble.customer {
      background: var(--cw-sunburst-customer);
      border-color: var(--cw-sunburst-customer-border);
    }

    body[data-theme="dark"][data-colour="crown"] .chat-body {
      background: var(--cw-crown-bg);
    }
    body[data-theme="dark"][data-colour="crown"] .chat-bubble.customer {
      background: var(--cw-crown-customer);
      border-color: var(--cw-crown-customer-border);
    }

    /* COLOURWAY-SPECIFIC – LIGHT THEME */
    body[data-theme="light"][data-colour="classic"] .chat-body {
      background: var(--cw-classic-light-bg);
    }
    body[data-theme="light"][data-colour="classic"] .chat-bubble.customer {
      background: var(--cw-classic-light-customer);
      border-color: var(--cw-classic-light-customer-border);
      color: #e5e7eb;
    }
    body[data-theme="light"][data-colour="classic"] .chat-bubble.agent {
      background: #1e293b;
      border-color: #2563eb;
    }

    body[data-theme="light"][data-colour="teal"] .chat-body {
      background: var(--cw-teal-light-bg);
    }
    body[data-theme="light"][data-colour="teal"] .chat-bubble.customer {
      background: var(--cw-teal-light-customer);
      border-color: var(--cw-teal-light-customer-border);
      color: #e5e7eb;
    }
    body[data-theme="light"][data-colour="teal"] .chat-bubble.agent {
      background: #0f172a;
      border-color: #0f766e;
    }

    body[data-theme="light"][data-colour="sahara"] .chat-body {
      background: var(--cw-sahara-light-bg);
    }
    body[data-theme="light"][data-colour="sahara"] .chat-bubble.customer {
      background: var(--cw-sahara-light-customer);
      border-color: var(--cw-sahara-light-customer-border);
      color: #fefce8;
    }
    body[data-theme="light"][data-colour="sahara"] .chat-bubble.agent {
      background: #1f2933;
      border-color: #a16207;
    }

    body[data-theme="light"][data-colour="sunburst"] .chat-body {
      background: var(--cw-sunburst-light-bg);
    }
    body[data-theme="light"][data-colour="sunburst"] .chat-bubble.customer {
      background: var(--cw-sunburst-light-customer);
      border-color: var(--cw-sunburst-light-customer-border);
      color: #111827; /* darker text for contrast */
    }
    body[data-theme="light"][data-colour="sunburst"] .chat-bubble.agent {
      background: #111827;
      border-color: #c2410c;
    }

    body[data-theme="light"][data-colour="crown"] .chat-body {
      background: var(--cw-crown-light-bg);
    }
    body[data-theme="light"][data-colour="crown"] .chat-bubble.customer {
      background: var(--cw-crown-light-customer);
      border-color: var(--cw-crown-light-customer-border);
      color: #fef2f2;
    }
    body[data-theme="light"][data-colour="crown"] .chat-bubble.agent {
      background: #0f172a;
      border-color: #1d4ed8;
    }

    /* COLOURWAY-SPECIFIC – LUNAR THEME (mid-tone chats) */
    body[data-theme="lunar"][data-colour="classic"] .chat-body {
      background: radial-gradient(circle at top, #020617 0, #1f2937 45%, #020617 100%);
    }
    body[data-theme="lunar"][data-colour="teal"] .chat-body {
      background: radial-gradient(circle at top, #02141a 0, #0f766e 42%, #020617 100%);
    }
    body[data-theme="lunar"][data-colour="sahara"] .chat-body {
      background: radial-gradient(circle at top, #111827 0, #78350f 44%, #020617 100%);
    }
    body[data-theme="lunar"][data-colour="sunburst"] .chat-body {
      background: radial-gradient(circle at top, #111827 0, #b45309 44%, #020617 100%);
    }
    body[data-theme="lunar"][data-colour="crown"] .chat-body {
      background: radial-gradient(circle at top, #020617 0, #1f2937 40%, #4c0519 95%);
    }
    body[data-theme="lunar"][data-colour="aurora"] .chat-body {
      background: radial-gradient(circle at top, #020617 0, #312e81 40%, #111827 95%);
    }

    body[data-theme="light"] .badge-pill {
      border-color: rgba(129, 140, 248, 0.9);
      background: radial-gradient(circle at top, #e0e7ff, #c7d2fe);
      color: #1e293b;
    }

    body[data-theme="light"] .home-bar {
      background: linear-gradient(to top, rgba(15, 23, 42, 0.9), transparent);
    }
    body[data-theme="light"] .home-pill {
      background: linear-gradient(to right, #9ca3af, #d1d5db);
    }


    .issue-tooltip {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
      font-size: 11px;
      line-height: 1.4;
      background: rgba(15, 23, 42, 0.98);
      color: #e5e7eb;
      border-radius: 6px;
      padding: 6px 8px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      z-index: 9999;
      max-width: 260px;
    }

    .issue-tooltip-note {
  margin-top: 4px;
  font-size: 11px;
  opacity: 0.9;
}
.issue-tooltip-main {
      margin-bottom: 4px;
    }

    .issue-tooltip-actions {
      display: flex;
      gap: 4px;
      justify-content: flex-end;
    }

    .issue-tooltip-actions button {
      border: none;
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 10px;
      cursor: pointer;
      background: #e5e7eb;
      color: #020617;
    }

    .issue-tooltip-actions button[data-action="apply"] {
      font-weight: 600;
    }

    .issue-tooltip-actions button[data-action="ignore"] {
      background: #0f172a;
      color: #e5e7eb;
      border: 1px solid rgba(148, 163, 184, 0.6);
    }

    
    #pasteBtn {
      position: relative;
    }

    #pasteBtn.hint-active::after {
      content: "Tip: Press Ctrl+V or right-click to paste";
      position: absolute;
      left: 50%;
      bottom: 125%;
      transform: translateX(-50%);
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 0.65rem;
      background: rgba(15, 23, 42, 0.98);
      color: #e5e7eb;
      white-space: nowrap;
      box-shadow: 0 8px 24px rgba(15, 23, 42, 0.7);
      pointer-events: none;
    }

@media (max-width: 960px) {
      .app { flex-direction: column; align-items: stretch; }
      .phone-frame { width: 100%; max-width: 380px; }
    }

    @media (max-width: 640px) {
      body { padding: 12px; }
      .panel { padding: 16px 14px; }
      .mlcx-panel { padding: 16px 14px; }
      /* Lock phone to a safe, fixed size on small widths so aspect/contents don't clip */
      .phone-frame {
        width: 360px;
        height: 760px;
        max-width: 100%;
        aspect-ratio: auto;
        margin: 8px auto;
      }
      /* Desktop-only override: never stack, even on small windows */
@media (max-width: 960px) {
       .app { flex-direction: row; align-items: stretch; }
      .phone-frame { width: 380px; max-width: 380px; }
   }

      .phone-frame .phone-inner { min-height: 0; }


      .toolbar { flex-direction: column; align-items: flex-start; }
      .toolbar-left { flex-wrap: nowrap; }
      .font-size-row { flex-direction: column; align-items: flex-start; }

      /* NEW – make pills a bit more compact on very small screens */
      .pill-button {
        padding: 3px 8px;
        font-size: 0.72rem;
      }

      /* Compact chooser visible on small screens */
      .colourway-toggle-group { display: none; }
      .compact-colour-chooser { display: inline-flex; gap:6px; align-items:center; }
      .compact-colour-chooser select {
        padding: 6px 8px;
        border-radius: 8px;
        border: 1px solid rgba(148,163,184,0.4);
        background: rgba(15,23,42,0.95);
        color: #e5e7eb;
      }
      body[data-theme="light"] .compact-colour-chooser select {
        background: #fff;
        color: #111827;
      }
      .compact-shuffle-btn {
        padding: 6px 8px;
        border-radius: 8px;
        border: 1px solid rgba(148,163,184,0.4);
        background: rgba(15,23,42,0.95);
        color: #e5e7eb;
      }

      /* Ensure text-size controls remain visible and attached under the phone on small screens */
      .phone-text-size-row {
        margin-top: 10px;
        position: relative;
        z-index: 3;
        display: flex;
        justify-content: center;
      }
    }

    .char-actions {
      margin-top: 0;
      display: flex;
      gap: 6px;
    }

    .char-actions button {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      padding: 4px 12px;
      font-size: 0.74rem;
      background: rgba(15, 23, 42, 0.9);
      color: #e5e7eb;
      cursor: pointer;
      box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.6), 0 10px 20px rgba(15, 23, 42, 0.6);
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease, transform 0.1s ease;
    }

    .char-actions button:hover {
      border-color: #f97316;
      background: radial-gradient(circle at top, rgba(249, 115, 22, 0.9), rgba(15, 23, 42, 0.95));
      color: #fff;
      transform: translateY(-0.5px);
    }

  
.context-menu {
  position: fixed;
  z-index: 9999;
  min-width: 160px;
  padding: 6px 0;
  background: #020617;
  color: #e5e7eb;
  border-radius: 10px;
  box-shadow: 0 18px 40px rgba(15,23,42,0.9);
  border: 1px solid rgba(148, 163, 184, 0.6);
  font-size: 13px;
}
.context-menu[hidden]{display:none;}
.context-menu button{display:block;width:100%;padding:6px 12px;text-align:left;border:none;background:transparent;color:inherit;cursor:pointer;}
.context-menu button:hover{background:rgba(148,163,184,0.16);}
.context-divider{margin:4px 0;border-top:1px solid rgba(148,163,184,0.4);}

/* ISSUE TARGET (flash / highlight when cycling through issues) */
.issue-target {
  box-shadow: 0 0 0 3px rgba(249,115,22,0.18);
  position: relative;
  animation: issueflash 900ms ease-in-out 1;
  border-radius: 2px;
}
@keyframes issueflash {
  0% { background: rgba(249,115,22,0.06); }
  40% { background: rgba(249,115,22,0.14); }
  100% { background: transparent; }
}

/* small adjustment so issue-target in bubbles also is apparent */
.chat-bubble .issue-target { background: rgba(255,255,255,0.03); }

  .app-viewport {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: auto;
  }
  .app-viewport > .app {
    pointer-events: auto;
  }


/* Short viewport: gently scale the phone so it fits */
  

  
  /* Uniform toolbar pill buttons (counters + actions) */
  .issue-counters .issue-counter,
  #spellToggleBtn,
  #pasteBtn,
  #copyBtn,
  #clearBtn,
  .toolbar-pill {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.28rem 0.85rem;
    min-height: 32px;
    border-radius: 999px;
    font-size: 0.72rem;
    letter-spacing: 0.04em;
    text-transform: uppercase;
    white-space: nowrap;
    cursor: pointer;
    user-select: none;
    border-width: 1px;
    border-style: solid;
    border-color: rgba(148, 163, 184, 0.45);

    /* tactile base */
    background: rgba(255, 255, 255, 0.06);
    color: var(--text-muted);
    box-shadow:
      inset 0 1px 0 rgba(255, 255, 255, 0.08),
      0 10px 22px rgba(0, 0, 0, 0.25);
    transition:
      transform 0.16s ease,
      box-shadow 0.16s ease,
      border-color 0.16s ease,
      background 0.16s ease,
      color 0.16s ease;
  }

  body[data-theme="light"] .issue-counters .issue-counter,
  body[data-theme="light"] #spellToggleBtn,
  body[data-theme="light"] #pasteBtn,
  body[data-theme="light"] #copyBtn,
  body[data-theme="light"] #clearBtn,
  body[data-theme="light"] .toolbar-pill {
    background: rgba(15, 23, 42, 0.06);
    color: rgba(15, 23, 42, 0.75);
    box-shadow:
      inset 0 1px 0 rgba(255, 255, 255, 0.65),
      0 10px 22px rgba(15, 23, 42, 0.10);
  }

  .issue-counters .issue-counter:hover,
  #spellToggleBtn:hover,
  #pasteBtn:hover,
  #copyBtn:hover,
  #clearBtn:hover,
  .toolbar-pill:hover {
    transform: translateY(-1px);
    border-color: rgba(96, 165, 250, 0.65);
    background: rgba(255, 255, 255, 0.10);
    color: #e5e7eb;
    box-shadow:
      inset 0 1px 0 rgba(255, 255, 255, 0.10),
      0 14px 28px rgba(0, 0, 0, 0.32);
  }

  body[data-theme="light"] .issue-counters .issue-counter:hover,
  body[data-theme="light"] #spellToggleBtn:hover,
  body[data-theme="light"] #pasteBtn:hover,
  body[data-theme="light"] #copyBtn:hover,
  body[data-theme="light"] #clearBtn:hover,
  body[data-theme="light"] .toolbar-pill:hover {
    background: rgba(15, 23, 42, 0.09);
    color: rgba(15, 23, 42, 0.90);
    box-shadow:
      inset 0 1px 0 rgba(255, 255, 255, 0.70),
      0 14px 28px rgba(15, 23, 42, 0.14);
  }

  /* CX drawer: keep CUSTOMER/AGENT toggle readable even in day mode.
     The CX drawer is intentionally dark (lunar-like) across themes, so
     we override the generic light-theme toolbar-pill colours inside it. */
  body[data-theme="light"] #cxDrawerOverlay .cx-drawer-header .toolbar-pill,
  body[data-theme="light"] #cxDrawerCallnotesOverlay .cx-drawer-header .toolbar-pill,
  body[data-theme="light"] #cvDrawerOverlay .cx-drawer-header .toolbar-pill {
    background: rgba(255, 255, 255, 0.06) !important;
    color: rgba(226, 232, 240, 0.95) !important;
    border-color: rgba(148, 163, 184, 0.45) !important;
    box-shadow:
      inset 0 1px 0 rgba(255, 255, 255, 0.08),
      0 10px 22px rgba(0, 0, 0, 0.25) !important;
  }

  body[data-theme="light"] #cxDrawerOverlay .cx-drawer-header .toolbar-pill:hover,
  body[data-theme="light"] #cxDrawerCallnotesOverlay .cx-drawer-header .toolbar-pill:hover,
  body[data-theme="light"] #cvDrawerOverlay .cx-drawer-header .toolbar-pill:hover {
    background: rgba(255, 255, 255, 0.10) !important;
    color: rgba(241, 245, 249, 0.98) !important;
    border-color: rgba(96, 165, 250, 0.65) !important;
  }



  .issue-counters .issue-counter:active,
  #spellToggleBtn:active,
  #pasteBtn:active,
  #copyBtn:active,
  #clearBtn:active,
  .toolbar-pill:active {
    transform: translateY(0px) scale(0.98);
    box-shadow:
      inset 0 1px 0 rgba(255, 255, 255, 0.06),
      0 8px 18px rgba(0, 0, 0, 0.22);
  }


  .char-actions .toolbar-pill + .toolbar-pill {
    margin-left: 0.4rem;
  }

  /* Let existing background colours for counters show through,
     but keep text readable in both themes */
  body[data-theme="dark"] .issue-counters .issue-counter {
    color: #e5e7eb;
  }

  /* Soft tooltip bubble for checker explanations */
  .soft-tooltip {
    position: fixed;
    z-index: 9999;
    max-width: 260px;
    padding: 6px 10px;
    border-radius: 999px;
    font-size: 11px;
    line-height: 1.3;
    background: rgba(15, 23, 42, 0.96);
    color: #e5e7eb;
    box-shadow: 0 12px 30px rgba(15, 23, 42, 0.45);
    opacity: 0;
    pointer-events: none;
    transform: translateY(4px);
    transition: opacity 0.16s ease-out, transform 0.16s ease-out;
  }

  body[data-theme="light"] .soft-tooltip {
    background: rgba(15, 23, 42, 0.96);
    color: #f9fafb;
  }

  .soft-tooltip.visible {
    opacity: 1;
    transform: translateY(0);
  }

  /* Toast notification system */
  .toast-container {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 10000;
    display: flex;
    flex-direction: column;
    gap: 10px;
    pointer-events: none;
  }
  .toast {
    min-width: 240px;
    padding: 12px 18px;
    border-radius: 12px;
    background: rgba(15, 23, 42, 0.96);
    color: #f7f9ff;
    font-size: 0.875rem;
    font-weight: 500;
    box-shadow: 0 12px 30px rgba(15, 23, 42, 0.6);
    opacity: 0;
    transform: translateX(20px);
    transition: opacity 0.25s ease, transform 0.25s ease;
    pointer-events: auto;
  }
  .toast.visible {
    opacity: 1;
    transform: translateX(0);
  }
  .toast.success {
    background: radial-gradient(circle at top, #10b981, #059669);
    color: #fff;
  }
  .toast.info {
    background: radial-gradient(circle at top, #3b82f6, #2563eb);
    color: #fff;
  }
  body[data-theme="light"] .toast {
    background: rgba(248, 250, 252, 0.98);
    color: #0f172a;
    box-shadow: 0 12px 30px rgba(148, 163, 184, 0.5);
  }
  body[data-theme="light"] .toast.success {
    background: radial-gradient(circle at top, #10b981, #059669);
    color: #fff;
  }
  body[data-theme="light"] .toast.info {
    background: radial-gradient(circle at top, #3b82f6, #2563eb);
    color: #fff;
  }


  /* MK1 Floating Quick Replies panel */
  .toolbar {
    position: relative; /* anchor for dropdown panels */
  }

  #repliesPanel,
  #phrasesPanel {
    position: absolute;
    top: 36px;
    width: 420px;
    max-height: 340px;
    padding: 10px 0;
    background: rgba(15, 23, 42, 0.96);
    backdrop-filter: blur(14px);
    border-radius: 18px;
    border: 1px solid rgba(148,163,184,0.35);
    box-shadow: 0 18px 45px rgba(15, 23, 42, 0.75);
    opacity: 0;
    pointer-events: none;
    transform: translateY(-6px);
    transition: opacity 0.18s ease, transform 0.18s ease;
    z-index: 40;
    overflow-y: auto;
  }

  #repliesPanel.visible,
  #phrasesPanel.visible {
    opacity: 1;
    pointer-events: auto;
    transform: translateY(0);
  }

  .qr-label {
    padding: 6px 18px;
    font-size: 11px;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: rgba(148,163,184,0.95);
  }

  .qr-item {
    padding: 8px 18px;
    font-size: 13px;
    line-height: 1.5;
    color: rgba(248,250,252,0.98);
    cursor: pointer;
    transition: background 0.16s ease, padding-left 0.16s ease, border-left 0.16s ease;
  }

  .qr-item:hover {
    background: rgba(251,191,36,0.1);
    border-left: 3px solid rgba(251,191,36,0.85);
    padding-left: 22px;
  }

  .qr-divider {
    height: 1px;
    margin: 6px 0;
    background: radial-gradient(circle at left, rgba(251,191,36,0.55), transparent 60%);
    opacity: 0.6;
  }

  @media (max-width: 1100px) {
    #repliesPanel,
    #phrasesPanel {
      left: 0;
      right: auto;
      width: min(420px, 100%);
    }
  }

/* Ghost placeholders (split view only – never in full Notepad mode) */
body[data-layout="split"] #customerInput:empty::before {
  content: "Hi, I need help with my claim.";
  color: rgba(0, 0, 0, 0.38);
}
body[data-layout="split"] #agentInput:empty::before {
  content: "Hi, thanks for reaching out, how can I help?";
  color: rgba(148, 163, 184, 0.65);
}
body[data-theme="dark"][data-layout="split"] #agentInput:empty::before,
body[data-theme="lunar"][data-layout="split"] #agentInput:empty::before {
  color: rgba(203, 213, 225, 0.75);
}
body[data-theme="light"][data-layout="split"] #agentInput:empty::before {
  color: rgba(100, 116, 139, 0.6);
}


.colourway-label {
    width: 140px !important;
    min-width: 140px !important;
    max-width: 140px !important;
    text-align: left;
    overflow: hidden;
}

.font-size-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
}
.bubble-add-group {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.bubble-add-btn {
  position: relative;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 26px;
  border-radius: 999px;
  border: none;
  cursor: pointer;
  padding: 0;
  background: rgba(0, 0, 0, 0.08);
  box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  transition: transform 0.18s ease-out, box-shadow 0.18s ease-out, background 0.18s ease-out;
}

body[data-theme="dark"] .bubble-add-btn {
  background: rgba(255, 255, 255, 0.05);
}

body[data-theme="lunar"] .bubble-add-btn {
  background: rgba(255, 255, 255, 0.08);
}

.bubble-add-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 10px rgba(0,0,0,0.25);
}

.bubble-add-btn:active {
  transform: translateY(0);
  box-shadow: 0 1px 3px rgba(0,0,0,0.18);
}

.bubble-add-dot {
  width: 14px;
  height: 14px;
  border-radius: 999px;
  background: rgba(255, 255, 255, 0.3);
  box-shadow: inset 0 0 0 1px rgba(0,0,0,0.15);
}

.bubble-add-plus {
  position: absolute;
  right: 8px;
  font-size: 14px;
  font-weight: 600;
  line-height: 1;
  color: rgba(0,0,0,0.7);
}

body[data-theme="dark"] .bubble-add-plus,
body[data-theme="lunar"] .bubble-add-plus {
  color: rgba(255,255,255,0.9);
}


    .mlcx-rails {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
      gap: 4px 10px;
      margin-top: 6px;
      font-size: 0.7rem;
      color: var(--text-muted);
    }
    .mlcx-rails.mlcx-hidden {
      display: none;
    }
    .mlcx-rail {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0;
    }
    .mlcx-sentence {
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.75));
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
    }
    .mlcx-sentence-question::after {
      content: "?";
      font-size: 0.65rem;
      margin-left: 4px;
      opacity: 0.8;
      vertical-align: middle;
    }


    .mlcx-coach-panel {
      margin-top: 4px;
      padding: 6px 10px;
      border-radius: 10px;
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.9));
      border: 1px solid rgba(148, 163, 184, 0.4);
      font-size: 0.72rem;
      color: var(--text-muted);
    }
    .mlcx-coach-hidden {
      display: none;
    }
    .mlcx-coach-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 4px;
      font-weight: 500;
      letter-spacing: 0.02em;
    }
    .mlcx-coach-title {
      text-transform: uppercase;
      font-size: 0.7rem;
      opacity: 0.9;
    }
    .mlcx-coach-close {
      border: none;
      background: transparent;
      color: var(--text-muted);
      font-size: 0.8rem;
      cursor: pointer;
      padding: 0 2px;
      line-height: 1;
    }
    .mlcx-coach-body {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .mlcx-coach-sentence {
      font-size: 0.7rem;
      color: var(--text-secondary);
    }
    .mlcx-coach-message {
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    /* Ensure MLCX panel never bleeds into other layouts */
    body[data-layout="split"] .mlcx-panel,
    body[data-layout="notepad"] .mlcx-panel {
      display: none;
      flex: 1 1 auto;
      height: 100%;
      min-height: 100%;
      padding: 20px 24px;
      overflow: hidden;
      flex-direction: column;
    }

    /* We'll be using small corner mode icons instead of the old pill toggle */
    .view-toggle-btn {
      display: none;
    }

    .layout-corner-switch {
      position: absolute;
      top: 10px;
      right: 14px;
      z-index: 15;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    /* Hide MLCX layout button (code remains intact for future re-enabling) */
    .layout-mode-btn-mlcx {
      display: none !important;
    }
    .layout-mode-btn {
      width: 24px;
      height: 24px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background:
        radial-gradient(circle at top, rgba(248, 250, 252, 0.96), rgba(226, 232, 240, 0.98));
      box-shadow: 0 10px 26px rgba(15, 23, 42, 0.85);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.76rem;
      line-height: 1;
      cursor: pointer;
      color: #111827;
      padding: 0;
    }
    body[data-theme="dark"] .layout-mode-btn,
    body[data-theme="lunar"] .layout-mode-btn {
      background:
        radial-gradient(circle at top, rgba(30, 64, 175, 0.96), rgba(15, 23, 42, 0.98));
      color: #e5e7eb;
      box-shadow: 0 12px 28px rgba(15, 23, 42, 0.95);
      border-color: rgba(148, 163, 184, 0.8);
    }
    .layout-mode-btn[disabled] {
      opacity: 0.28;
      cursor: default;
      box-shadow: none;
    }
    .layout-mode-btn-icon {
      display: block;
      transform: translateY(0.5px);
    }

body[data-cx-mode="on"] .mlcx-pills-row {
  display: none !important;
}



    /* Improve text visibility for MLCX Notepad on light/lunar themes */
    body[data-theme="lunar"] .mlcx-panel,
    body[data-theme="light"] .mlcx-panel {
      --text-main: #111827;
      --text-muted: #4b5563;
      color: var(--text-main);
    }

    body[data-theme="lunar"] .mlcx-og-left,
    body[data-theme="lunar"] .mlcx-og-right,
    body[data-theme="light"] .mlcx-og-left,
    body[data-theme="light"] .mlcx-og-right {
      background: rgba(255, 255, 255, 0.9);
    }

    body[data-theme="lunar"] .mlcx-og-textarea,
    body[data-theme="light"] .mlcx-og-textarea {
      background: rgba(255, 255, 255, 0.98);
      color: #111827;
    }

    body[data-theme="lunar"] .mlcx-og-textarea::placeholder,
    body[data-theme="light"] .mlcx-og-textarea::placeholder {
      color: rgba(75, 85, 99, 0.9);
    }

    body[data-theme="lunar"] .mlcx-og-card,
    body[data-theme="light"] .mlcx-og-card {
      background: rgba(255, 255, 255, 0.98);
      color: #111827;
    }

    body[data-theme="lunar"] .mlcx-og-chips,
    body[data-theme="light"] .mlcx-og-chips {
      color: var(--text-muted);
    }

    /* CX notch visible in this build – override any older notepad-only rule */
    /* (If you ever want a notepad-only build, scope this hide rule with a body[data-layout="mlcx-notepad"] prefix.) */


    /* Header row for CALL NOTES + actions */
    .mlcx-og-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 8px;
    }

    .mlcx-og-header-actions {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .mlcx-dice-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 26px;
      height: 26px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background:
        radial-gradient(circle at top, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.86));
      box-shadow: 0 6px 16px rgba(15, 23, 42, 0.9);
      font-size: 0.9rem;
      cursor: pointer;
      transition: transform 120ms ease-out, box-shadow 140ms ease-out, background 140ms ease-out;
    }

    body[data-theme="lunar"] .mlcx-dice-btn,
    body[data-theme="light"] .mlcx-dice-btn {
      background:
        radial-gradient(circle at top, rgba(255, 255, 255, 0.96), rgba(226, 232, 240, 0.96));
      box-shadow: 0 6px 16px rgba(148, 163, 184, 0.55);
      color: #0f172a;
    }

    .mlcx-dice-btn.is-spinning {
      transform: rotate(90deg) scale(1.05);
    }

    /* Compact CV pill button (inactive: "CV"; active: "CV ⚡") */
    .cv-pill-btn {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      font-size: 0.74rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      background:
        radial-gradient(circle at top, rgba(15, 23, 42, 0.98), rgba(15, 23, 42, 0.9));
      color: #e5f3ff;
      cursor: pointer;
      transition: background 140ms ease-out, box-shadow 140ms ease-out, transform 120ms ease-out;
      box-shadow: 0 6px 18px rgba(15, 23, 42, 0.9);
    }

    .cv-pill-label {
      font-weight: 600;
    }

    .cv-pill-icon {
      opacity: 0;
      transform: scale(0.6);
      transition: opacity 140ms ease-out, transform 140ms ease-out;
    }

    .cv-pill-btn[aria-expanded="true"] .cv-pill-icon {
      opacity: 1;
      transform: scale(1);
    }

    body[data-theme="lunar"] .cv-pill-btn,
    body[data-theme="light"] .cv-pill-btn {
      background:
        radial-gradient(circle at top, rgba(255, 255, 255, 0.98), rgba(226, 232, 240, 0.96));
      color: #0f172a;
      box-shadow: 0 6px 14px rgba(148, 163, 184, 0.7);
    }

    body[data-theme="lunar"] .cv-pill-btn[aria-expanded="true"],
    body[data-theme="light"] .cv-pill-btn[aria-expanded="true"] {
      background:
        radial-gradient(circle at top, rgba(251, 191, 36, 0.22), rgba(255, 255, 255, 0.98));
      box-shadow: 0 8px 20px rgba(251, 191, 36, 0.45);
    }
/* FULLSCREEN MLCX DASHBOARD LAYOUT */
body[data-layout="mlcx"] .app-main {
      height: 100%;
      min-height: 100%;
      display: flex;
      flex-direction: column;
    }

body[data-layout="mlcx"] .app-card {
  height: calc(100vh - 60px);
      display: flex;
      flex-direction: column;
    }

body[data-layout="mlcx"] .mlcx-panel {
      display: flex;
    }

.mlcx-layout {
      flex: 1 1 auto;
      height: 100%;
      min-height: 100%;
      display: grid;
      grid-template-columns: 2fr 1.2fr;
  gap: 20px;
    }

.mlcx-notes-column {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

.mlcx-notes-textarea {
      flex: 1 1 auto;
      min-height: 60vh;
      height: 100%;
      resize: vertical;
    }

.mlcx-train-column {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }

.mlcx-training-panel {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow: auto;
    }


    /* Gold UX polish: unified focus states for interactive controls */
    button:focus-visible,
    .layout-mode-btn:focus-visible,
    .dev-demo-btn:focus-visible,
    .dev-view-toggle-btn:focus-visible,
    .dev-editor-nav-btn:focus-visible,
    .dev-editor-bulk-btn:focus-visible,
    .text-size-btn:focus-visible,
    .cx-drawer-close-btn:focus-visible,
    .cv-pill-btn:focus-visible,
    .view-toggle-btn:focus-visible,
    .devlab-toggle-btn:focus-visible {
      outline: 2px solid var(--focus-ring);
      outline-offset: 2px;
      box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.9), 0 0 0 3px rgba(56, 189, 248, 0.45);
    }

    /* Gold UX polish: subtle motion for pills and chips */
    .callnotes-chip,
    .cv-chip,
    .mlcv-chip,
    .badge-pill {
      transition:
        background 0.16s ease,
        color 0.16s ease,
        box-shadow 0.16s ease,
        transform 0.12s ease,
        border-color 0.16s ease;
    }
    .callnotes-chip:hover,
    .cv-chip:hover,
    .mlcv-chip:hover,
    .badge-pill:hover {
      transform: translateY(-1px);
      box-shadow: 0 2px 6px rgba(15, 23, 42, 0.35);
      border-color: rgba(148, 163, 184, 0.85);
    }

    /* Gold UX polish: emphasise insight card headings slightly */
    .callnotes-card-header,
    .dev-card-header {
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    /* Gold UX polish: ensure smooth animations for core buttons */
    .layout-mode-btn,
    .dev-demo-btn,
    .dev-view-toggle-btn,
    .dev-editor-nav-btn,
    .dev-editor-bulk-btn,
    .text-size-btn,
    .cx-drawer-close-btn,
    .cv-pill-btn,
    .view-toggle-btn,
    .devlab-toggle-btn {
      transition:
        background 0.16s ease,
        color 0.16s ease,
        box-shadow 0.16s ease,
        transform 0.12s ease,
        border-color 0.16s ease;
    }
    .layout-mode-btn:hover,
    .dev-demo-btn:hover,
    .dev-view-toggle-btn:hover,
    .dev-editor-nav-btn:hover,
    .dev-editor-bulk-btn:hover,
    .text-size-btn:hover,
    .cx-drawer-close-btn:hover,
    .cv-pill-btn:hover,
    .view-toggle-btn:hover,
    .devlab-toggle-btn:hover {
      transform: translateY(-1px);
    }
    .layout-mode-btn:active,
    .dev-demo-btn:active,
    .dev-view-toggle-btn:active,
    .dev-editor-nav-btn:active,
    .dev-editor-bulk-btn:active,
    .text-size-btn:active,
    .cx-drawer-close-btn:active,
    .cv-pill-btn:active,
    .view-toggle-btn:active,
    .devlab-toggle-btn:active {
      transform: translateY(0);
      box-shadow: none;
    }

    /* Gold3 layout clean-up: centre phone preview elegantly in split layout */
    body[data-layout="split"] .preview-panel {
      justify-content: center;
      gap: 16px;
    }
    body[data-layout="split"] .preview-panel .preview-badges {
      margin-top: 0;
    }
    body[data-layout="split"] .phone-text-size-row {
      margin-bottom: 6px;
    }

    /* Gold3 toolbar alignment: remove negative offset in full Notepad layout */
    body[data-layout="notepad"] .toolbar-left {
      margin-top: 0 !important;
    }

    /* === Refinement: hide floating notch buttons while their drawers are open (prevents overlay on content) === */
    body.cx-drawer-open #cxNotchToggle,
    body.cx-callnotes-drawer-open #cxNotchCallnotesToggle,
    body.writer-drawer-open #msWriterNotch {
      opacity: 0;
      pointer-events: none;
      transform: translateY(-50%) translateX(10px) scale(0.98);
      filter: blur(0.2px);
    }

    /* When closed, ensure notches are crisp and tactile */
    #cxNotchToggle,
    #cxNotchCallnotesToggle,
    #msWriterNotch {
      transition: opacity 0.18s ease, transform 0.18s ease, box-shadow 0.18s ease, border-color 0.18s ease;
    }

    /* Hide the Sync CX button for now (keeps logic wired, removes visual noise) */
    #mlcxToggleBtn {
      display: none !important;
    }


    /* --- View toggles (Phone + Focus) --- */
    .view-toggle {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      margin-left: 6px;
    }

    .icon-pill {
      width: 32px;
      height: 28px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.35);
      background: radial-gradient(circle at top, rgba(15,23,42,0.70), rgba(15,23,42,0.92));
      box-shadow:
        0 10px 22px rgba(0,0,0,0.28),
        0 0 0 1px rgba(15,23,42,0.65) inset;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: rgba(226,232,240,0.92);
      transition: transform .14s ease, box-shadow .22s ease, border-color .22s ease, background .22s ease, opacity .22s ease;
      user-select: none;
    }
    .icon-pill svg { width: 16px; height: 16px; opacity: 0.92; }
    .icon-pill:hover{
      transform: translateY(-1px);
      border-color: rgba(147,197,253,0.55);
      box-shadow:
        0 14px 28px rgba(0,0,0,0.32),
        0 0 0 1px rgba(147,197,253,0.12) inset,
        0 0 0 1px rgba(15,23,42,0.55) inset;
    }
    .icon-pill:active{ transform: translateY(0px) scale(0.98); }
    .icon-pill[aria-pressed="true"]{
      border-color: rgba(56,189,248,0.7);
      box-shadow:
        0 16px 32px rgba(0,0,0,0.38),
        0 0 0 1px rgba(56,189,248,0.18) inset;
      background: radial-gradient(circle at top, rgba(56,189,248,0.22), rgba(15,23,42,0.96));
    }

    /* Coaching master toggle lives in the bottom-most row next to Phone focus.
       It needs more width to carry text without stretching other rows. */
    .icon-pill--coaching{
      width: auto;
      min-width: 74px;
      padding: 0 12px;
      font-size: 11px;
      letter-spacing: 0.2px;
    }
/* --- Phone spotlight: center the phone, dim the rest --- */
    #phoneSpotlightOverlay{
      position: fixed;
      inset: 0;
      /* transparent click-catcher only - the blur/dim comes from the phone focus state */
      background: transparent;
      backdrop-filter: none;
      -webkit-backdrop-filter: none;
      opacity: 0;
      pointer-events: none;
      transition: opacity .25s ease;
      z-index: 1500;
    }
    
    
#phoneSpotlightOverlay .phone-spotlight-close{
  position: fixed;
  top: calc(var(--mf-app-top, 12px) + 14px);
  left: calc(var(--mf-app-right, calc(100vw - 14px)) - 58px);
  width: 44px;
  height: 44px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.18);
  background: rgba(8,12,20,.62);
  box-shadow: 0 14px 42px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.14);
  color: rgba(255,255,255,.92);
  display: grid;
  place-items: center;
  cursor: pointer;
  pointer-events: auto;
  transition: transform .16s ease, filter .16s ease, background .2s ease, border-color .2s ease;
  z-index: 20002;
}

  /* Adaptive phone scaling + entry zoom (Phone Focus Mode) */
  body[data-phone="on"] .phone-frame{
    transform: scale(var(--mf-phone-spotlight-scale, 1.10));
    transform-origin: center center;
    transition: transform 260ms cubic-bezier(.2,.9,.2,1);
    will-change: transform;
  }
  body.phone-spotlight-enter[data-phone="on"] .phone-frame{
    animation: mfPhoneSpotlightIn 300ms cubic-bezier(.2,.9,.2,1) both;
  }
  @keyframes mfPhoneSpotlightIn{
    from{ transform: scale(calc(var(--mf-phone-spotlight-scale, 1.10) * 0.96)); }
    to{ transform: scale(var(--mf-phone-spotlight-scale, 1.10)); }
  }

body[data-phone="on"] #phoneSpotlightOverlay .phone-spotlight-close{
  position: fixed;
  top: calc(var(--mf-app-top, 12px) + 14px);
  left: calc(var(--mf-app-right, calc(100vw - 14px)) - 58px);
  width: 44px;
  height: 44px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.18);
  background: rgba(8,12,20,.62);
  box-shadow: 0 14px 42px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.14);
  color: rgba(255,255,255,.92);
  display: grid;
  place-items: center;
  cursor: pointer;
  pointer-events: auto;
  transition: transform .16s ease, filter .16s ease, background .2s ease, border-color .2s ease;
  z-index: 20002;
}
#phoneSpotlightOverlay .phone-spotlight-close:hover{
  border-color: rgba(56,189,248,0.85);
  background: rgba(2,6,23,0.82);
  box-shadow: 0 18px 46px rgba(0,0,0,0.62), 0 0 0 1px rgba(56,189,248,0.22) inset;
}

/* When phone spotlight is active, hide helpers that compete with the preview */
body.phone-spotlight-on .preview-badges,
body.phone-spotlight-on .text-size-row,
body.phone-spotlight-on .phone-text-size-row{
  display: none !important;
}

/* Robustness: spotlight state is driven by data-phone="on" */
body[data-phone="on"] .preview-badges,
body[data-phone="on"] .text-size-row,
body[data-phone="on"] .phone-text-size-row{
  display: none !important;
}
#phoneSpotlightOverlay .phone-spotlight-close:active{
  transform: translateY(1px);
}

/* Hide drawers + notches while phone spotlight is active */
    body[data-phone="on"] #cxDrawerOverlay,
    body[data-phone="on"] #msWriterOverlay{
      opacity: 0 !important;
      pointer-events: none !important;
    }
    body[data-phone="on"] #cxNotchToggle,
    body[data-phone="on"] #msWriterNotch{
      opacity: 0 !important;
      pointer-events: none !important;
      transform: translateY(-50%) translateX(10px) scale(0.98) !important;
    }
body[data-phone="on"] #phoneSpotlightOverlay{
      opacity: 1;
      pointer-events: none;
    }
    body[data-phone="on"] .preview-panel{
      position: fixed;
      inset: 0;
      z-index: 1501;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
    }
    body[data-phone="on"] .preview-panel .preview-badges,
    body[data-phone="on"] .preview-panel .phone-text-size-row,
    body[data-phone="on"] .preview-panel .text-size-inline,
    body[data-phone="on"] .preview-panel .text-size-row{
      opacity: 0.85;
    }
    body[data-phone="on"] .panel,
    body[data-phone="on"] .notepad-shell,
    body[data-phone="on"] .mlcx-shell,
    body[data-phone="on"] .dev-shell{
      opacity: 0.08;
      pointer-events: none;
      filter: blur(1.2px);
    }



/* === Draft Peek Preview (hold 👁 to preview in phone) === */
.peek-btn{
  position:absolute;
  right:56px;
  bottom:14px;
  width:36px;
  height:36px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.14);
  background: rgba(10,14,24,.55);
  color: rgba(255,255,255,.92);
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  box-shadow: 0 8px 24px rgba(0,0,0,.28);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  transition: transform .18s ease, box-shadow .18s ease, border-color .18s ease, background .18s ease;
  user-select:none;
  z-index: 6;
}
.peek-btn:hover{ transform: translateY(-1px); border-color: rgba(255,255,255,.24); box-shadow: 0 10px 28px rgba(0,0,0,.34); }
.peek-btn:active{ transform: translateY(0px) scale(.98); }
.peek-btn.is-locked{
  border-color: rgba(255,255,255,.40);
  box-shadow: 0 10px 30px rgba(0,0,0,.38), 0 0 0 2px rgba(255,255,255,.10) inset;
}
.peek-btn.is-locked::after{
  content:"";
  position:absolute;
  inset:-6px;
  border-radius:18px;
  background: radial-gradient(circle at 50% 50%, rgba(255,255,255,.16), rgba(255,255,255,0) 60%);
  pointer-events:none;
  opacity:.7;
}

.chat-bubble.is-peek{
  opacity:.78;
  border-style: dashed !important;
}


/* === DEVLAB TEMP LOCKDOWN (MLCX ONLY) === */
/* Hide all DevLab toggles except MLCX */
.devlab-toggle-btn[data-view="editor"],
.devlab-toggle-btn[data-view="lib2"],
.devlab-toggle-btn[data-view="dict2"],
.devlab-toggle-btn[data-view="libdict"],
.devlab-toggle-btn[data-view="dict"] {
  display: none !important;
}


/* === DEVLAB SYSTEM THEME (UTILITARIAN) ===
   Goal: Keep Dev Lab highly readable across all colourways by using a stable,
   Writer-Insights-like system palette (flatter, less glow). */
:root{
  --sys-bg0:#0b1220;      /* page */
  --sys-bg1:#0f172a;      /* panels */
  --sys-bg2:#111b33;      /* cards */
  --sys-line:#24324a;     /* borders */
  --sys-line2:#1b2740;    /* subtle borders */
  --sys-t0:#e6eefc;       /* primary text */
  --sys-t1:#b7c4dd;       /* muted text */
  --sys-t2:#90a2c4;       /* softer */
  --sys-ac:#4ea3ff;       /* action accent */
  --sys-ac2:#2f6fb8;      /* subdued accent */
  --sys-badge:#121c32;    /* pill bg */
}

/* Apply only in Dev Lab mode */
body[data-layout="dev"] .devlab-wrap,
body[data-layout="dev"] .devlab-panel,
body[data-layout="dev"] .devlab-root,
body[data-layout="dev"] .devlab-container,
body[data-layout="dev"] #devLab,
body[data-layout="dev"] .devlab{
  background: var(--sys-bg0) !important;
  background-image: none !important;
  color: var(--sys-t0) !important;
}

/* Header + helper text */
body[data-layout="dev"] .devlab-head,
body[data-layout="dev"] .devlab-header,
body[data-layout="dev"] .devlab-title{
  color: var(--sys-t0) !important;
}
body[data-layout="dev"] .devlab-subtitle,
body[data-layout="dev"] .devlab-desc,
body[data-layout="dev"] .devlab-help,
body[data-layout="dev"] .devlab-muted{
  color: var(--sys-t1) !important;
}

/* Cards */
body[data-layout="dev"] .devlab-card,
body[data-layout="dev"] .devlab-section,
body[data-layout="dev"] .devlab-pane,
body[data-layout="dev"] .devlab-box{
  background: var(--sys-bg2) !important;
  border: 1px solid var(--sys-line) !important;
  box-shadow: none !important; /* flatter */
  color: var(--sys-t0) !important;
}

/* Text areas / pre blocks */
body[data-layout="dev"] textarea,
body[data-layout="dev"] pre,
body[data-layout="dev"] code,
body[data-layout="dev"] .devlab-mono,
body[data-layout="dev"] .devlab-output{
  background: var(--sys-bg1) !important;
  color: var(--sys-t0) !important;
  border: 1px solid var(--sys-line2) !important;
  box-shadow: none !important;
}

/* Buttons: readable, low-glow */
body[data-layout="dev"] button,
body[data-layout="dev"] .devlab-btn{
  background: rgba(78,163,255,0.10) !important;
  color: var(--sys-t0) !important;
  border: 1px solid rgba(78,163,255,0.35) !important;
  box-shadow: none !important;
}
body[data-layout="dev"] button:hover,
body[data-layout="dev"] .devlab-btn:hover{
  background: rgba(78,163,255,0.16) !important;
  border-color: rgba(78,163,255,0.55) !important;
}
body[data-layout="dev"] button:disabled,
body[data-layout="dev"] .devlab-btn:disabled{
  opacity: .55 !important;
}

/* Toggle row button (MLCX DEBUG) */
body[data-layout="dev"] .devlab-toggle-btn{
  background: rgba(78,163,255,0.08) !important;
  border: 1px solid rgba(78,163,255,0.28) !important;
  color: var(--sys-t1) !important;
  box-shadow: none !important;
}
body[data-layout="dev"] .devlab-toggle-btn.active{
  color: var(--sys-t0) !important;
  background: rgba(78,163,255,0.14) !important;
  border-color: rgba(78,163,255,0.60) !important;
}

/* Scenario tiles */
body[data-layout="dev"] .scenario-card,
body[data-layout="dev"] .demo-card,
body[data-layout="dev"] .devlab-scenario{
  background: var(--sys-bg2) !important;
  border: 1px solid var(--sys-line) !important;
  box-shadow: none !important;
}

</style>
<style>
/* Call Notes: Hide CX notch/overlay in mlcx layout mode */
body[data-layout="mlcx"] .cx-notch,
body[data-layout="mlcx"] .cx-drawer-overlay {
  display: none !important;
}

/* Call Notes pinned CX drawer wrapper */
.callnotes-cx-wrapper {
  width: 100%;
  max-width: 100%;
  height: 100%;
  max-height: 100%;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  flex-shrink: 0;
  border-left: 1px solid rgba(255,255,255,0.05);
  box-shadow: -6px 0 18px rgba(0,0,0,0.8);
  padding-left: 8px;
}

/* Pinned drawer styling (embedded, not floating) */
.callnotes-cx-pinned {
  position: static !important;
  width: 100%;
  max-width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  background:
    radial-gradient(circle at top left, rgba(148,163,184,0.12), transparent 55%),
    radial-gradient(circle at 100% 0, rgba(56,189,248,0.08), transparent 60%),
    linear-gradient(135deg, rgba(15,23,42,0.98), rgba(15,23,42,0.92));
  border-radius: 12px;
  border: 1px solid rgba(148,163,184,0.6);
  box-shadow:
    0 0 0 1px rgba(15,23,42,0.9),
    inset 0 0 0 1px rgba(148,163,184,0.15);
  backdrop-filter: blur(12px);
  padding: 12px;
  overflow: hidden;
  flex-shrink: 0;
}

/* Light mode: balanced background with readable borders */
body[data-theme="light"] .callnotes-cx-pinned {
  background: linear-gradient(to bottom, #f1f5f9, #e2e8f0);
  border: 1px solid rgba(71, 85, 105, 0.3);
  box-shadow:
    0 0 0 1px rgba(71, 85, 105, 0.15),
    0 4px 16px rgba(0, 0, 0, 0.1),
    0 0 30px rgba(56, 189, 248, 0.12);
}

/* Lunar mode: subtle dark blue with soft borders */
body[data-theme="lunar"] .callnotes-cx-pinned {
  background:
    radial-gradient(circle at top left, rgba(148,163,184,0.1), transparent 55%),
    radial-gradient(circle at 100% 0, rgba(56,189,248,0.06), transparent 60%),
    linear-gradient(135deg, rgba(15,23,42,0.9), rgba(15,23,42,0.85));
  border: 1px solid rgba(148,163,184,0.5);
  box-shadow:
    0 0 0 1px rgba(15,23,42,0.8),
    inset 0 0 0 1px rgba(148,163,184,0.12);
}

.callnotes-cx-pinned .cx-drawer-header {
  margin-bottom: 8px;
  flex-shrink: 0;
}

.callnotes-cx-pinned .cx-drawer-close-btn {
  display: none !important;
}

.callnotes-cx-pinned .cx-drawer-body {
  flex: 1 1 auto;
  width: 100%;
  max-width: 100%;
  min-height: 0;
  max-height: calc(100vh - 280px); /* Fixed max height based on viewport */
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-width: thin;
}

.callnotes-cx-pinned .cx-drawer-section {
  flex-shrink: 0;
  min-width: 0;
}

.callnotes-cx-pinned .cx-drawer-section > div,
.callnotes-cx-pinned .mlcx-highrisk-list li {
  min-width: 0;
  word-wrap: break-word;
  overflow-wrap: break-word;
}

.callnotes-cx-wrapper .cx-drawer-body::-webkit-scrollbar {
  width: 6px;
}
.callnotes-cx-wrapper .cx-drawer-body::-webkit-scrollbar-track {
  background: transparent;
}
.callnotes-cx-wrapper .cx-drawer-body::-webkit-scrollbar-thumb {
  border-radius: 999px;
  background: var(--scrollbar-thumb);
  box-shadow: 0 0 10px rgba(15, 23, 42, 0.9);
}

/* Light mode scrollbar visibility */
body[data-theme="light"] .callnotes-cx-wrapper .cx-drawer-body::-webkit-scrollbar-thumb {
  background: rgba(71, 85, 105, 0.5);
  box-shadow: 0 0 8px rgba(0, 0, 0, 0.15);
}

body[data-theme="lunar"] .callnotes-cx-wrapper .cx-drawer-body::-webkit-scrollbar-thumb {
  background: rgba(100, 116, 139, 0.6);
  box-shadow: 0 0 10px rgba(15, 23, 42, 0.8);
}
</style>
<script>
// --- Call Notes Pinned CX Drawer Sync ---
function updateCallNotesCxDrawer(analysis) {
  if (!analysis) return;
  
  const notesText = (typeof mlcxNotesInput !== 'undefined' && mlcxNotesInput) ? mlcxNotesInput.value : '';
  const lowerText = notesText.toLowerCase();
  
  // Scan using the same mlcxLibrary and civcLibrary as the Messenger drawer
  const mlcxHits = new Set();
  const civcHits = new Set();
  const allSnippets = [];
  
  // Scan MLCX library (emotion, clarity, urgency, etc.)
  if (typeof mlcxLibrary !== 'undefined') {
    Object.keys(mlcxLibrary).forEach((key) => {
      const entry = mlcxLibrary[key];
      if (!entry || !Array.isArray(entry.triggers)) return;
      entry.triggers.forEach((phrase) => {
        const needle = phrase.toLowerCase();
        if (needle && lowerText.includes(needle)) {
          mlcxHits.add(key);
          allSnippets.push({
            text: phrase,
            category: entry.meta ? entry.meta.label : key,
            type: 'mlcx',
            severity: 'medium'
          });
        }
      });
    });
  }
  
  // Scan CiVC library (vulnerability indicators)
  if (typeof civcLibrary !== 'undefined') {
    Object.keys(civcLibrary).forEach((key) => {
      const entry = civcLibrary[key];
      if (!entry || !Array.isArray(entry.triggers)) return;
      entry.triggers.forEach((phrase) => {
        const needle = phrase.toLowerCase();
        if (needle && lowerText.includes(needle)) {
          civcHits.add(key);
          allSnippets.push({
            text: phrase,
            category: entry.meta ? entry.meta.label : key,
            type: 'civc',
            severity: 'high'
          });
        }
      });
    });
  }
  
  // Group snippets by category
  const emotionSnippets = allSnippets.filter(s => 
    ['frustration', 'confusion', 'anxiety', 'urgency'].includes(s.category.toLowerCase()) ||
    s.category.toLowerCase().includes('emotion')
  );
  const claritySnippets = allSnippets.filter(s => 
    ['cost', 'routing'].includes(s.category.toLowerCase()) ||
    s.category.toLowerCase().includes('clarity') ||
    s.category.toLowerCase().includes('jargon')
  );
  const safetySnippets = allSnippets.filter(s => 
    s.type === 'civc' && ['safeguarding'].includes(s.category.toLowerCase())
  );
  const vulnSnippets = allSnippets.filter(s => 
    s.type === 'civc' && !['safeguarding'].includes(s.category.toLowerCase())
  );
  
  const totalCount = allSnippets.length;
  
  // Overview snapshot
  const notesSnapshot = document.getElementById("cxNotesSnapshot");
  if (notesSnapshot) {
    let severityBand = 'low';
    let severityLabel = 'Low activity';
    
    if (civcHits.size > 0 || totalCount >= 5) {
      severityBand = 'high';
      severityLabel = 'High concern';
    } else if (totalCount >= 3) {
      severityBand = 'medium';
      severityLabel = 'Medium concern';
    }
    
    notesSnapshot.innerHTML = `
      <div class="mlcx-snapshot-severity mlcx-severity-${severityBand}">${severityLabel}</div>
      <div class="mlcx-snapshot-counts">
        <span>Emotion ${emotionSnippets.length}</span> · 
        <span>Clarity ${claritySnippets.length}</span> · 
        <span>CX Risk ${mlcxHits.size}</span> · 
        <span>Safety ${civcHits.size}</span>
      </div>
    `;
  }
  
  // Emotion & Tone section
  const emotionSection = document.querySelector("#cxNotesDrawerBody .cx-drawer-section:nth-child(2)");
  if (emotionSection) {
    let html = '';
    if (emotionSnippets.length > 0 || claritySnippets.length > 0) {
      html = `<p style="font-size:0.74rem;margin-bottom:8px;color:rgba(203,213,225,0.9);">Emotion: ${emotionSnippets.length} signal(s) | Clarity: ${claritySnippets.length} signal(s)</p>`;
      
      const combined = [...emotionSnippets, ...claritySnippets].slice(0, 8);
      combined.forEach(snip => {
        const escaped = String(snip.text).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        const cat = snip.category || 'Signal';
        html += `<div style="margin:6px 0;padding:6px 8px;background:rgba(148,163,184,0.08);border-radius:8px;font-size:0.72rem;line-height:1.4;border-left:2px solid rgba(56,189,248,0.6);"><strong>${cat}</strong> · ${escaped}</div>`;
      });
    } else {
      html = '<p class="cx-drawer-section-empty">Emotional chips and tone bands will appear here as you type in Call Notes.</p>';
    }
    emotionSection.innerHTML = '<h3 class="cx-drawer-section-title">Emotion &amp; tone</h3>' + html;
  }
  
  // CV & Vulnerability section
  const vulnSummary = document.getElementById("mlcxNotesVulnSummary");
  if (vulnSummary) {
    let vulnHtml = '';
    if (civcHits.size > 0) {
      const severity = civcHits.size >= 2 ? 'high' : 'medium';
      const severityLabel = severity === 'high' ? 'High' : 'Medium';
      const severityColor = severity === 'high' ? '#ef4444' : '#f59e0b';
      
      const categories = Array.from(civcHits).map(key => {
        const entry = civcLibrary[key];
        return entry && entry.meta ? entry.meta.label : key;
      });
      
      vulnHtml += `<p class="mlcx-vuln-line" style="margin-bottom:6px;"><strong style="color:${severityColor};">Vulnerability level: ${severityLabel}</strong></p>`;
      vulnHtml += `<p class="mlcx-vuln-line" style="margin-bottom:6px;"><strong>Areas:</strong> ${categories.join(", ")}</p>`;
      
      if (severity === 'high') {
        vulnHtml += `<p class="mlcx-vuln-line" style="margin-bottom:6px;"><strong>Summary:</strong> Possible vulnerability indicators – consider offering extra time, checking understanding, and signposting to support if needed.</p>`;
      } else {
        vulnHtml += `<p class="mlcx-vuln-line" style="margin-bottom:6px;"><strong>Summary:</strong> Stay alert and adapt your approach as the conversation develops.</p>`;
      }
      
      if (vulnSnippets.length > 0) {
        vulnHtml += `<p class="mlcx-vuln-line" style="margin-top:8px;margin-bottom:4px;font-size:0.72rem;text-transform:uppercase;letter-spacing:0.08em;opacity:0.8;">Noticed phrases:</p>`;
        vulnSnippets.slice(0, 5).forEach(snip => {
          vulnHtml += `<div style="margin:4px 0;padding:4px 6px;background:rgba(239,68,68,0.12);border-radius:6px;font-size:0.72rem;border-left:2px solid rgba(239,68,68,0.5);">${snip.text}</div>`;
        });
      }
    } else {
      vulnHtml = '<p class="cx-drawer-section-empty">No clear vulnerability indicators detected yet. Use this space if you notice anything that might make the call harder for the customer.</p>';
    }
    vulnSummary.innerHTML = vulnHtml;
  }
  
  // High-risk snippets (prioritize civc, then mlcx)
  const notesHighRiskContent = document.getElementById("mlcxNotesHighRiskContent");
  if (notesHighRiskContent) {
    const prioritized = [
      ...safetySnippets,
      ...vulnSnippets,
      ...emotionSnippets.slice(0, 4),
      ...claritySnippets.slice(0, 4)
    ];
    
    // Filter unique
    const uniqueSnippets = [];
    const seen = new Set();
    prioritized.forEach(s => {
      const key = s.text.toLowerCase();
      if (!seen.has(key) && uniqueSnippets.length < 15) {
        uniqueSnippets.push(s);
        seen.add(key);
      }
    });
    
    if (uniqueSnippets.length === 0) {
      notesHighRiskContent.innerHTML = '<div class="mlcx-highrisk-empty">No high-risk snippets detected yet. This panel will list key phrases as they\'re flagged.</div>';
    } else {
      const listItems = uniqueSnippets.map(s => {
        const escaped = String(s.text).replace(/</g, "&lt;").replace(/>/g, "&gt;");
        const chipLabel = s.type === 'civc' ? s.category.toUpperCase() : s.category;
        const chipClass = s.type === 'civc' ? 'mlcx-highrisk-chip-safety' : 'mlcx-highrisk-chip';
        return `<li><span class="${chipClass}">${chipLabel}</span> ${escaped}</li>`;
      }).join("");
      notesHighRiskContent.innerHTML = `<ul class="mlcx-highrisk-list">${listItems}</ul>`;
    }
  }

  // Coaching section
  const coachingContent = document.getElementById("cxNotesCoachingContent");
  if (coachingContent) {
    const tips = [];
    
    if (civcHits.size > 0) {
      tips.push('Potential vulnerability detected - check if they need additional support or a different channel.');
    }
    if (safetySnippets.length > 0) {
      tips.push('High concern detected - take your time, stay calm, and be extra clear with next steps.');
    }
    if (emotionSnippets.length >= 3) {
      tips.push('Be mindful of tone - keep empathy front and center.');
    }
    if (claritySnippets.length >= 2) {
      tips.push('Check understanding: "Does that make sense?" or "Would you like me to..."');
    }
    
    // Add specific guidance from library entries
    mlcxHits.forEach(key => {
      const entry = mlcxLibrary[key];
      if (entry && entry.guidance && tips.length < 5) {
        tips.push(entry.guidance);
      }
    });
    
    if (tips.length > 0) {
      let html = '<ul style="margin:0;padding-left:20px;font-size:0.76rem;line-height:1.6;color:rgba(226,232,240,0.92);">';
      tips.slice(0, 5).forEach(tip => {
        html += `<li style="margin:6px 0;">${tip}</li>`;
      });
      html += '</ul>';
      coachingContent.innerHTML = html;
    } else {
      coachingContent.innerHTML = '<p class="cx-drawer-section-empty">Coaching tips will appear here based on your analysis.</p>';
    }
  }
}

// Patch refreshAllMlcxSurfaces to also update Call Notes pinned drawer
const origRefreshAllMlcxSurfaces = window.refreshAllMlcxSurfaces;
window.refreshAllMlcxSurfaces = function() {
  if (typeof origRefreshAllMlcxSurfaces === "function") origRefreshAllMlcxSurfaces();
  // Use mlcxHybridAnalysis from Call Notes or fallback to mlcxState
  const analysis = window.mlcxHybridAnalysis || window.mlcxState;
  if (analysis) updateCallNotesCxDrawer(analysis);
};

// Initial render on load
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", function() {
    if (window.mlcxState) updateCallNotesCxDrawer(window.mlcxState);
  });
} else {
  setTimeout(function() {
    if (window.mlcxState) updateCallNotesCxDrawer(window.mlcxState);
  }, 100);
}
</script>
  <style>
    /* Phase 19.13: Notepad sync buttons */
    .mlcx-sync-btn {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background:
        radial-gradient(circle at top, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.88));
      color: rgba(248, 250, 252, 0.95);
      font-size: 0.72rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      cursor: pointer;
      opacity: 0.9;
      transition: background 0.16s ease, box-shadow 0.16s ease, transform 0.08s ease;
      margin-left: 8px;
    }

    .mlcx-sync-btn:hover {
      opacity: 1;
      box-shadow: 0 2px 8px rgba(15, 23, 42, 0.7);
    }

    body[data-theme="lunar"] .mlcx-sync-btn,
    body[data-theme="light"] .mlcx-sync-btn {
      background:
        radial-gradient(circle at top, rgba(255, 255, 255, 0.98), rgba(229, 231, 235, 0.96));
      color: #0f172a;
    }

    /* Phase 19.13: Coaching card activation + count badges */
    .mlcx-og-card {
      transition: box-shadow 0.18s ease, border-color 0.18s ease, transform 0.08s ease;
    }
    .mlcx-og-card.mlcx-card-active {
      border-color: rgba(59, 130, 246, 0.9);
      box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.65), 0 10px 24px rgba(15, 23, 42, 0.75);
      transform: translateY(-1px);
    }
    .mlcx-card-count {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 18px;
      padding: 2px 6px;
      margin-left: 6px;
      border-radius: 999px;
      background: rgba(59, 130, 246, 0.95);
      color: #f9fafb;
      font-size: 0.7rem;
      font-weight: 600;
    }
    body[data-theme="lunar"] .mlcx-card-count,
    body[data-theme="light"] .mlcx-card-count {
      background: rgba(59, 130, 246, 0.9);
      color: #0f172a;
    }

    .mlcx-snippet-btn {
      margin-top: 8px;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px dashed rgba(148, 163, 184, 0.5);
      background: transparent;
      color: rgba(148, 163, 184, 0.95);
      font-size: 0.72rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: background 0.18s ease, border-color 0.18s ease, box-shadow 0.18s ease, transform 0.12s ease;
    }
    .mlcx-snippet-btn::before {
      content: '💡';
      font-size: 0.8rem;
      opacity: 0.85;
    }
    .mlcx-snippet-btn:hover {
      background: rgba(148, 163, 184, 0.14);
      border-style: solid;
      border-color: rgba(148, 163, 184, 0.95);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25), 0 0 0 1px rgba(15, 23, 42, 0.75);
      transform: translateY(-1px);
    }
    @keyframes mlcxSnippetPulse {
      0%, 100% { border-color: rgba(148, 163, 184, 0.5); }
      50% { border-color: rgba(148, 163, 184, 0.9); }
    }
    .mlcx-snippet-btn.is-new {
      animation: mlcxSnippetPulse 2s ease-in-out 1;
    }
  </style>










<style>
  /* THE CROWN - HASTINGS / OUTsurance / SA FLAG EDITION */

  /* Crown – Light (Day): Hastings Red, White & Blue */
  body[data-colour="crown"][data-theme="light"] {
    --primary-bg: #FFFFFF;
    --primary-surface: #F9FAFF;
    --primary-text: #111827;

    --accent-red: #D71920;   /* Hastings red */
    --accent-blue: #003A70;  /* Hastings deep blue */

    --accent: var(--accent-red);
    --accent-soft: #FDD5D8;

    background:
      radial-gradient(circle at 15% 20%, #ffffff, transparent 55%),
      radial-gradient(circle at 85% 90%, #f9faff, #dbeafe);
  }
  body[data-theme="light"][data-colour="crown"] .chat-body {
    background:
      radial-gradient(circle at top, #ffffff 0, #eff6ff 40%, #e5e7eb 100%);
  }
  body[data-theme="light"][data-colour="crown"] .chat-bubble.customer {
    background: #D71920;
    border-color: #B0141A;
    color: #FEF2F2;
  }
  body[data-theme="light"][data-colour="crown"] .chat-bubble.agent {
    background: #003A70;
    border-color: #001A3D;
    color: #E5F0FF;
  }
  body[data-theme="light"][data-colour="crown"] .phone-frame {
    border-color: #D71920;
    box-shadow: 0 26px 60px rgba(215, 25, 32, 0.55);
  }

  /* Crown – Dark: SA Flag Night */
  body[data-colour="crown"][data-theme="dark"] {
    --primary-bg: #020308;
    --primary-surface: #050815;
    --primary-text: #F9FAFB;

    --accent-red: #DE3831;
    --accent-green: #007A4D;
    --accent-blue: #002395;
    --accent-gold: #FFB81C;

    --accent: var(--accent-green);
    --accent-soft: #1F9B66;

    background:
      radial-gradient(circle at 20% 25%, #111827, transparent 55%),
      radial-gradient(circle at 70% 85%, #020308, #000000);
  }
  body[data-theme="dark"][data-colour="crown"] .chat-body {
    background:
      radial-gradient(circle at 12% 15%, #DE3831 0, transparent 45%),
      radial-gradient(circle at 85% 20%, #007A4D 0, transparent 45%),
      radial-gradient(circle at 50% 90%, #002395 0, transparent 55%),
      radial-gradient(circle at 50% 40%, #020617 0, #020308 100%);
  }
  body[data-theme="dark"][data-colour="crown"] .chat-bubble.customer {
    background: #DE3831;
    border-color: #A3221D;
    color: #FEF2F2;
  }
  body[data-theme="dark"][data-colour="crown"] .chat-bubble.agent {
    background: #007A4D;
    border-color: #005336;
    color: #E6FFFA;
  }
  body[data-theme="dark"][data-colour="crown"] .phone-frame {
    border-color: #FFB81C;
    box-shadow: 0 26px 70px rgba(255, 184, 28, 0.65);
  }

  /* Crown – Lunar: OUTsurance Rift */
  body[data-colour="crown"][data-theme="lunar"] {
    --primary-bg: #36185A;  /* OUT purple base */
    --primary-surface: #4A227A;
    --primary-text: #F9F5FF;

    --accent-purple: #732282;  /* OUT purple */
    --accent-green: #8DC63F;   /* OUT green */

    --accent: var(--accent-green);
    --accent-soft: #C8F79C;

    background:
      radial-gradient(circle at 25% 25%, #4a227a, transparent 55%),
      radial-gradient(circle at 70% 85%, #36185a, #111827);
  }
  body[data-theme="lunar"][data-colour="crown"] .chat-body {
    background:
      radial-gradient(circle at 20% 20%, #732282 0, transparent 45%),
      radial-gradient(circle at 80% 80%, #8DC63F 0, transparent 55%),
      radial-gradient(circle at 50% 50%, #020617 0, #020617 100%);
  }
  body[data-theme="lunar"][data-colour="crown"] .chat-bubble.customer {
    background: #732282;
    border-color: #4E1657;
    color: #FEF5FF;
  }
  body[data-theme="lunar"][data-colour="crown"] .chat-bubble.agent {
    background: #111827;
    border-color: #8DC63F;
    color: #E5FDF2;
  }
  body[data-theme="lunar"][data-colour="crown"] .phone-frame {
    border-color: #8DC63F;
    box-shadow: 0 24px 60px rgba(141, 198, 63, 0.55);
  }
.font-size-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
}
.bubble-add-group {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.bubble-add-btn {
  position: relative;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 26px;
  border-radius: 999px;
  border: none;
  cursor: pointer;
  padding: 0;
  background: rgba(0, 0, 0, 0.08);
  box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  transition: transform 0.18s ease-out, box-shadow 0.18s ease-out, background 0.18s ease-out;
}

body[data-theme="dark"] .bubble-add-btn {
  background: rgba(255, 255, 255, 0.05);
}

body[data-theme="lunar"] .bubble-add-btn {
  background: rgba(255, 255, 255, 0.08);
}

.bubble-add-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 10px rgba(0,0,0,0.25);
}

.bubble-add-btn:active {
  transform: translateY(0);
  box-shadow: 0 1px 3px rgba(0,0,0,0.18);
}

.bubble-add-dot {
  width: 14px;
  height: 14px;
  border-radius: 999px;
  background: rgba(255, 255, 255, 0.3);
  box-shadow: inset 0 0 0 1px rgba(0,0,0,0.15);
}

.bubble-add-plus {
  position: absolute;
  right: 8px;
  font-size: 14px;
  font-weight: 600;
  line-height: 1;
  color: rgba(0,0,0,0.7);
}

body[data-theme="dark"] .bubble-add-plus,
body[data-theme="lunar"] .bubble-add-plus {
  color: rgba(255,255,255,0.9);
}


body[data-cx-mode="on"] .mlcx-pills-row {
  display: none !important;
}


/* FULLSCREEN MLCX DASHBOARD LAYOUT */
body[data-layout="mlcx"] .app-main {
      height: 100%;
      min-height: 100%;
      display: flex;
      flex-direction: column;
    }

body[data-layout="mlcx"] .app-card {
      height: calc(100vh - 40px);
      display: flex;
      flex-direction: column;
    }

body[data-layout="mlcx"] .mlcx-panel {
      display: flex;
    }

.mlcx-layout {
      flex: 1 1 auto;
      height: 100%;
      min-height: 100%;
      display: grid;
      grid-template-columns: 2fr 1.2fr;
      gap: 24px;
    }

.mlcx-notes-column {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

.mlcx-notes-textarea {
      flex: 1 1 auto;
      min-height: 60vh;
      height: 100%;
      resize: vertical;
    }

.mlcx-train-column {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }

.mlcx-training-panel {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow: auto;
    }

</style>


<style>
  /* RIFT - SHADOWFIRE THEME */

  /* Rift – Light: Fractured Dawn */
  body[data-colour="classic"][data-theme="light"] {
    --primary-bg: #0F1220;
    --primary-surface: #15182A;
    --primary-text: #F7E4D3;

    --accent-shadow: #3D0238;   /* void-purple vein */
    --accent-fire:   #FF4A1C;   /* ember vein */
    --accent-glow:   #FFB06A;   /* flame gold */

    --accent: var(--accent-fire);
    --accent-soft: #F79F6A;

    background:
      radial-gradient(circle at 18% 20%, #15182A 0, transparent 55%),
      radial-gradient(circle at 80% 88%, #0F1220 0, #000000 70%);
  }
  body[data-theme="light"][data-colour="classic"] .chat-body {
    background:
      radial-gradient(circle at 12% 16%, #3D0238 0, transparent 45%),
      radial-gradient(circle at 86% 26%, #FF4A1C 0, transparent 55%),
      radial-gradient(circle at 50% 90%, #000000 0, #000000 100%);
  }
  body[data-theme="light"][data-colour="classic"] .chat-bubble.customer {
    background: #FF4A1C;
    border-color: #FFB06A;
    color: #0B0610;
  }
  body[data-theme="light"][data-colour="classic"] .chat-bubble.agent {
    background: #15182A;
    border-color: #F7E4D3;
    color: #F7E4D3;
  }

  /* Rift – Dark: Core Shadowfire */
  body[data-colour="classic"][data-theme="dark"] {
    --primary-bg: #000000;
    --primary-surface: #050314;
    --primary-text: #F7E4D3;

    --accent-shadow: #6A00FF;
    --accent-fire:   #FF4A1C;
    --accent-glow:   #FFB06A;

    --accent: var(--accent-fire);
    --accent-soft: #6A00FF;

    background:
      radial-gradient(circle at 18% 22%, #120A1C 0, transparent 55%),
      radial-gradient(circle at 78% 82%, #050314 0, #000000 80%);
  }
  body[data-theme="dark"][data-colour="classic"] .chat-body {
    background:
      radial-gradient(circle at 14% 18%, rgba(106, 0, 255, 0.35) 0, transparent 55%),
      radial-gradient(circle at 84% 20%, rgba(255, 74, 28, 0.45) 0, transparent 55%),
      radial-gradient(circle at 50% 90%, #000000 0, #000000 100%);
  }
  body[data-theme="dark"][data-colour="classic"] .chat-bubble.customer {
    background: #FF4A1C;
    border-color: #FFB06A;
    color: #0B0610;
  }
  body[data-theme="dark"][data-colour="classic"] .chat-bubble.agent {
    background: #050314;
    border-color: #6A00FF;
    color: #F7E4D3;
  }

  /* Rift – Lunar: Ember Afterglow */
  body[data-colour="classic"][data-theme="lunar"] {
    --primary-bg: #120A1C;
    --primary-surface: #1B1024;
    --primary-text: #F7E4D3;

    --accent-shadow: #3D0238;
    --accent-fire:   #FF4A1C;
    --accent-glow:   #FFB06A;

    --accent: var(--accent-shadow);
    --accent-soft: #C084FC;

    background:
      radial-gradient(circle at 20% 22%, #1B1024 0, transparent 55%),
      radial-gradient(circle at 78% 90%, #120A1C 0, #000000 85%);
  }
  body[data-theme="lunar"][data-colour="classic"] .chat-body {
    background:
      radial-gradient(circle at 18% 18%, rgba(255, 74, 28, 0.32) 0, transparent 52%),
      radial-gradient(circle at 82% 26%, rgba(192, 132, 252, 0.38) 0, transparent 55%),
      radial-gradient(circle at 50% 80%, #000000 0, #000000 100%);
  }
  body[data-theme="lunar"][data-colour="classic"] .chat-bubble.customer {
    background: #C084FC;
    border-color: #6A00FF;
    color: #120A1C;
  }
  body[data-theme="lunar"][data-colour="classic"] .chat-bubble.agent {
    background: #120A1C;
    border-color: #FF4A1C;
    color: #F7E4D3;
  }
.font-size-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
}
.bubble-add-group {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.bubble-add-btn {
  position: relative;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 26px;
  border-radius: 999px;
  border: none;
  cursor: pointer;
  padding: 0;
  background: rgba(0, 0, 0, 0.08);
  box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  transition: transform 0.18s ease-out, box-shadow 0.18s ease-out, background 0.18s ease-out;
}

body[data-theme="dark"] .bubble-add-btn {
  background: rgba(255, 255, 255, 0.05);
}

body[data-theme="lunar"] .bubble-add-btn {
  background: rgba(255, 255, 255, 0.08);
}

.bubble-add-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 10px rgba(0,0,0,0.25);
}

.bubble-add-btn:active {
  transform: translateY(0);
  box-shadow: 0 1px 3px rgba(0,0,0,0.18);
}

.bubble-add-dot {
  width: 14px;
  height: 14px;
  border-radius: 999px;
  background: rgba(255, 255, 255, 0.3);
  box-shadow: inset 0 0 0 1px rgba(0,0,0,0.15);
}

.bubble-add-plus {
  position: absolute;
  right: 8px;
  font-size: 14px;
  font-weight: 600;
  line-height: 1;
  color: rgba(0,0,0,0.7);
}

body[data-theme="dark"] .bubble-add-plus,
body[data-theme="lunar"] .bubble-add-plus {
  color: rgba(255,255,255,0.9);
}


body[data-cx-mode="on"] .mlcx-pills-row {
  display: none !important;
}


/* FULLSCREEN MLCX DASHBOARD LAYOUT */
body[data-layout="mlcx"] .app-main {
      height: 100%;
      min-height: 100%;
      display: flex;
      flex-direction: column;
    }

body[data-layout="mlcx"] .app-card {
      height: calc(100vh - 40px);
      display: flex;
      flex-direction: column;
    }

body[data-layout="mlcx"] .mlcx-panel {
      display: flex;
    }

.mlcx-layout {
      flex: 1 1 auto;
      height: 100%;
      min-height: 100%;
      display: grid;
      grid-template-columns: 2fr 1.2fr;
      gap: 24px;
    }

.mlcx-notes-column {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

.mlcx-notes-textarea {
      flex: 1 1 auto;
      min-height: 60vh;
      height: 100%;
      resize: vertical;
    }

.mlcx-train-column {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }

.mlcx-training-panel {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow: auto;
    }

</style>


<style>
  /* SUNBURST - SOLAR FORGE (Spectrum Rift C) */

  /* Light – Solar Dawn */
  body[data-colour="sunburst"][data-theme="light"] {
    --primary-bg:#FFF4D8;
    --primary-surface:#FFF9EA;
    --primary-text:#3A1C00;

    --accent:#FF9A42;
    --accent-soft:#FFE2B3;

    background:
      radial-gradient(circle at 20% 22%, #fff9ea, transparent 50%),
      radial-gradient(circle at 80% 85%, #fff4d8, #ffd46b);
  }
  body[data-theme="light"][data-colour="sunburst"] .chat-body {
    background:
      radial-gradient(circle at top, #ffd46b 0, #ffe9c0 40%, #f3f4f6 100%);
  }
  body[data-theme="light"][data-colour="sunburst"] .chat-bubble.customer {
    background:#FF6A3C;
    border-color:#D54E28;
    color:#FFF7F5;
  }
  body[data-theme="light"][data-colour="sunburst"] .chat-bubble.agent {
    background:#4CA9FF;
    border-color:#1A6FD6;
    color:#EAF4FF;
  }

  /* Dark – Solar Flare */
  body[data-colour="sunburst"][data-theme="dark"] {
    --primary-bg:#120400;
    --primary-surface:#1F0A00;
    --primary-text:#FFE8D6;

    --accent:#FF3B00;
    --accent-soft:#D44A00;

    background:
      radial-gradient(circle at 18% 22%, #1f0a00, transparent 55%),
      radial-gradient(circle at 78% 88%, #120400, #000000);
  }
  body[data-theme="dark"][data-colour="sunburst"] .chat-body {
    background:
      radial-gradient(circle at 12% 15%, #FF3B00 0, transparent 45%),
      radial-gradient(circle at 88% 25%, #D44A00 0, transparent 45%),
      radial-gradient(circle at 50% 80%, #120400 0, #000000 100%);
  }
  body[data-theme="dark"][data-colour="sunburst"] .chat-bubble.customer {
    background:#FF3B00;
    border-color:#B72A00;
    color:#FFEDE5;
  }
  body[data-theme="dark"][data-colour="sunburst"] .chat-bubble.agent {
    background:#0A0300;
    border-color:#FF6A3C;
    color:#FFE8D6;
  }

  /* Lunar – Coronal Spectrum (C-mode) */
  body[data-colour="sunburst"][data-theme="lunar"] {
    --primary-bg:#0C1130;
    --primary-surface:#141A3F;
    --primary-text:#E8F0FF;

    --accent:#F8C84E;   /* soft spectral yellow */
    --accent-soft:#A5E6FF;

    background:
      radial-gradient(circle at 30% 30%, #141a3f, transparent 55%),
      radial-gradient(circle at 70% 88%, #0c1130, #020617);
  }
  body[data-theme="lunar"][data-colour="sunburst"] .chat-body {
    background:
      radial-gradient(circle at 20% 18%, #F8C84E 0, transparent 45%),
      radial-gradient(circle at 80% 82%, #3DB7FF 0, transparent 45%),
      radial-gradient(circle at 50% 50%, #0C1130 0, #020617 100%);
  }
  body[data-theme="lunar"][data-colour="sunburst"] .chat-bubble.customer {
    background:#F8C84E;
    border-color:#D4A535;
    color:#2A2100;
  }
  body[data-theme="lunar"][data-colour="sunburst"] .chat-bubble.agent {
    background:#10162F;
    border-color:#3DB7FF;
    color:#E8F0FF;
  }
.font-size-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
}
.bubble-add-group {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.bubble-add-btn {
  position: relative;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 26px;
  border-radius: 999px;
  border: none;
  cursor: pointer;
  padding: 0;
  background: rgba(0, 0, 0, 0.08);
  box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  transition: transform 0.18s ease-out, box-shadow 0.18s ease-out, background 0.18s ease-out;
}

body[data-theme="dark"] .bubble-add-btn {
  background: rgba(255, 255, 255, 0.05);
}

body[data-theme="lunar"] .bubble-add-btn {
  background: rgba(255, 255, 255, 0.08);
}

.bubble-add-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 10px rgba(0,0,0,0.25);
}

.bubble-add-btn:active {
  transform: translateY(0);
  box-shadow: 0 1px 3px rgba(0,0,0,0.18);
}

.bubble-add-dot {
  width: 14px;
  height: 14px;
  border-radius: 999px;
  background: rgba(255, 255, 255, 0.3);
  box-shadow: inset 0 0 0 1px rgba(0,0,0,0.15);
}

.bubble-add-plus {
  position: absolute;
  right: 8px;
  font-size: 14px;
  font-weight: 600;
  line-height: 1;
  color: rgba(0,0,0,0.7);
}

body[data-theme="dark"] .bubble-add-plus,
body[data-theme="lunar"] .bubble-add-plus {
  color: rgba(255,255,255,0.9);
}


body[data-cx-mode="on"] .mlcx-pills-row {
  display: none !important;
}


/* FULLSCREEN MLCX DASHBOARD LAYOUT */
body[data-layout="mlcx"] .app-main {
      height: 100%;
      min-height: 100%;
      display: flex;
      flex-direction: column;
    }

body[data-layout="mlcx"] .app-card {
      height: calc(100vh - 40px);
      display: flex;
      flex-direction: column;
    }

body[data-layout="mlcx"] .mlcx-panel {
      display: flex;
    }

.mlcx-layout {
      flex: 1 1 auto;
      height: 100%;
      min-height: 100%;
      display: grid;
      grid-template-columns: 2fr 1.2fr;
      gap: 24px;
    }

.mlcx-notes-column {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

.mlcx-notes-textarea {
      flex: 1 1 auto;
      min-height: 60vh;
      height: 100%;
      resize: vertical;
    }

.mlcx-train-column {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }

.mlcx-training-panel {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow: auto;
    }

</style>


<style>
  /* AURORA - CELESTIAL BAOBAB EDITION */

  /* Light – Canopy Dawn (soft aurora above the savannah) */
  body[data-colour="aurora"][data-theme="light"] {
    --primary-bg: #EDEBFF;        /* pale violet sky */
    --primary-surface: #F7F5FF;   /* soft canopy haze */
    --primary-text: #111322;

    --accent: #9AE6B4;            /* soft aurora green */
    --accent-soft: #C7F9D4;

    background:
      radial-gradient(circle at 22% 18%, #f7f5ff, transparent 55%),
      radial-gradient(circle at 78% 86%, #edebff, #c4c0ff);
  }
  body[data-theme="light"][data-colour="aurora"] .chat-body {
    background:
      radial-gradient(circle at top, #edebff 0, #c4c0ff 36%, #e5f9f4 78%, #f9fafb 100%);
  }
  body[data-theme="light"][data-colour="aurora"] .chat-bubble.customer {
    background: #7F5AF0;     /* violet ribbon */
    border-color: #5432B8;
    color: #F7F2FF;
  }
  body[data-theme="light"][data-colour="aurora"] .chat-bubble.agent {
    background: #17C69B;     /* soft canopy green */
    border-color: #099268;
    color: #F1FFFA;
  }
  body[data-theme="light"][data-colour="aurora"] .phone-frame {
    border-color: #7F5AF0;
    box-shadow: 0 18px 44px rgba(127, 90, 240, 0.35);
  }

  /* Dark – Rift Sky (auroras over the Great Celestial Baobab) */
  body[data-colour="aurora"][data-theme="dark"] {
    --primary-bg: #050517;        /* deep night */
    --primary-surface: #091029;   /* horizon glow */
    --primary-text: #E8ECFF;

    --accent: #4ADE80;            /* bright aurora green */
    --accent-soft: #38BDF8;       /* cool cyan ribbon */

    background:
      radial-gradient(circle at 28% 20%, #1b103b, transparent 55%),
      radial-gradient(circle at 72% 88%, #050517, #020010);
  }
  body[data-theme="dark"][data-colour="aurora"] .chat-body {
    background:
      radial-gradient(circle at 15% 18%, #4ADE80 0, transparent 45%),
      radial-gradient(circle at 85% 22%, #38BDF8 0, transparent 50%),
      radial-gradient(circle at 50% 90%, #7C3AED 0, transparent 60%),
      radial-gradient(circle at 50% 50%, #020617 0, #020617 100%);
  }
  body[data-theme="dark"][data-colour="aurora"] .chat-bubble.customer {
    background: #4ADE80;         /* aurora green arc */
    border-color: #15803D;
    color: #052E16;
  }
  body[data-theme="dark"][data-colour="aurora"] .chat-bubble.agent {
    background: #1D2240;         /* night ridge */
    border-color: #38BDF8;       /* cyan edge like aurora curtain */
    color: #E8ECFF;
  }
  body[data-theme="dark"][data-colour="aurora"] .phone-frame {
    border-color: #38BDF8;
    box-shadow: 0 26px 64px rgba(56, 189, 248, 0.62);
  }

  /* Lunar – Baobab Crown (Rift-touched aurora canopies) */
  body[data-colour="aurora"][data-theme="lunar"] {
    --primary-bg: #0A1028;        /* deeper magic sky */
    --primary-surface: #111637;
    --primary-text: #EEF4FF;

    --accent: #A855F7;            /* magenta-violet ribbon */
    --accent-soft: #4ADE80;       /* echo of green below */

    background:
      radial-gradient(circle at 32% 24%, #111637, transparent 55%),
      radial-gradient(circle at 68% 90%, #0a1028, #020617);
  }
  body[data-theme="lunar"][data-colour="aurora"] .chat-body {
    background:
      radial-gradient(circle at 18% 18%, #A855F7 0, transparent 45%),
      radial-gradient(circle at 82% 26%, #4ADE80 0, transparent 50%),
      radial-gradient(circle at 50% 88%, #38BDF8 0, transparent 55%),
      radial-gradient(circle at 50% 50%, #020617 0, #020617 100%);
  }
  body[data-theme="lunar"][data-colour="aurora"] .chat-bubble.customer {
    background: #A855F7;         /* Riftborn purple aurora */
    border-color: #7C3AED;
    color: #FEF5FF;
  }
  body[data-theme="lunar"][data-colour="aurora"] .chat-bubble.agent {
    background: #020617;
    border-color: #4ADE80;
    color: #E8FDF4;
  }
  body[data-theme="lunar"][data-colour="aurora"] .phone-frame {
    border-color: #A855F7;
    box-shadow: 0 24px 60px rgba(168, 85, 247, 0.55);
  }
.font-size-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
}
.bubble-add-group {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.bubble-add-btn {
  position: relative;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 26px;
  border-radius: 999px;
  border: none;
  cursor: pointer;
  padding: 0;
  background: rgba(0, 0, 0, 0.08);
  box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  transition: transform 0.18s ease-out, box-shadow 0.18s ease-out, background 0.18s ease-out;
}

body[data-theme="dark"] .bubble-add-btn {
  background: rgba(255, 255, 255, 0.05);
}

body[data-theme="lunar"] .bubble-add-btn {
  background: rgba(255, 255, 255, 0.08);
}

.bubble-add-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 10px rgba(0,0,0,0.25);
}

.bubble-add-btn:active {
  transform: translateY(0);
  box-shadow: 0 1px 3px rgba(0,0,0,0.18);
}

.bubble-add-dot {
  width: 14px;
  height: 14px;
  border-radius: 999px;
  background: rgba(255, 255, 255, 0.3);
  box-shadow: inset 0 0 0 1px rgba(0,0,0,0.15);
}

.bubble-add-plus {
  position: absolute;
  right: 8px;
  font-size: 14px;
  font-weight: 600;
  line-height: 1;
  color: rgba(0,0,0,0.7);
}

body[data-theme="dark"] .bubble-add-plus,
body[data-theme="lunar"] .bubble-add-plus {
  color: rgba(255,255,255,0.9);
}


body[data-cx-mode="on"] .mlcx-pills-row {
  display: none !important;
}


/* FULLSCREEN MLCX DASHBOARD LAYOUT */
body[data-layout="mlcx"] .app-main {
      height: 100%;
      min-height: 100%;
      display: flex;
      flex-direction: column;
    }

body[data-layout="mlcx"] .app-card {
      height: calc(100vh - 40px);
      display: flex;
      flex-direction: column;
    }

body[data-layout="mlcx"] .mlcx-panel {
      display: flex;
    }

.mlcx-layout {
      flex: 1 1 auto;
      height: 100%;
      min-height: 100%;
      display: grid;
      grid-template-columns: 2fr 1.2fr;
      gap: 24px;
    }

.mlcx-notes-column {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

.mlcx-notes-textarea {
      flex: 1 1 auto;
      min-height: 60vh;
      height: 100%;
      resize: vertical;
    }

.mlcx-train-column {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }

.mlcx-training-panel {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow: auto;
    }

</style>


<style>
  /* THE GROVE - BAOBAB WOODLAND */

  /* Grove – Light: Canopy Morning */
  body[data-colour="nighttide"][data-theme="light"]{
    --primary-bg:#d8eeeb;
    --primary-surface:#f5fbf8;
    --primary-text:#143328;

    --accent:#156669;
    --accent-soft:#6fd19f;

    background:
      radial-gradient(circle at 20% 25%, #b1ddd6, transparent 55%),
      radial-gradient(circle at 80% 85%, #f5fbf8, #d8eeeb);
  }
  body[data-theme="light"][data-colour="nighttide"] .chat-body{
    background:
      radial-gradient(circle at 18% 20%, #b1ddd6 0, transparent 50%),
      radial-gradient(circle at 82% 30%, #6fd19f 0, transparent 55%),
      radial-gradient(circle at 50% 88%, #f5fbf8 0, #f5fbf8 100%);
  }
  body[data-theme="light"][data-colour="nighttide"] .chat-bubble.customer{
    background:#156669;
    border-color:#0a7d42;
    color:#f5fbf8;
  }
  body[data-theme="light"][data-colour="nighttide"] .chat-bubble.agent{
    background:#ffffff;
    border-color:#6fd19f;
    color:#143328;
  }

  /* Grove – Dark: Roots at Dusk */
  body[data-colour="nighttide"][data-theme="dark"]{
    --primary-bg:#051710;
    --primary-surface:#071f16;
    --primary-text:#d8eeeb;

    --accent:#156669;
    --accent-soft:#78a39c;

    background:
      radial-gradient(circle at 18% 22%, #156669, transparent 55%),
      radial-gradient(circle at 74% 88%, #051710, #000000);
  }
  body[data-theme="dark"][data-colour="nighttide"] .chat-body{
    background:
      radial-gradient(circle at 20% 18%, rgba(21,102,105,0.55) 0, transparent 55%),
      radial-gradient(circle at 80% 26%, rgba(111,209,159,0.40) 0, transparent 55%),
      radial-gradient(circle at 50% 88%, #020617 0, #000000 100%);
  }
  body[data-theme="dark"][data-colour="nighttide"] .chat-bubble.customer{
    background:#156669;
    border-color:#6fd19f;
    color:#d8eeeb;
  }
  body[data-theme="dark"][data-colour="nighttide"] .chat-bubble.agent{
    background:#071f16;
    border-color:#78a39c;
    color:#d8eeeb;
  }

  /* Grove – Lunar: Lantern Canopy */
  body[data-colour="nighttide"][data-theme="lunar"]{
    --primary-bg:#0b2320;
    --primary-surface:#12342f;
    --primary-text:#e6f6f1;

    --accent:#6fd19f;
    --accent-soft:#d4b46a;

    background:
      radial-gradient(circle at 24% 26%, #12342f, transparent 55%),
      radial-gradient(circle at 76% 90%, #0b2320, #020617);
  }
  body[data-theme="lunar"][data-colour="nighttide"] .chat-body{
    background:
      radial-gradient(circle at 18% 18%, rgba(111,209,159,0.4) 0, transparent 52%),
      radial-gradient(circle at 82% 26%, rgba(180,130,74,0.36) 0, transparent 55%),
      radial-gradient(circle at 50% 88%, #020617 0, #000000 100%);
  }
  body[data-theme="lunar"][data-colour="nighttide"] .chat-bubble.customer{
    background:#6fd19f;
    border-color:#d4b46a;
    color:#12342f;
  }
  body[data-theme="lunar"][data-colour="nighttide"] .chat-bubble.agent{
    background:#12342f;
    border-color:#b1ddd6;
    color:#e6f6f1;
  }
.font-size-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
}
.bubble-add-group {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.bubble-add-btn {
  position: relative;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 26px;
  border-radius: 999px;
  border: none;
  cursor: pointer;
  padding: 0;
  background: rgba(0, 0, 0, 0.08);
  box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  transition: transform 0.18s ease-out, box-shadow 0.18s ease-out, background 0.18s ease-out;
}

body[data-theme="dark"] .bubble-add-btn {
  background: rgba(255, 255, 255, 0.05);
}

body[data-theme="lunar"] .bubble-add-btn {
  background: rgba(255, 255, 255, 0.08);
}

.bubble-add-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 10px rgba(0,0,0,0.25);
}

.bubble-add-btn:active {
  transform: translateY(0);
  box-shadow: 0 1px 3px rgba(0,0,0,0.18);
}

.bubble-add-dot {
  width: 14px;
  height: 14px;
  border-radius: 999px;
  background: rgba(255, 255, 255, 0.3);
  box-shadow: inset 0 0 0 1px rgba(0,0,0,0.15);
}

.bubble-add-plus {
  position: absolute;
  right: 8px;
  font-size: 14px;
  font-weight: 600;
  line-height: 1;
  color: rgba(0,0,0,0.7);
}

body[data-theme="dark"] .bubble-add-plus,
body[data-theme="lunar"] .bubble-add-plus {
  color: rgba(255,255,255,0.9);
}


body[data-cx-mode="on"] .mlcx-pills-row {
  display: none !important;
}


/* FULLSCREEN MLCX DASHBOARD LAYOUT */
body[data-layout="mlcx"] .app-main {
      height: 100%;
      min-height: 100%;
      display: flex;
      flex-direction: column;
    }

body[data-layout="mlcx"] .app-card {
      height: calc(100vh - 40px);
      display: flex;
      flex-direction: column;
    }

body[data-layout="mlcx"] .mlcx-panel {
      display: flex;
    }

.mlcx-layout {
      flex: 1 1 auto;
      height: 100%;
      min-height: 100%;
      display: grid;
      grid-template-columns: 2fr 1.2fr;
      gap: 24px;
    }

.mlcx-notes-column {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

.mlcx-notes-textarea {
      flex: 1 1 auto;
      min-height: 60vh;
      height: 100%;
      resize: vertical;
    }

.mlcx-train-column {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }

.mlcx-training-panel {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow: auto;
    }

</style>


<style>
  /* ECHO - MEMORY STITCH THEME */

  /* Echo – Light: Stitched Dawn */
  body[data-colour="sahara"][data-theme="light"] {
    --primary-bg: #F1E6FF;
    --primary-surface: #F9F4FF;
    --primary-text: #2B2431;

    --accent-plum:   #4B2E4F;
    --accent-lilac:  #A78BC3;
    --accent-gold:   #D9BB65;

    --accent: var(--accent-lilac);
    --accent-soft: #E0D0FF;

    background:
      radial-gradient(circle at 14% 20%, #f9f4ff 0, transparent 55%),
      radial-gradient(circle at 84% 86%, #f1e6ff 0, #c6d7e9 90%);
  }
  body[data-theme="light"][data-colour="sahara"] .chat-body {
    background:
      radial-gradient(circle at 18% 18%, #e0d0ff 0, transparent 48%),
      radial-gradient(circle at 82% 28%, #c6d7e9 0, transparent 55%),
      radial-gradient(circle at 50% 88%, #f9f4ff 0, #f9f4ff 100%);
  }
  body[data-theme="light"][data-colour="sahara"] .chat-bubble.customer {
    background: #4B2E4F;
    border-color: #A78BC3;
    color: #F9F4FF;
  }
  body[data-theme="light"][data-colour="sahara"] .chat-bubble.agent {
    background: #FFFFFF;
    border-color: #D9BB65;
    color: #2B2431;
  }
  body[data-theme="light"][data-colour="sahara"] .phone-frame {
    border-color: #A78BC3;
    box-shadow: 0 22px 52px rgba(167, 139, 195, 0.45);
  }

  /* Echo – Dark: Threaded Dusk */
  body[data-colour="sahara"][data-theme="dark"] {
    --primary-bg: #120F18;
    --primary-surface: #1B1622;
    --primary-text: #F9F4FF;

    --accent-plum:   #4B2E4F;
    --accent-lilac:  #C4A5E6;
    --accent-gold:   #D9BB65;

    --accent: var(--accent-lilac);
    --accent-soft: #C4A5E6;

    background:
      radial-gradient(circle at 16% 20%, #2B2431 0, transparent 55%),
      radial-gradient(circle at 80% 84%, #120F18 0, #020617 80%);
  }
  body[data-theme="dark"][data-colour="sahara"] .chat-body {
    background:
      radial-gradient(circle at 20% 18%, rgba(167, 139, 195, 0.38) 0, transparent 55%),
      radial-gradient(circle at 82% 26%, rgba(217, 187, 101, 0.32) 0, transparent 55%),
      radial-gradient(circle at 50% 90%, #020617 0, #000000 100%);
  }
  body[data-theme="dark"][data-colour="sahara"] .chat-bubble.customer {
    background: #A78BC3;
    border-color: #D9BB65;
    color: #2B2431;
  }
  body[data-theme="dark"][data-colour="sahara"] .chat-bubble.agent {
    background: #2B2431;
    border-color: #4B2E4F;
    color: #F9F4FF;
  }
  body[data-theme="dark"][data-colour="sahara"] .phone-frame {
    border-color: #D9BB65;
    box-shadow: 0 26px 60px rgba(217, 187, 101, 0.55);
  }

  /* Echo – Lunar: Loom of Echoes */
  body[data-colour="sahara"][data-theme="lunar"] {
    --primary-bg: #EDE6F6;
    --primary-surface: #F7F1FF;
    --primary-text: #2B2431;

    --accent-plum:   #4B2E4F;
    --accent-lilac:  #A78BC3;
    --accent-gold:   #D9BB65;

    --accent: var(--accent-gold);
    --accent-soft: #E0D0FF;

    background:
      radial-gradient(circle at 22% 24%, #f7f1ff 0, transparent 55%),
      radial-gradient(circle at 76% 88%, #ede6f6 0, #c6d7e9 95%);
  }
  body[data-theme="lunar"][data-colour="sahara"] .chat-body {
    background:
      radial-gradient(circle at 18% 18%, #E0D0FF 0, transparent 52%),
      radial-gradient(circle at 82% 26%, #D9BB65 0, transparent 55%),
      radial-gradient(circle at 50% 88%, #2B2431 0, #120F18 100%);
  }
  body[data-theme="lunar"][data-colour="sahara"] .chat-bubble.customer {
    background: #D9BB65;
    border-color: #A78BC3;
    color: #2B2431;
  }
  body[data-theme="lunar"][data-colour="sahara"] .chat-bubble.agent {
    background: #4B2E4F;
    border-color: #C4A5E6;
    color: #F9F4FF;
  }
  body[data-theme="lunar"][data-colour="sahara"] .phone-frame {
    border-color: #A78BC3;
    box-shadow: 0 24px 56px rgba(167, 139, 195, 0.55);
  }
.font-size-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
}
.bubble-add-group {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.bubble-add-btn {
  position: relative;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 26px;
  border-radius: 999px;
  border: none;
  cursor: pointer;
  padding: 0;
  background: rgba(0, 0, 0, 0.08);
  box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  transition: transform 0.18s ease-out, box-shadow 0.18s ease-out, background 0.18s ease-out;
}

body[data-theme="dark"] .bubble-add-btn {
  background: rgba(255, 255, 255, 0.05);
}

body[data-theme="lunar"] .bubble-add-btn {
  background: rgba(255, 255, 255, 0.08);
}

.bubble-add-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 10px rgba(0,0,0,0.25);
}

.bubble-add-btn:active {
  transform: translateY(0);
  box-shadow: 0 1px 3px rgba(0,0,0,0.18);
}

.bubble-add-dot {
  width: 14px;
  height: 14px;
  border-radius: 999px;
  background: rgba(255, 255, 255, 0.3);
  box-shadow: inset 0 0 0 1px rgba(0,0,0,0.15);
}

.bubble-add-plus {
  position: absolute;
  right: 8px;
  font-size: 14px;
  font-weight: 600;
  line-height: 1;
  color: rgba(0,0,0,0.7);
}

body[data-theme="dark"] .bubble-add-plus,
body[data-theme="lunar"] .bubble-add-plus {
  color: rgba(255,255,255,0.9);
}


body[data-cx-mode="on"] .mlcx-pills-row {
  display: none !important;
}


/* FULLSCREEN MLCX DASHBOARD LAYOUT */
body[data-layout="mlcx"] .app-main {
      height: 100%;
      min-height: 100%;
      display: flex;
      flex-direction: column;
    }

body[data-layout="mlcx"] .app-card {
      height: calc(100vh - 40px);
      display: flex;
      flex-direction: column;
    }

body[data-layout="mlcx"] .mlcx-panel {
      display: flex;
    }

.mlcx-layout {
      flex: 1 1 auto;
      height: 100%;
      min-height: 100%;
      display: grid;
      grid-template-columns: 2fr 1.2fr;
      gap: 24px;
    }

.mlcx-notes-column {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

.mlcx-notes-textarea {
      flex: 1 1 auto;
      min-height: 60vh;
      height: 100%;
      resize: vertical;
    }

.mlcx-train-column {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }

.mlcx-training-panel {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow: auto;
    }

</style>


  <!-- Phase 3: mesh tint per colourway -->
  <style>
    body[data-colour="classic"] .mesh-bg { filter: hue-rotate(45deg); opacity: 0.9; }
    body[data-colour="teal"] .mesh-bg { filter: hue-rotate(120deg); opacity: 0.9; }
    body[data-colour="sahara"] .mesh-bg { filter: hue-rotate(270deg); opacity: 0.9; }
    body[data-colour="sunburst"] .mesh-bg { filter: hue-rotate(15deg); opacity: 0.92; }
    body[data-colour="crown"] .mesh-bg { filter: hue-rotate(-15deg); opacity: 0.92; }
    body[data-colour="aurora"] .mesh-bg { filter: hue-rotate(200deg); opacity: 0.9; }
  .font-size-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
}
.bubble-add-group {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.bubble-add-btn {
  position: relative;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 26px;
  border-radius: 999px;
  border: none;
  cursor: pointer;
  padding: 0;
  background: rgba(0, 0, 0, 0.08);
  box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  transition: transform 0.18s ease-out, box-shadow 0.18s ease-out, background 0.18s ease-out;
}

body[data-theme="dark"] .bubble-add-btn {
  background: rgba(255, 255, 255, 0.05);
}

body[data-theme="lunar"] .bubble-add-btn {
  background: rgba(255, 255, 255, 0.08);
}

.bubble-add-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 10px rgba(0,0,0,0.25);
}

.bubble-add-btn:active {
  transform: translateY(0);
  box-shadow: 0 1px 3px rgba(0,0,0,0.18);
}

.bubble-add-dot {
  width: 14px;
  height: 14px;
  border-radius: 999px;
  background: rgba(255, 255, 255, 0.3);
  box-shadow: inset 0 0 0 1px rgba(0,0,0,0.15);
}

.bubble-add-plus {
  position: absolute;
  right: 8px;
  font-size: 14px;
  font-weight: 600;
  line-height: 1;
  color: rgba(0,0,0,0.7);
}

body[data-theme="dark"] .bubble-add-plus,
body[data-theme="lunar"] .bubble-add-plus {
  color: rgba(255,255,255,0.9);
}


body[data-cx-mode="on"] .mlcx-pills-row {
  display: none !important;
}


/* FULLSCREEN MLCX DASHBOARD LAYOUT */
body[data-layout="mlcx"] .app-main {
      height: 100%;
      min-height: 100%;
      display: flex;
      flex-direction: column;
    }

body[data-layout="mlcx"] .app-card {
      height: calc(100vh - 40px);
      display: flex;
      flex-direction: column;
    }

body[data-layout="mlcx"] .mlcx-panel {
      display: flex;
    }

.mlcx-layout {
      flex: 1 1 auto;
      height: 100%;
      min-height: 100%;
      display: grid;
      grid-template-columns: 2fr 1.2fr;
      gap: 24px;
    }

.mlcx-notes-column {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

.mlcx-notes-textarea {
      flex: 1 1 auto;
      min-height: 60vh;
      height: 100%;
      resize: vertical;
    }

.mlcx-train-column {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }

.mlcx-training-panel {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow: auto;
    }

</style>


<style>
/* === CV Overlay Toggle Button === */
.cv-toggle-btn {
  position: fixed;
  right: 18px;
  bottom: 18px;
  z-index: 60;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  border-radius: 999px;
  border: 1px solid rgba(148, 163, 184, 0.9);
  background: radial-gradient(circle at top, rgba(15,23,42,0.98), rgba(15,23,42,0.92));
  color: #e5f3ff;
  font-size: 0.78rem;
  letter-spacing: 0.04em;
  text-transform: uppercase;
  cursor: pointer;
  box-shadow: 0 8px 24px rgba(15,23,42,0.6);
  backdrop-filter: blur(10px);
  transition: transform 0.14s ease-out, box-shadow 0.16s ease-out, border-color 0.16s ease-out, background 0.16s ease-out;
}
.cv-toggle-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 12px 28px rgba(15,23,42,0.85);
  border-color: rgba(96, 165, 250, 0.9);
}
.cv-toggle-btn:active {
  transform: translateY(0);
  box-shadow: 0 6px 18px rgba(15,23,42,0.8);
}
.cv-toggle-icon {
  font-size: 0.95rem;
}
.cv-toggle-text {
  font-weight: 600;
  font-size: 0.72rem;
}

/* Hide CV toggle in notepad-only layouts if body uses data-layout */
body[data-layout="notepad"] .cv-toggle-btn {
  display: none;
}

/* === CV Overlay Container === */
.cv-overlay {
  position: fixed;
  inset: 0;
  z-index: 55;
  display: none;
  pointer-events: none;
}
.cv-overlay.is-visible {
  display: block;
  pointer-events: auto;
}

/* Backdrop blur */
.cv-overlay-backdrop {
  position: absolute;
  inset: 0;
  background: radial-gradient(circle at top, rgba(15,23,42,0.92), rgba(15,23,42,0.98));
  opacity: 0;
  transition: opacity 160ms ease-out;
  backdrop-filter: blur(18px);
}
.cv-overlay.is-visible .cv-overlay-backdrop {
  opacity: 1;
}

/* Right-hand Apple-style sheet */
.cv-sheet {
  position: absolute;
  top: 0;
  right: 0;
  height: 100%;
  max-width: 440px;
  width: min(92vw, 440px);
  background:
    linear-gradient(145deg, rgba(15,23,42,0.94), rgba(30,64,175,0.94)),
    radial-gradient(circle at top, rgba(96,165,250,0.25), transparent 60%);
  border-left: 1px solid rgba(148,163,184,0.7);
  box-shadow:
    -18px 0 40px rgba(15,23,42,0.9),
    0 0 0 1px rgba(15,23,42,0.8);
  display: flex;
  flex-direction: column;
  padding: 14px 18px;
  transform-origin: 100% 50%;
  transform: translateX(16px) scaleX(0.96);
  opacity: 0;
  transition:
    transform 160ms cubic-bezier(0.16, 0.9, 0.3, 1),
    opacity 160ms ease-out;
}
.cv-overlay.is-visible .cv-sheet {
  transform: translateX(0) scaleX(1);
  opacity: 1;
}

/* Sheet header */
.cv-sheet-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  padding-bottom: 8px;
  border-bottom: 1px solid rgba(148,163,184,0.4);
}
.cv-sheet-titles {
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.cv-sheet-title {
  margin: 0;
  font-size: 0.95rem;
  font-weight: 600;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  color: #e5f3ff;
}
.cv-sheet-subtitle {
  margin: 0;
  font-size: 0.78rem;
  color: rgba(191, 219, 254, 0.9);
}
.cv-sheet-close {
  border-radius: 999px;
  border: 1px solid rgba(148,163,184,0.7);
  background: radial-gradient(circle at top, rgba(15,23,42,0.98), rgba(15,23,42,0.9));
  color: #e5f3ff;
  width: 26px;
  height: 26px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 0.8rem;
  box-shadow: 0 6px 18px rgba(15,23,42,0.9);
  transition: background 140ms ease-out, box-shadow 140ms ease-out, transform 120ms ease-out;
}
.cv-sheet-close:hover {
  box-shadow: 0 10px 24px rgba(15,23,42,0.95);
  transform: translateY(-1px);
}
.cv-sheet-close:active {
  transform: translateY(0);
}

/* Body */
.cv-sheet-body {
  margin-top: 8px;
  padding-top: 4px;
  overflow-y: auto;
  scrollbar-width: thin;
}
.cv-sheet-body::-webkit-scrollbar {
  width: 6px;
}
.cv-sheet-body::-webkit-scrollbar-track {
  background: rgba(15,23,42,0.6);
}
.cv-sheet-body::-webkit-scrollbar-thumb {
  background: rgba(148,163,184,0.9);
  border-radius: 999px;
}

/* Sections */
.cv-sheet-section {
  margin-bottom: 12px;
  padding: 8px 8px 10px;
  border-radius: 10px;
  background: radial-gradient(circle at top left, rgba(56,189,248,0.08), transparent 60%);
  border: 1px solid rgba(148,163,184,0.45);
}
.cv-section-title {
  margin: 0 0 4px;
  font-size: 0.8rem;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: rgba(191, 219, 254, 0.95);
}
.cv-section-text {
  margin: 0;
  font-size: 0.78rem;
  color: rgba(226,232,240,0.95);
}
.cv-section-placeholder {
  font-size: 0.76rem;
  color: rgba(148,163,184,0.9);
}

body[data-cx-mode="on"] .mlcx-pills-row {
  display: none !important;
}


/* FULLSCREEN MLCX DASHBOARD LAYOUT */
body[data-layout="mlcx"] .app-main {
      height: 100%;
      min-height: 100%;
      display: flex;
      flex-direction: column;
    }

body[data-layout="mlcx"] .app-card {
      height: calc(100vh - 40px);
      display: flex;
      flex-direction: column;
    }

body[data-layout="mlcx"] .mlcx-panel {
      display: flex;
    }

.mlcx-layout {
      flex: 1 1 auto;
      height: 100%;
      min-height: 100%;
      display: grid;
      grid-template-columns: 2fr 1.2fr;
      gap: 24px;
    }

.mlcx-notes-column {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

.mlcx-notes-textarea {
      flex: 1 1 auto;
      min-height: 60vh;
      height: 100%;
      resize: vertical;
    }

.mlcx-train-column {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }

.mlcx-training-panel {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow: auto;
    }

</style>


<style>
/* === Phase 19.7: Dev Lab Library Editor Layout === */
.devlab-toggle-row { display: flex; gap: 10px; margin-bottom: 20px; }
.devlab-toggle-row.is-flag-hidden { display: none !important; }
.devlab-toggle-btn.is-flag-hidden { display: none !important; }

.devlab-toggle-btn { flex: 1 1 0; padding: 10px 16px; border-radius: 8px; border: 1px solid rgba(148, 163, 184, 0.4); background: rgba(255, 255, 255, 0.5); color: #475569; font-size: 0.88em; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; cursor: pointer; transition: all 0.2s; }
.devlab-toggle-btn:hover { background: rgba(255, 255, 255, 0.8); border-color: rgba(148, 163, 184, 0.6); }
.devlab-toggle-btn.is-active { background: rgba(59, 130, 246, 0.15); border-color: rgba(59, 130, 246, 0.6); color: #1e40af; font-weight: 600; box-shadow: 0 2px 8px rgba(59, 130, 246, 0.2); }

/* TEMP: Hide Dictionaries toggle button – UI only, all logic remains intact.
   Re-enable by removing this rule. */
.devlab-toggle-btn[data-view="dict"] { display: none !important; }

.devlab-editor-container {
  display: flex;
  flex-direction: row;
  gap: 20px;
  height: 100%;
}
.devlab-card {
  background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.08), rgba(255, 255, 255, 0.6) 60%);
  border-radius: 14px;
  box-shadow: 0 2px 8px 0 rgba(15,23,42,0.12);
  border: 1px solid rgba(148,163,184,0.4);
  padding: 20px 18px 18px 18px;
  display: flex;
  flex-direction: column;
  min-width: 0;
  min-height: 0;
  flex: 1 1 0;
  overflow: auto;
  scrollbar-width: thin;
}

.devlab-card h3 {
  color: #0f172a;
  font-size: 0.88rem;
  font-weight: 600;
  margin: 0 0 14px 0;
  letter-spacing: 0.05em;
  text-transform: uppercase;
}
.devlab-editor-left { flex: 0 0 210px; max-width: 220px; }
.devlab-editor-middle { flex: 1 1 0; min-width: 0; }
.devlab-editor-right { flex: 1 1 0; min-width: 0; }

/* Library Editor layout controls */
.lib-search { width: 100%; margin-bottom: 14px; padding: 7px 10px; border-radius: 8px; border: 1px solid rgba(148, 163, 184, 0.5); background: rgba(255, 255, 255, 0.8); color: #0f172a; font-size: 0.95em; }
.lib-filter-label { display: block; margin-top: 10px; margin-bottom: 4px; font-size: 0.85em; color: #4b5563; }
.lib-group-filter { width: 100%; padding: 7px 10px; border-radius: 8px; border: 1px solid rgba(148, 163, 184, 0.5); background: rgba(255, 255, 255, 0.8); color: #0f172a; font-size: 0.95em; margin-bottom: 12px; }
.lib-status-toggle { display: flex; gap: 8px; margin-top: 10px; }
.lib-status-button { flex: 1 1 0; padding: 7px 0; border-radius: 8px; border: 1px solid rgba(148, 163, 184, 0.5); background: rgba(255, 255, 255, 0.6); color: #1e293b; font-size: 0.93em; cursor: pointer; opacity: 0.8; transition: all 0.2s; }
.lib-status-button:hover { opacity: 0.9; }
.lib-status-active { background: #0ea5e9; color: #fff; border-color: #0ea5e9; opacity: 1 !important; }

.lib-add-new { margin: 0 0 12px 0; padding: 8px 0; width: 100%; border-radius: 8px; border: 1px solid rgba(148, 163, 184, 0.5); background: rgba(59, 130, 246, 0.1); color: #1e293b; font-size: 0.97em; cursor: pointer; opacity: 0.9; transition: all 0.2s; font-weight: 500; }
.lib-add-new:hover { opacity: 1; background: rgba(59, 130, 246, 0.2); box-shadow: 0 2px 6px rgba(59, 130, 246, 0.2); }
.lib-template-list { min-height: 80px; margin-bottom: 16px; max-height: 500px; overflow-y: auto; }
.lib-empty-state { color: #6b7280; font-size: 0.95em; text-align: center; margin: 30px 0; }

/* Template list items */
.lib-template-item { display: flex; gap: 10px; padding: 10px; margin-bottom: 6px; border-radius: 8px; background: rgba(255, 255, 255, 0.5); border: 1px solid rgba(148, 163, 184, 0.3); cursor: pointer; transition: all 0.2s; }
.lib-template-item:hover { background: rgba(255, 255, 255, 0.8); border-color: rgba(148, 163, 184, 0.5); box-shadow: 0 2px 6px rgba(15, 23, 42, 0.1); }
.lib-template-item.is-selected { background: rgba(59, 130, 246, 0.12); border-left: 3px solid rgba(59, 130, 246, 0.8); border-color: rgba(59, 130, 246, 0.4); box-shadow: 0 2px 8px rgba(59, 130, 246, 0.15); padding-left: 8px; }
.lib-template-checkbox { margin: 0; cursor: pointer; }
.lib-template-content { flex: 1 1 0; min-width: 0; }
.lib-template-text { font-size: 0.95em; color: #0f172a; margin-bottom: 4px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-weight: 500; }
.lib-template-meta { font-size: 0.82em; color: #4b5563; }

.lib-bulk-actions { display: flex; gap: 8px; margin-top: 10px; }
.bulk-delete, .bulk-archive, .bulk-restore, .bulk-duplicate { flex: 1 1 0; padding: 7px 0; border-radius: 8px; border: 1px solid rgba(148, 163, 184, 0.5); background: rgba(59, 130, 246, 0.1); color: #1e293b; font-size: 0.93em; cursor: pointer; opacity: 0.9; transition: all 0.2s; font-weight: 500; }
.bulk-delete:not(:disabled):hover, .bulk-archive:not(:disabled):hover, .bulk-restore:not(:disabled):hover, .bulk-duplicate:not(:disabled):hover { opacity: 1; background: rgba(59, 130, 246, 0.2); box-shadow: 0 2px 6px rgba(59, 130, 246, 0.2); }
.bulk-delete:disabled, .bulk-archive:disabled, .bulk-restore:disabled, .bulk-duplicate:disabled { cursor: not-allowed; opacity: 0.3; background: rgba(203, 213, 225, 0.3); color: #94a3b8; }

.editor-buttons { display: flex; gap: 8px; margin-top: 12px; }
.editor-buttons button { flex: 1 1 0; padding: 8px 0; border-radius: 8px; border: 1px solid rgba(148, 163, 184, 0.5); background: rgba(59, 130, 246, 0.1); color: #1e293b; font-size: 0.93em; cursor: pointer; opacity: 0.9; transition: all 0.2s; font-weight: 500; }
.editor-buttons button:hover:not(:disabled) { opacity: 1; background: rgba(59, 130, 246, 0.2); box-shadow: 0 2px 6px rgba(59, 130, 246, 0.2); }
.editor-buttons button:disabled { cursor: not-allowed; opacity: 0.3; background: rgba(203, 213, 225, 0.3); color: #94a3b8; }
.editor-toggle-row { display: flex; align-items: center; gap: 8px; margin: 12px 0; }
.editor-toggle-row label { font-size: 0.9em; color: #0f172a; font-weight: 500; }
.editor-toggle-row input { cursor: pointer; }
.editor-toggle-row input:disabled { cursor: not-allowed; opacity: 0.4; }

#editor-text, #editor-group {
  background: rgba(255, 255, 255, 0.8);
  border: 1px solid rgba(148, 163, 184, 0.5);
  border-radius: 8px;
  padding: 8px 10px;
  color: #0f172a;
  font-size: 0.95em;
  font-family: inherit;
}

#editor-text {
  min-height: 120px;
  resize: vertical;
}

.editor-preview-box, .editor-mini-analysis { margin-top: 18px; background: rgba(255, 255, 255, 0.6); border-radius: 8px; padding: 12px 14px; border: 1px solid rgba(148, 163, 184, 0.3); }
.editor-preview-box h4, .editor-mini-analysis h4 { font-size: 0.92em; margin-bottom: 6px; color: #0f172a; font-weight: 600; letter-spacing: 0.05em; }

.editor-preview-box .preview-placeholder, .mini-analysis-content { color: #4b5563; font-size: 0.95em; }
.editor-preview-box p { color: #1e293b; margin: 0; }
.mini-analysis-toggle {
  display: inline-flex;
  align-items: center;
  padding: 3px 8px;
  border-radius: 999px;
  border: 1px dashed rgba(148, 163, 184, 0.7);
  background: transparent;
  color: rgba(148, 163, 184, 0.9);
  font-size: 0.7rem;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  cursor: default;
  margin-bottom: 6px;
}
.mini-analysis-toggle {
  display: inline-flex;
  align-items: center;
  padding: 3px 8px;
  border-radius: 999px;
  border: 1px dashed rgba(148, 163, 184, 0.7);
  background: transparent;
  color: rgba(148, 163, 184, 0.9);
  font-size: 0.7rem;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  cursor: default;
  margin-bottom: 6px;
}
.mini-analysis-toggle {
  display: inline-flex;
  align-items: center;
  padding: 3px 8px;
  border-radius: 999px;
  border: 1px dashed rgba(148, 163, 184, 0.7);
  background: transparent;
  color: rgba(148, 163, 184, 0.9);
  font-size: 0.7rem;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  cursor: default;
  margin-bottom: 6px;
}
.mini-analysis-toggle {
  display: inline-flex;
  align-items: center;
  padding: 3px 8px;
  border-radius: 999px;
  border: 1px dashed rgba(148, 163, 184, 0.7);
  background: transparent;
  color: rgba(148, 163, 184, 0.9);
  font-size: 0.7rem;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  cursor: default;
  margin-bottom: 6px;
}
.mini-analysis-toggle {
  display: inline-flex;
  align-items: center;
  padding: 3px 8px;
  border-radius: 999px;
  border: 1px dashed rgba(148, 163, 184, 0.7);
  background: transparent;
  color: rgba(148, 163, 184, 0.9);
  font-size: 0.7rem;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  cursor: default;
  margin-bottom: 6px;
}
.mini-analysis-toggle {
  display: inline-flex;
  align-items: center;
  padding: 3px 8px;
  border-radius: 999px;
  border: 1px dashed rgba(148, 163, 184, 0.7);
  background: transparent;
  color: rgba(148, 163, 184, 0.9);
  font-size: 0.7rem;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  cursor: default;
  margin-bottom: 6px;
}
.mini-analysis-toggle {
  display: inline-flex;
  align-items: center;
  padding: 3px 8px;
  border-radius: 999px;
  border: 1px dashed rgba(148, 163, 184, 0.7);
  background: transparent;
  color: rgba(148, 163, 184, 0.9);
  font-size: 0.7rem;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  cursor: default;
  margin-bottom: 6px;
}

/* Phase 19.12b: Demo Scenarios scroll container */
#devDemoBlocks {
  max-height: 360px;
  overflow-y: auto;
  padding-right: 4px;
  margin-top: 6px;
}

/* Phase 19.12b: Library type toggle */
.lib-library-toggle {
  display: flex;
  gap: 8px;
  margin-top: 6px;
  margin-bottom: 8px;
}

.lib-library-button {
  flex: 1 1 0;
  padding: 7px 0;
  border-radius: 999px;
  border: 1px solid rgba(148, 163, 184, 0.6);
  background: rgba(15, 23, 42, 0.85);
  color: rgba(249, 250, 251, 0.9);
  font-size: 0.93em;
  cursor: pointer;
  opacity: 0.85;
  transition: all 0.2s;
}

.lib-library-button:hover {
  opacity: 1;
}

.lib-library-button.lib-status-active {
  background: #0ea5e9;
  color: #fff;
  border-color: #0ea5e9;
  opacity: 1 !important;
}

/* Phase 19.12b: Mini analysis phrase toggle affordance */
.mini-analysis {
  margin-top: 18px;
}

.mini-analysis h4 {
  margin: 0 0 6px 0;
}

.mini-analysis-toggle {
  display: inline-flex;
  align-items: center;
  padding: 3px 8px;
  border-radius: 999px;
  border: 1px dashed rgba(148, 163, 184, 0.7);
  background: transparent;
  color: rgba(148, 163, 184, 0.9);
  font-size: 0.7rem;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  cursor: default;
  margin-bottom: 6px;
}

/* === Phase 16: MirrorFlow CX Notch + Sliding Drawer === */

/* Global overlay wrapper for drawer + dim */
.cx-drawer-overlay {
  position: fixed;
  inset: 0;
  z-index: 58;
  pointer-events: none;
}

.cx-drawer-overlay.is-open {
  pointer-events: auto;
}

/* Soft dim behind drawer */
.cx-dim {
  position: absolute;
  inset: 0;
  background: radial-gradient(circle at top, rgba(15,23,42,0.78), rgba(15,23,42,0.94));
  opacity: 0;
  transition: opacity 220ms ease-out;
}

.cx-drawer-overlay.is-open .cx-dim {
  opacity: 1;
}

/* Right-hand sliding drawer */
.cx-drawer {
  position: absolute;
  top: 0;
  right: -400px; /* hidden by default */
  width: 400px;
  max-width: 92vw;
  height: 100%;
  display: flex;
  flex-direction: column;
  padding: 14px 16px 16px;
  background:
    linear-gradient(135deg, rgba(15,23,42,0.96), rgba(15,23,42,0.88)),
    radial-gradient(circle at top, rgba(148,163,184,0.3), transparent 60%);
  border-left: 1px solid rgba(148,163,184,0.8);
  box-shadow:
    -14px 0 40px rgba(0,0,0,0.85),
    0 0 0 1px rgba(15,23,42,0.98);
  backdrop-filter: blur(22px);
  color: var(--text-main);
  transform: translateX(0);
  transition:
    right 260ms cubic-bezier(0.32, 0.12, 0.24, 1),
    box-shadow 220ms ease-out;
}

/* Colourway-reactive glow */
body[data-colour] .cx-drawer {
  box-shadow:
    -14px 0 40px rgba(0,0,0,0.9),
    0 0 0 1px rgba(15,23,42,0.98),
    0 0 36px 0 var(--scrollbar-thumb);
}

/* Open state */
.cx-drawer-overlay.is-open .cx-drawer {
  right: 0;
}

/* Drawer header */
.cx-drawer-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  margin-bottom: 8px;
}

.cx-drawer-title-block {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.cx-drawer-title {
  margin: 0;
  font-size: 0.86rem;
  font-weight: 600;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: rgba(226,232,240,0.96);
}

.cx-drawer-subtitle {
  margin: 0;
  font-size: 0.76rem;
  color: rgba(191,219,254,0.92);
}

/* Close button */
.cx-drawer-close-btn {
  border-radius: 999px;
  border: 1px solid rgba(148,163,184,0.85);
  background: radial-gradient(circle at top, rgba(15,23,42,0.98), rgba(15,23,42,0.9));
  color: #e5f3ff;
  width: 26px;
  height: 26px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 0.8rem;
  box-shadow: 0 8px 22px rgba(15,23,42,0.96);
  transition:
    transform 140ms ease-out,
    box-shadow 160ms ease-out,
    border-color 160ms ease-out;
}

.cx-drawer-close-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 12px 26px rgba(15,23,42,0.98);
  border-color: var(--focus-ring);
}

.cx-drawer-close-btn:active {
  transform: translateY(0);
}

/* Drawer body */
.cx-drawer-body {
  flex: 1 1 auto;
  overflow-y: auto;
  padding-top: 4px;
  scrollbar-width: thin;
}

.cx-drawer-body::-webkit-scrollbar {
  width: 6px;
}
.cx-drawer-body::-webkit-scrollbar-track {
  background: rgba(15,23,42,0.5);
}
.cx-drawer-body::-webkit-scrollbar-thumb {
  background: rgba(148,163,184,0.98);
  border-radius: 999px;
}

/* Section cards inside drawer */
.cx-drawer-section {
  margin-bottom: 10px;
  padding: 8px 9px 9px;
  border-radius: 12px;
  border: 1px solid rgba(148,163,184,0.5);
  background: radial-gradient(circle at top left, rgba(56,189,248,0.08), transparent 60%);
}

/* Light mode: keep CX drawer in "lunar" styling for consistent visibility */
body[data-theme="light"] .cx-drawer {
  background:
    linear-gradient(135deg, rgba(15,23,42,0.96), rgba(15,23,42,0.88)),
    radial-gradient(circle at top, rgba(148,163,184,0.3), transparent 60%);
  border-left: 1px solid rgba(148,163,184,0.8);
}

body[data-theme="light"] .cx-drawer-section {
  background: radial-gradient(circle at top left, rgba(56,189,248,0.06), transparent 60%);
  border: 1px solid rgba(148,163,184,0.4);
}

body[data-theme="light"] .cx-drawer-body::-webkit-scrollbar-track {
  background: rgba(15,23,42,0.5);
}

/* Lunar mode: softer section cards */
body[data-theme="lunar"] .cx-drawer-section {
  background: radial-gradient(circle at top left, rgba(56,189,248,0.06), transparent 60%);
  border: 1px solid rgba(148,163,184,0.4);
}

.cx-drawer-section-title {
  margin: 0 0 4px;
  font-size: 0.78rem;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: rgba(191,219,254,0.96);
}

/* Light mode: keep CX drawer titles in lunar styling for consistent visibility */
body[data-theme="light"] .cx-drawer-section-title {
  color: rgba(226, 232, 240, 0.95);
  font-weight: 600;
}

/* Lunar mode: bright visible titles */
body[data-theme="lunar"] .cx-drawer-section-title {
  color: rgba(226, 232, 240, 0.95);
  font-weight: 600;
}

/* MLCX Snapshot styling */
.mlcx-snapshot-severity {
  display: inline-block;
  padding: 4px 12px;
  border-radius: 999px;
  font-size: 0.72rem;
  font-weight: 600;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  margin-bottom: 8px;
}
.mlcx-severity-low {
  background: rgba(34,197,94,0.2);
  color: rgba(134,239,172,0.98);
  border: 1px solid rgba(34,197,94,0.4);
}
.mlcx-severity-medium {
  background: rgba(251,146,60,0.2);
  color: rgba(253,186,116,0.98);
  border: 1px solid rgba(251,146,60,0.4);
}
.mlcx-severity-high {
  background: rgba(239,68,68,0.2);
  color: rgba(252,165,165,0.98);
  border: 1px solid rgba(239,68,68,0.4);
}

.mlcx-snapshot-counts {
  font-size: 0.74rem;
  color: rgba(203,213,225,0.92);
  line-height: 1.5;
}

/* Light/Lunar mode visibility */
body[data-theme="light"] .mlcx-snapshot-counts,
body[data-theme="lunar"] .mlcx-snapshot-counts {
  color: rgba(148,163,184,0.95);
}

.cx-drawer-section-empty {
  font-size: 0.76rem;
  color: rgba(148,163,184,0.94);
}

/* Light mode: keep CX drawer empty text in lunar styling for consistent visibility */
body[data-theme="light"] .cx-drawer-section-empty {
  color: rgba(148,163,184,0.94);
}

/* MLCX Alpha – vulnerability summary wiring (non-destructive patch) */
.mlcx-vuln-line {
  font-size: 0.76rem;
  line-height: 1.5;
  color: rgba(226,232,240,0.96);
}

/* Light mode: keep CX drawer content in lunar styling for consistent visibility */
body[data-theme="light"] .mlcx-vuln-line,
body[data-theme="light"] .mlcx-highrisk-list li,
body[data-theme="light"] .cx-drawer-section-content {
  color: #e2e8f0;
}

/* Lunar mode: ensure bright readable text */
body[data-theme="lunar"] .mlcx-vuln-line,
body[data-theme="lunar"] .mlcx-highrisk-list li,
body[data-theme="lunar"] .cx-drawer-section-content {
  color: #e2e8f0;
}

/* MirrorFlow CX Notch */
.cx-notch {
  position: fixed;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  z-index: 59;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 6px 10px;
  min-width: 44px;
  border-radius: 14px 4px 4px 14px; /* asymmetric MirrorFlow shard */
  background:
    linear-gradient(135deg, rgba(15,23,42,0.96), rgba(15,23,42,0.86)),
    radial-gradient(circle at top left, rgba(148,163,184,0.3), transparent 60%);
  border: 1px solid rgba(148,163,184,0.85);
  box-shadow:
    0 0 0 1px rgba(15,23,42,0.95),
    0 10px 26px rgba(0,0,0,0.9);
  backdrop-filter: blur(18px);
  color: #e5f3ff;
  cursor: pointer;
  font-size: 0.75rem;
  letter-spacing: 0.14em;
  text-transform: uppercase;
  overflow: hidden;
  transition:
    transform 160ms ease-out,
    box-shadow 180ms ease-out,
    border-color 160ms ease-out,
    background 180ms ease-out;
}

/* MirrorFlow geometric angle accent */
.cx-notch::before {
  content: "";
  position: absolute;
  inset: -30%;
  background:
    linear-gradient(120deg, rgba(148,163,184,0.3), transparent 40%),
    linear-gradient(300deg, rgba(56,189,248,0.4), transparent 55%);
  opacity: 0.4;
  mix-blend-mode: soft-light;
  pointer-events: none;
}

/* Inner label */
.cx-notch-label {
  position: relative;
  z-index: 1;
  display: inline-flex;
  align-items: center;
  gap: 4px;
}

.cx-notch-main {
  font-weight: 600;
}

.cx-notch-echo {
  font-size: 0.7rem;
  opacity: 0.9;
}

/* Hover / active */
.cx-notch:hover {
  transform: translateY(-50%) translateX(-2px);
  box-shadow:
    0 0 0 1px rgba(15,23,42,1),
    0 14px 30px rgba(0,0,0,0.95),
    0 0 18px 0 var(--scrollbar-thumb);
  border-color: var(--focus-ring);
}

.cx-notch:active {
  transform: translateY(-50%) translateX(0);
}

/* CX active state glow */
.cx-notch.is-hot {
  animation: mfCxGlow 1900ms ease-in-out infinite;
}

@keyframes mfCxGlow {
  0% {
    box-shadow:
      0 0 0 1px rgba(15,23,42,0.98),
      0 10px 26px rgba(0,0,0,0.9),
      0 0 10px 0 rgba(56,189,248,0.0);
  }
  50% {
    box-shadow:
      0 0 0 1px rgba(15,23,42,0.98),
      0 14px 32px rgba(0,0,0,0.95),
      0 0 24px 0 var(--scrollbar-thumb);
  }
  100% {
    box-shadow:
      0 0 0 1px rgba(15,23,42,0.98),
      0 10px 26px rgba(0,0,0,0.9),
      0 0 10px 0 rgba(56,189,248,0.0);
  }
}

.cx-notch.cx-notch-pulse {
  animation: notchPulse 2.4s ease-in-out infinite;
}

@keyframes notchPulse {
  0% {
    box-shadow:
      0 0 0 1px rgba(15, 23, 42, 0.95),
      0 10px 24px rgba(0, 0, 0, 0.85),
      0 0 0 rgba(56, 189, 248, 0);
    opacity: 0.85;
  }
  50% {
    box-shadow:
      0 0 0 2px rgba(56, 189, 248, 0.75),
      0 18px 36px rgba(0, 0, 0, 0.9),
      0 0 22px rgba(56, 189, 248, 0.45);
    opacity: 1;
  }
  100% {
    box-shadow:
      0 0 0 1px rgba(15, 23, 42, 0.95),
      0 10px 24px rgba(0, 0, 0, 0.85),
      0 0 0 rgba(56, 189, 248, 0);
    opacity: 0.85;
  }
}

/* Notepad/Messenger Insights notch pulse */
.np-notch.cx-notch-pulse,
.ms-notch.cx-notch-pulse {
  animation: notchPulse 2.4s ease-in-out infinite;
}

/* Show CX notch and drawer on all panels by default */
.cx-notch,
.cx-drawer-overlay {
  display: block !important;
}

/* CX notch visibility tweaks for dev lab only */
body[data-layout="dev"] .cx-notch,
body[data-layout="dev"] .cx-drawer-overlay {
  display: none !important;
}

/* CV Notch for Call Notes Panel */
.cv-notch-callnotes {
  position: fixed;
  right: 10px;
  top: calc(50% + 80px);
  transform: translateY(-50%);
  z-index: 59;
  display: none;
  align-items: center;
  justify-content: center;
  padding: 6px 10px;
  min-width: 44px;
  border-radius: 14px 4px 4px 14px;
  background:
    linear-gradient(135deg, rgba(15,23,42,0.96), rgba(15,23,42,0.86)),
    radial-gradient(circle at top left, rgba(251,146,60,0.3), transparent 60%);
  border: 1px solid rgba(251,146,60,0.85);
  box-shadow:
    0 0 0 1px rgba(15,23,42,0.95),
    0 10px 26px rgba(0,0,0,0.9),
    0 0 20px rgba(251,146,60,0.3);
  backdrop-filter: blur(18px);
  color: #ffe5cc;
  cursor: pointer;
  font-size: 0.75rem;
  letter-spacing: 0.14em;
  text-transform: uppercase;
  overflow: hidden;
  transition:
    transform 160ms ease-out,
    box-shadow 180ms ease-out,
    border-color 160ms ease-out,
    background 180ms ease-out;
}

.cv-notch-callnotes::before {
  content: "";
  position: absolute;
  inset: -30%;
  background:
    linear-gradient(120deg, rgba(251,146,60,0.3), transparent 40%),
    linear-gradient(300deg, rgba(251,146,60,0.4), transparent 55%);
  opacity: 0.4;
  mix-blend-mode: soft-light;
  pointer-events: none;
}

.cv-notch-callnotes-label {
  position: relative;
  z-index: 1;
  display: inline-flex;
  align-items: center;
  gap: 4px;
}

.cv-notch-callnotes-main {
  font-weight: 600;
}

.cv-notch-callnotes-echo {
  font-size: 0.85em;
  opacity: 0.7;
}

.cv-notch-callnotes:hover {
  transform: translateY(-50%) scale(1.04);
  border-color: rgba(251,146,60,0.95);
  box-shadow:
    0 0 0 1px rgba(15,23,42,0.98),
    0 12px 30px rgba(0,0,0,0.95),
    0 0 30px rgba(251,146,60,0.5);
}

.cv-notch-callnotes:active {
  transform: translateY(-50%) scale(0.96);
}

.cv-notch-callnotes.is-hot {
  animation: cv-pulse-callnotes 2.4s ease-in-out infinite;
  border-color: rgba(239,68,68,0.9);
  box-shadow:
    0 0 0 1px rgba(15,23,42,0.98),
    0 10px 26px rgba(0,0,0,0.9),
    0 0 30px rgba(239,68,68,0.6);
}

@keyframes cv-pulse-callnotes {
  0%, 100% {
    box-shadow:
      0 0 0 1px rgba(15,23,42,0.98),
      0 10px 26px rgba(0,0,0,0.9),
      0 0 30px rgba(239,68,68,0.6);
  }
  50% {
    box-shadow:
      0 0 0 1px rgba(15,23,42,0.98),
      0 10px 26px rgba(0,0,0,0.9),
      0 0 50px rgba(239,68,68,0.85);
  }
}

/* Show CV notch on Call Notes layout */
body[data-layout="callnotes"] .cv-notch-callnotes {
  display: inline-flex;
}

/* CX Notch for Call Notes Panel */
.cx-notch-callnotes {
  position: fixed;
  right: 10px;
  top: calc(50% - 40px);
  transform: translateY(-50%);
  z-index: 59;
  display: none;
  align-items: center;
  justify-content: center;
  padding: 6px 10px;
  min-width: 44px;
  border-radius: 14px 4px 4px 14px;
  background:
    linear-gradient(135deg, rgba(15,23,42,0.96), rgba(15,23,42,0.86)),
    radial-gradient(circle at top left, rgba(148,163,184,0.3), transparent 60%);
  border: 1px solid rgba(148,163,184,0.85);
  box-shadow:
    0 0 0 1px rgba(15,23,42,0.95),
    0 10px 26px rgba(0,0,0,0.9);
  backdrop-filter: blur(18px);
  color: #e5f3ff;
  cursor: pointer;
  font-size: 0.75rem;
  letter-spacing: 0.14em;
  text-transform: uppercase;
  overflow: hidden;
  transition:
    transform 160ms ease-out,
    box-shadow 180ms ease-out,
    border-color 160ms ease-out,
    background 180ms ease-out;
}

.cx-notch-callnotes::before {
  content: "";
  position: absolute;
  inset: -30%;
  background:
    linear-gradient(120deg, rgba(148,163,184,0.3), transparent 40%),
    linear-gradient(300deg, rgba(56,189,248,0.4), transparent 55%);
  opacity: 0.4;
  mix-blend-mode: soft-light;
  pointer-events: none;
}

.cx-notch-callnotes-label {
  position: relative;
  z-index: 1;
  display: inline-flex;
  align-items: center;
  gap: 4px;
}

.cx-notch-callnotes-main {
  font-weight: 600;
}

.cx-notch-callnotes-echo {
  font-size: 0.85em;
  opacity: 0.7;
}

.cx-notch-callnotes:hover {
  transform: translateY(-50%) scale(1.04);
  border-color: rgba(148,163,184,0.95);
  box-shadow:
    0 0 0 1px rgba(15,23,42,0.98),
    0 12px 30px rgba(0,0,0,0.95),
    0 0 30px rgba(56,189,248,0.3);
}

.cx-notch-callnotes:active {
  transform: translateY(-50%) scale(0.96);
}

.cx-notch-callnotes.is-hot {
  animation: cx-pulse-callnotes 2.4s ease-in-out infinite;
  border-color: rgba(56,189,248,0.95);
  box-shadow:
    0 0 0 1px rgba(15,23,42,0.98),
    0 10px 26px rgba(0,0,0,0.9),
    0 0 30px rgba(56,189,248,0.5);
}

@keyframes cx-pulse-callnotes {
  0%, 100% {
    box-shadow:
      0 0 0 1px rgba(15,23,42,0.98),
      0 10px 26px rgba(0,0,0,0.9),
      0 0 30px rgba(56,189,248,0.5);
  }
  50% {
    box-shadow:
      0 0 0 1px rgba(15,23,42,0.98),
      0 10px 26px rgba(0,0,0,0.9),
      0 0 50px rgba(56,189,248,0.75);
  }
}

/* Show CX notch on Call Notes layout */
body[data-layout="callnotes"] .cx-notch-callnotes {
  display: inline-flex;
}

/* Phase 20: Hide CX Sync button in plain notepad mode (only show on Messenger split + Call Notes mlcx) */
body[data-layout="notepad"] #mlcxToggleBtn {
  display: none !important;
}

/* Phase 19.10: Hide CV pill on MLCX Notepad only */
body[data-layout="mlcx"] .cv-pill-btn {
  display: none !important;
}

/* When CX mode is on, hide the inline MLCX pills row */
body[data-cx-mode="on"] .mlcx-pills-row {
  display: none !important;
}


/* FULLSCREEN MLCX DASHBOARD LAYOUT */
body[data-layout="mlcx"] .app-main {
      height: 100%;
      min-height: 100%;
      display: flex;
      flex-direction: column;
    }

body[data-layout="mlcx"] .app-card {
      height: calc(100vh - 40px);
      display: flex;
      flex-direction: column;
    }

body[data-layout="mlcx"] .mlcx-panel {
      display: flex;
    }

.mlcx-layout {
      flex: 1 1 auto;
      height: 100%;
      min-height: 100%;
      display: grid;
      grid-template-columns: 2fr 1.2fr;
      gap: 24px;
    }

.mlcx-notes-column {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

.mlcx-notes-textarea {
      flex: 1 1 auto;
      min-height: 60vh;
      height: 100%;
      resize: vertical;
    }

.mlcx-train-column {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }

.mlcx-training-panel {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow: auto;
    }

</style>
<style>
/* === Phase 5.A: Dev Lab Dictionaries Skeleton === */
.devlab-view-dict { height: auto; min-height: 560px; display:flex; flex-direction:column; gap: 12px; }
#dictTopbar { display:flex; align-items:center; justify-content:space-between; gap: 12px; padding: 12px 14px; border-radius: 14px; background: rgba(255,255,255,0.55); border: 1px solid rgba(148,163,184,0.35); backdrop-filter: blur(10px); }
#dictTitle { margin: 0; font-size: 0.95rem; font-weight: 700; letter-spacing: 0.02em; }
#dictMeta { margin-top: 2px; font-size: 0.72rem; opacity: 0.75; }
.dictTopbarLeft { display:flex; flex-direction:column; min-width: 220px; }
.dictTopbarRight { display:flex; align-items:center; gap: 8px; flex-wrap:wrap; justify-content:flex-end; }
#dictSearch { width: 260px; max-width: 38vw; padding: 9px 10px; border-radius: 12px; border: 1px solid rgba(148,163,184,0.35); background: rgba(255,255,255,0.75); outline: none; }
#dictScope, #filterUkusType { padding: 9px 10px; border-radius: 12px; border: 1px solid rgba(148,163,184,0.35); background: rgba(255,255,255,0.75); }
#dictCopyView, #dictCopyItem, #dictExportJson, #detailCopyBtn { padding: 9px 12px; border-radius: 12px; border: 1px solid rgba(148,163,184,0.35); background: rgba(255,255,255,0.75); cursor:pointer; }
#dictCopyItem[disabled], #dictExportJson[disabled] { opacity: 0.45; cursor:not-allowed; }



/* === Dictionaries 2.0 (View-only) === */
/* === Library 2.0 (Dev Lab) === */
#lib2Container, #lib2Container * { pointer-events:auto !important; }
#lib2Container .editor-title { width:100%; }
#lib2Container .editor-text { min-height:260px; }

#dict2Topbar { display:flex; justify-content:space-between; align-items:center; gap:12px; padding: 10px 12px; border:1px solid var(--panel-border); border-radius: 12px; background: rgba(10,16,26,0.55); box-shadow: 0 6px 18px rgba(0,0,0,0.22); margin-bottom: 12px; }
#dict2Topbar .dictTopbarLeft h3 { margin:0; }
#dict2Topbar .dictTopbarRight { display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:flex-end; }
#dict2Topbar input, #dict2Topbar select { height:34px; border-radius: 10px; border: 1px solid var(--panel-border); background: rgba(8,12,20,0.65); color: #e9eef7; padding: 0 10px; outline:none; }
#dict2Topbar button { height:34px; border-radius: 10px; border: 1px solid var(--panel-border); background: rgba(18,26,40,0.75); color: #e9eef7; padding: 0 10px; cursor:pointer; }
#dict2Topbar button:hover { filter: brightness(1.08); }
#dict2Grid { display:grid; grid-template-columns: 240px 1fr 1fr; gap: 12px; min-height: 360px; height: 72vh; }
#dict2Grid .dictCard { height: 100%; }
.dict2SectionBtn { width:100%; }
#devlabPanelDictionaries2, #devlabPanelDictionaries2 * { pointer-events:auto !important; }
#dict2Topbar, #dict2Topbar * { pointer-events:auto !important; }
#dict2Grid, #dict2Grid * { pointer-events:auto !important; }

@media (max-width: 1100px) {
  #dict2Grid { grid-template-columns: 220px 1fr; grid-template-rows: 1fr 1fr; }
  #dict2DetailPanel { grid-column: 1 / -1; }
}
#dictGrid { display:grid; grid-template-columns: 240px 1fr 1fr; gap: 12px; min-height: 360px; height: 72vh; }
.dictCard { background: rgba(255,255,255,0.55); border: 1px solid rgba(148,163,184,0.35); border-radius: 16px; padding: 12px; backdrop-filter: blur(10px); min-height: 0; overflow: hidden; display:flex; flex-direction:column; }
#dictIndex { display:flex; flex-direction:column; gap: 12px; }
.dictSectionGroup { display:flex; flex-direction:column; gap: 8px; }
.dictSectionBtn { text-align:left; padding: 10px 10px; border-radius: 12px; border: 1px solid rgba(148,163,184,0.35); background: rgba(255,255,255,0.72); cursor:pointer; font-weight: 650; }
.dictSectionBtn.is-active { background: rgba(59,130,246,0.14); border-color: rgba(59,130,246,0.42); color: #1e40af; }
.dictFilters { display:flex; flex-direction:column; gap: 12px; }
.dictFilterLabel { font-size: 0.72rem; font-weight: 650; opacity: 0.8; margin-bottom: 6px; }
.dictTinyNote { font-size: 0.7rem; opacity: 0.65; margin-top: 8px; }
.dictSeg { display:flex; gap: 6px; flex-wrap:wrap; }
.dictSegBtn { padding: 7px 9px; border-radius: 999px; border: 1px solid rgba(148,163,184,0.35); background: rgba(255,255,255,0.75); cursor:pointer; font-size:0.72rem; font-weight:650; }
.dictSegBtn.is-active { background: rgba(16,185,129,0.14); border-color: rgba(16,185,129,0.42); }
.dictCounts { margin-top:auto; font-size: 0.72rem; opacity: 0.75; border-top: 1px solid rgba(148,163,184,0.25); padding-top: 10px; }

#dictListPanel { display:flex; flex-direction:column; gap: 10px; overflow: hidden; height: 100%; }
.dictListHeader { display:flex; flex-direction:column; gap: 2px; padding-bottom: 8px; border-bottom: 1px solid rgba(148,163,184,0.25); }
#dictListTitle { font-weight: 750; font-size: 0.86rem; }
#dictListHint { font-size: 0.72rem; opacity: 0.7; }
.dictList { overflow:auto; padding-top: 10px; display:flex; flex-direction:column; gap: 8px; flex:1; }
.dictItem { width:100%; text-align:left; padding: 10px; border-radius: 14px; border: 1px solid rgba(148,163,184,0.32); background: rgba(255,255,255,0.76); cursor:pointer; display:flex; align-items:flex-start; justify-content:space-between; gap: 10px; }
.dictItem:hover { background: rgba(255,255,255,0.9); }
.dictItem.is-selected { outline: 2px solid rgba(59,130,246,0.35); border-color: rgba(59,130,246,0.35); }
.dictItemPrimary { font-weight: 750; font-size: 0.84rem; }
.dictItemSecondary { font-size: 0.72rem; opacity: 0.75; margin-top: 2px; }
.dictItemBadge { font-size: 0.7rem; font-weight: 750; padding: 4px 8px; border-radius: 999px; border: 1px solid rgba(148,163,184,0.32); background: rgba(255,255,255,0.6); opacity: 0.95; white-space:nowrap; align-self:flex-start; }

#dictDetailPanel { overflow: hidden; height: 100%; }
#dictIndex { height: 100%; overflow: auto; }
 .detailTitle { font-weight: 800; font-size: 0.92rem; }
.detailBadges { display:flex; flex-wrap:wrap; gap: 6px; margin-top: 8px; }
.detailBadges .chip { font-size: 0.7rem; font-weight: 750; padding: 4px 8px; border-radius: 999px; border: 1px solid rgba(148,163,184,0.32); background: rgba(255,255,255,0.7); }
.detailBlock { margin-top: 14px; }
.detailLabel { font-size: 0.72rem; font-weight: 700; opacity: 0.75; margin-bottom: 6px; }
.detailBody, .detailNotes, .detailExample { font-size: 0.8rem; line-height: 1.35; }
.detailPatterns { margin-top: 12px; }
.detailPre { font-size: 0.72rem; background: rgba(15,23,42,0.06); border: 1px solid rgba(148,163,184,0.25); padding: 10px; border-radius: 12px; overflow:auto; }
#detailCopySnippet { width: 100%; padding: 10px; border-radius: 12px; border: 1px solid rgba(148,163,184,0.35); background: rgba(255,255,255,0.75); resize: vertical; }
.dictEmpty { font-size: 0.78rem; opacity: 0.7; padding: 14px; border: 1px dashed rgba(148,163,184,0.4); border-radius: 14px; margin-top: 10px; }

@media (max-width: 1100px) {
  #dictGrid { grid-template-columns: 220px 1fr; grid-template-rows: 1fr 1fr; }
  #dictDetailPanel { grid-column: 1 / -1; }
  #dictSearch { width: 180px; }
}

</style>


<style>
.mlcx-og-container {display:flex;gap:24px;height:100%;}
.mlcx-og-left, .mlcx-og-right {background:rgba(255,255,255,0.02);padding:20px;border-radius:18px;flex:1;display:flex;flex-direction:column;}
.mlcx-og-left {flex:1.4;}
.mlcx-og-title {color:var(--text-main);font-size:18px;margin-bottom:8px;}
.mlcx-og-desc {color:var(--text-muted);margin-bottom:6px;font-size:14px;}
.mlcx-og-textarea {flex:1;background:rgba(255,255,255,0.05);border:1px solid var(--panel-border);border-radius:14px;color:var(--text-main);padding:12px;font-size:14px;}
.mlcx-og-actions {margin-top:10px;display:flex;gap:8px;}
.mlcx-og-chips {margin-top:12px;color:var(--text-muted);background:rgba(255,255,255,0.05);padding:6px 10px;border-radius:12px;font-size:13px;}
.mlcx-og-right {flex:1;overflow-y:auto;}
.mlcx-og-card {background:rgba(255,255,255,0.04);border:1px solid var(--panel-border);padding:14px;border-radius:14px;margin-bottom:14px;}
.mlcx-og-card-header {display:flex;justify-content:space-between;margin-bottom:6px;font-weight:600;color:var(--text-main);}
.mlcx-tag {font-size:11px;padding:2px 8px;background:rgba(255,255,255,0.1);border-radius:10px;}
</style>


<style>
/* Hide CX drawer button when in MLCX layout */
body[data-layout="mlcx"] .cx-toggle { display: none !important; }
</style>


<style>
.mlcx-chip{
  display:inline-block;
  margin:4px;
  padding:4px 8px;
  border-radius:12px;
  background:rgba(148,163,184,0.15);
  border:1px solid rgba(148,163,184,0.3);
  font-size:12px;
  color:var(--text-main);
}
</style>

<style>
/* High-risk snippets card in CX drawer */
.mlcx-highrisk-card {
  background: rgba(255,255,255,0.03);
  border: 1px solid rgba(239, 68, 68, 0.3);
  padding: 12px;
  border-radius: 12px;
  margin-top: 8px;
  display: flex;
  flex-direction: column;
  max-height: 280px;
}

.mlcx-highrisk-header {
  margin-bottom: 8px;
  flex-shrink: 0;
}

.mlcx-highrisk-title {
  font-weight: 600;
  color: var(--text-main);
  font-size: 13px;
  margin-bottom: 2px;
}

.mlcx-highrisk-subtitle {
  font-size: 11px;
  color: var(--text-muted);
  opacity: 0.8;
}

.mlcx-highrisk-content {
  flex: 1 1 auto;
  overflow-y: auto;
  min-height: 0;
  font-size: 12px;
  color: var(--text-main);
}

.mlcx-highrisk-empty {
  color: var(--text-muted);
  font-size: 12px;
  opacity: 0.7;
  font-style: italic;
}

.mlcx-highrisk-list {
  margin: 0;
  padding-left: 1.2em;
  list-style-type: disc;
}

.mlcx-highrisk-list li {
  margin-bottom: 6px;
  line-height: 1.4;
}

.mlcx-highrisk-chip {
  display: inline-block;
  margin: 0 4px 0 0;
  padding: 2px 6px;
  border-radius: 8px;
  background: rgba(239, 68, 68, 0.15);
  border: 1px solid rgba(239, 68, 68, 0.3);
  font-size: 10px;
  color: #fca5a5;
  text-transform: uppercase;
  letter-spacing: 0.03em;
}

.mlcx-highrisk-chip-safety {
  display: inline-block;
  margin: 0 4px 0 0;
  padding: 2px 6px;
  border-radius: 8px;
  background: rgba(220,38,38,0.25);
  border: 1px solid rgba(220,38,38,0.4);
  font-size: 10px;
  color: rgba(254,202,202,0.98);
  text-transform: uppercase;
  letter-spacing: 0.03em;
  font-weight: 600;
}

/* Light/Lunar mode chip visibility */
body[data-theme="light"] .mlcx-highrisk-chip,
body[data-theme="lunar"] .mlcx-highrisk-chip {
  background: rgba(239,68,68,0.12);
  color: rgba(127,29,29,0.95);
  border: 1px solid rgba(239,68,68,0.25);
  font-weight: 600;
}

body[data-theme="light"] .mlcx-highrisk-chip-safety,
body[data-theme="lunar"] .mlcx-highrisk-chip-safety {
  background: rgba(220,38,38,0.15);
  color: rgba(127,29,29,0.98);
  border: 1px solid rgba(220,38,38,0.35);
  font-weight: 700;
}

/* MLCX Snapshot styling - added after mlcx-highrisk-chip */
.mlcx-snapshot-severity {
  display: inline-block;
  padding: 4px 12px;
  border-radius: 999px;
  font-size: 0.72rem;
  font-weight: 600;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  margin-bottom: 8px;
}
.mlcx-severity-low {
  background: rgba(34,197,94,0.2);
  color: rgba(134,239,172,0.98);
  border: 1px solid rgba(34,197,94,0.4);
}
.mlcx-severity-medium {
  background: rgba(251,146,60,0.2);
  color: rgba(253,186,116,0.98);
  border: 1px solid rgba(251,146,60,0.4);
}
.mlcx-severity-high {
  background: rgba(239,68,68,0.2);
  color: rgba(252,165,165,0.98);
  border: 1px solid rgba(239,68,68,0.4);
}

/* Light/Lunar mode severity badges */
body[data-theme="light"] .mlcx-severity-low,
body[data-theme="lunar"] .mlcx-severity-low {
  background: rgba(34,197,94,0.15);
  color: rgba(21,128,61,0.98);
  border: 1px solid rgba(34,197,94,0.3);
}
body[data-theme="light"] .mlcx-severity-medium,
body[data-theme="lunar"] .mlcx-severity-medium {
  background: rgba(251,146,60,0.15);
  color: rgba(154,52,18,0.98);
  border: 1px solid rgba(251,146,60,0.3);
}
body[data-theme="light"] .mlcx-severity-high,
body[data-theme="lunar"] .mlcx-severity-high {
  background: rgba(239,68,68,0.15);
  color: rgba(127,29,29,0.98);
  border: 1px solid rgba(239,68,68,0.3);
}

.mlcx-snapshot-counts {
  font-size: 0.74rem;
  color: rgba(203,213,225,0.92);
  line-height: 1.5;
}

body[data-theme="light"] .mlcx-snapshot-counts,
body[data-theme="lunar"] .mlcx-snapshot-counts {
  color: rgba(148,163,184,0.95);
  font-weight: 500;
}

/* Ensure no snapshot renders under Call Notes panel */
.mlcx-og-left .mlcx-snapshot { display: none !important; }


</style>



<style>
.mlcx-og-container {display:flex;gap:24px;height:100%;}
.mlcx-og-left, .mlcx-og-right {background:rgba(255,255,255,0.02);padding:20px;border-radius:18px;flex:1;display:flex;flex-direction:column;}
.mlcx-og-left {flex:1.4;}
.mlcx-og-title {color:var(--text-main);font-size:18px;margin-bottom:8px;}
.mlcx-og-desc {color:var(--text-muted);margin-bottom:6px;font-size:14px;}
.mlcx-og-textarea {flex:1;background:rgba(255,255,255,0.05);border:1px solid var(--panel-border);border-radius:14px;color:var(--text-main);padding:12px;font-size:14px;}
.mlcx-og-actions {margin-top:10px;display:flex;gap:8px;}
.mlcx-og-chips {margin-top:12px;color:var(--text-muted);background:rgba(255,255,255,0.05);padding:6px 10px;border-radius:12px;font-size:13px;}
.mlcx-og-right {flex:1;overflow-y:auto;}
.mlcx-og-card {background:rgba(255,255,255,0.04);border:1px solid var(--panel-border);padding:14px;border-radius:14px;margin-bottom:14px;}
.mlcx-og-card-header {display:flex;justify-content:space-between;margin-bottom:6px;font-weight:600;color:var(--text-main);}
.mlcx-tag {font-size:11px;padding:2px 8px;background:rgba(255,255,255,0.1);border-radius:10px;}
</style>


<style>
/* Hide CX drawer button when in MLCX layout */
body[data-layout="mlcx"] .cx-toggle { display: none !important; }
</style>


<style>
.mlcx-chip{
  display:inline-block;
  margin:4px;
  padding:4px 8px;
  border-radius:12px;
  background:rgba(148,163,184,0.15);
  border:1px solid rgba(148,163,184,0.3);
  font-size:12px;
  color:var(--text-main);
}
</style>

<style>
/* High-risk snippets card in CX drawer */
.mlcx-highrisk-card {
  background: rgba(255,255,255,0.03);
  border: 1px solid rgba(239, 68, 68, 0.3);
  padding: 12px;
  border-radius: 12px;
  margin-top: 8px;
  display: flex;
  flex-direction: column;
  max-height: 280px;
}

.mlcx-highrisk-header {
  margin-bottom: 8px;
  flex-shrink: 0;
}

.mlcx-highrisk-title {
  font-weight: 600;
  color: var(--text-main);
  font-size: 13px;
  margin-bottom: 2px;
}

.mlcx-highrisk-subtitle {
  font-size: 11px;
  color: var(--text-muted);
  opacity: 0.8;
}

.mlcx-highrisk-content {
  flex: 1 1 auto;
  overflow-y: auto;
  min-height: 0;
  font-size: 12px;
  color: var(--text-main);
}

.mlcx-highrisk-empty {
  color: var(--text-muted);
  font-size: 12px;
  opacity: 0.7;
  font-style: italic;
}

.mlcx-highrisk-list {
  margin: 0;
  padding-left: 1.2em;
  list-style-type: disc;
}

.mlcx-highrisk-list li {
  margin-bottom: 6px;
  line-height: 1.4;
}

.mlcx-highrisk-chip {
  display: inline-block;
  margin: 0 4px 0 0;
  padding: 2px 6px;
  border-radius: 8px;
  background: rgba(239, 68, 68, 0.15);
  border: 1px solid rgba(239, 68, 68, 0.3);
  font-size: 10px;
  color: #fca5a5;
  text-transform: uppercase;
  letter-spacing: 0.03em;
}

.mlcx-highrisk-chip-safety {
  display: inline-block;
  margin: 0 4px 0 0;
  padding: 2px 6px;
  border-radius: 8px;
  background: rgba(220,38,38,0.25);
  border: 1px solid rgba(220,38,38,0.4);
  font-size: 10px;
  color: rgba(254,202,202,0.98);
  text-transform: uppercase;
  letter-spacing: 0.03em;
  font-weight: 600;
}

/* Light/Lunar mode chip visibility */
body[data-theme="light"] .mlcx-highrisk-chip,
body[data-theme="lunar"] .mlcx-highrisk-chip {
  background: rgba(239,68,68,0.12);
  color: rgba(127,29,29,0.95);
  border: 1px solid rgba(239,68,68,0.25);
  font-weight: 600;
}

body[data-theme="light"] .mlcx-highrisk-chip-safety,
body[data-theme="lunar"] .mlcx-highrisk-chip-safety {
  background: rgba(220,38,38,0.15);
  color: rgba(127,29,29,0.98);
  border: 1px solid rgba(220,38,38,0.35);
  font-weight: 700;
}

/* MLCX Snapshot styling - added after mlcx-highrisk-chip */
.mlcx-snapshot-severity {
  display: inline-block;
  padding: 4px 12px;
  border-radius: 999px;
  font-size: 0.72rem;
  font-weight: 600;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  margin-bottom: 8px;
}
.mlcx-severity-low {
  background: rgba(34,197,94,0.2);
  color: rgba(134,239,172,0.98);
  border: 1px solid rgba(34,197,94,0.4);
}
.mlcx-severity-medium {
  background: rgba(251,146,60,0.2);
  color: rgba(253,186,116,0.98);
  border: 1px solid rgba(251,146,60,0.4);
}
.mlcx-severity-high {
  background: rgba(239,68,68,0.2);
  color: rgba(252,165,165,0.98);
  border: 1px solid rgba(239,68,68,0.4);
}

/* Light/Lunar mode severity badges */
body[data-theme="light"] .mlcx-severity-low,
body[data-theme="lunar"] .mlcx-severity-low {
  background: rgba(34,197,94,0.15);
  color: rgba(21,128,61,0.98);
  border: 1px solid rgba(34,197,94,0.3);
}
body[data-theme="light"] .mlcx-severity-medium,
body[data-theme="lunar"] .mlcx-severity-medium {
  background: rgba(251,146,60,0.15);
  color: rgba(154,52,18,0.98);
  border: 1px solid rgba(251,146,60,0.3);
}
body[data-theme="light"] .mlcx-severity-high,
body[data-theme="lunar"] .mlcx-severity-high {
  background: rgba(239,68,68,0.15);
  color: rgba(127,29,29,0.98);
  border: 1px solid rgba(239,68,68,0.3);
}

.mlcx-snapshot-counts {
  font-size: 0.74rem;
  color: rgba(203,213,225,0.92);
  line-height: 1.5;
}

body[data-theme="light"] .mlcx-snapshot-counts,
body[data-theme="lunar"] .mlcx-snapshot-counts {
  color: rgba(148,163,184,0.95);
  font-weight: 500;
}

/* Ensure no snapshot renders under Call Notes panel */
.mlcx-og-left .mlcx-snapshot { display: none !important; }

/* === Refinement: icon/button weight consistency for icon-only controls === */
:root{
  --tap-lift: translateY(-1px);
  --tap-press: translateY(0px);
}

.theme-toggle button,
.theme-toggle .dice-toggle,
.text-size-btn,
.highlight-swatch,
.ms-notch,
.cx-notch,
.cx-drawer-close-btn{
  font-weight: 600;
  -webkit-font-smoothing: antialiased;
  text-rendering: geometricPrecision;
  transition:
    transform 140ms ease-out,
    box-shadow 160ms ease-out,
    border-color 160ms ease-out,
    background 180ms ease-out,
    filter 180ms ease-out,
    opacity 180ms ease-out;
}

/* tactile hover/press */
.theme-toggle button:hover,
.theme-toggle .dice-toggle:hover,
.text-size-btn:hover,
.highlight-swatch:hover,
.ms-notch:hover,
.cx-notch:hover,
.cx-drawer-close-btn:hover{
  transform: var(--tap-lift);
  filter: brightness(1.06);
}

.theme-toggle button:active,
.theme-toggle .dice-toggle:active,
.text-size-btn:active,
.highlight-swatch:active,
.ms-notch:active,
.cx-notch:active,
.cx-drawer-close-btn:active{
  transform: var(--tap-press);
  filter: brightness(0.98);
}

/* normalize icon-only pills */
.text-size-btn{
  box-shadow: 0 6px 16px rgba(0,0,0,0.22);
}
.text-size-btn:hover{
  box-shadow: 0 10px 24px rgba(0,0,0,0.28);
}

/* make swatches feel "clickable" */
.highlight-swatch{
  box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.85), 0 6px 16px rgba(0,0,0,0.22);
}
.highlight-swatch:hover{
  box-shadow: 0 0 0 2px var(--focus-ring), 0 10px 24px rgba(0,0,0,0.28);
}

</style>

</head>
<body data-colour="crown" data-textsize="md" data-theme="lunar" data-layout="split" data-phone="off" class="mf-preload">
<!-- LOW-POLY SVG BACKGROUND -->
<svg class="lowpoly-bg" id="lowpolyBg" preserveaspectratio="xMidYMid slice" viewbox="0 0 100 60"></svg>
<div class="bg-overlay"></div>
<div class="app-viewport">
<main class="app">

<!-- LEFT PANEL -->
<section aria-label="Messenger draft builder" class="panel">
<div class="panel-title-row">
<div class="agent-tag" title="MirrorFlow Customer Experience">
<span aria-hidden="true" class="agent-dot"></span>
<span class="app-title app-title--split">MirrorFlow</span>
</div>
</div>
<div class="draft-layout">
<!-- CUSTOMER LAST MESSAGE -->
<div class="draft-column">
<div class="field-label"></div>
<div class="textarea-shell">
<textarea style="height:210px;" aria-label="Customer's last message" class="locked-textarea" id="customerInput" placeholder="Hi, I need help with my claim." spellcheck="true"></textarea>
<button type="button" class="commit-btn commit-btn--customer" id="customerCommitBtn" aria-label="Lock customer bubble" title="Lock bubble">➤</button></div>
</div>
<!-- AGENT MESSAGE -->
<div class="draft-column agent-column">
<div class="field-label"></div>
<div aria-label="Formatting tools" class="toolbar">
<div class="toolbar-left" style="margin-top:-8px;">
<button aria-label="Make selected text bold" class="fmt-btn" data-action="bold" type="button"><strong>B</strong> Bold</button>
<button aria-label="Make selected text italic" class="fmt-btn" data-action="italic" type="button"><em>I</em> Italic</button>
<button aria-label="Apply bullet list" class="fmt-btn" data-action="bullets" type="button">• Bullets</button>
<button aria-label="Apply numbered list" class="fmt-btn" data-action="numbered" type="button">1. Numbered</button>
<button aria-label="Undo last change" class="fmt-btn" data-action="undo" type="button">↺ Undo</button>
<button aria-label="Redo last change" class="fmt-btn" data-action="redo" type="button">↻ Redo</button>
<button aria-label="Clean extra spaces and blank lines" data-action="clean" class="fmt-btn clean-btn" data-tooltip="Tidy formatting and refresh highlights (when hints are on)" title="Clean formatting" type="button">Clean</button>
<button class="toolbar-pill" data-tooltip="Insert reply template" title="Reply templates" id="repliesBtn" type="button">Replies ▾</button>
<button class="toolbar-pill" data-tooltip="Insert warmth phrase" title="Warmth phrases" id="phrasesBtn" type="button">Phrases ▾</button>
<div aria-label="Reply templates" 
<div aria-label="Reply templates" id="repliesPanel">
  <!-- NCD & pricing -->
  <div class="qr-label">NCD &amp; pricing</div>
  <div class="qr-item">Hi [name]. Thanks for getting in touch. As the claim is still open, we don’t yet have a final cost, so the exact impact on your price isn’t confirmed. What I can explain for now is…</div>
  <div class="qr-item">Hi [name]. Now that the claim has been settled, we can see the total cost. I’d like to explain how that can affect your no claims discount and renewal price so you know what to expect.</div>
  <div class="qr-item">Hi [name]. I know changes to price can be worrying. Insurers look at your overall claims history as well as any discounts you have, so even with a protected no claims discount the base price can still move. Here’s how that works for you…</div>

  <div class="qr-divider"></div>

  <!-- Courtesy car & mobility -->
  <div class="qr-label">Courtesy car &amp; mobility</div>
  <div class="qr-item">Hi [name]. Thanks for your message. Courtesy cars are usually only provided while repairs are being carried out. In write-off or unrecovered theft cases, the cover works a bit differently. What this means here is…</div>
  <div class="qr-item">Hi [name]. I’ve taken a look at the hire car dates and want to clear up how the charges work once the agreed period ends. In this case…</div>
  <div class="qr-item">Hi [name]. I’ve checked your cover and there isn’t a courtesy or hire car included on this policy. I know that’s not ideal, so I’ll explain what options you still have from here…</div>

  <div class="qr-divider"></div>

  <!-- Write-off & valuation -->
  <div class="qr-label">Write-off &amp; valuation</div>
  <div class="qr-item">Hi [name]. Your vehicle has been classed as a write-off and we’re now working on the valuation. Once that figure is ready, we’ll share it with you so you can review it. In the meantime…</div>
  <div class="qr-item">Hi [name]. I know this isn’t the news you were hoping for. A vehicle is usually written off when the cost of repairs is close to or more than its value, or when repairs wouldn’t be safe. Here’s what that means for your claim…</div>
  <div class="qr-item">Hi [name]. Thanks for sharing your thoughts on the valuation. If you’re unhappy with the figure we’ve given, there are a few things we can look at together to review it fairly…</div>

  <div class="qr-divider"></div>

  <!-- Under review & chasing -->
  <div class="qr-label">Under review &amp; chasing</div>
  <div class="qr-item">Hi [name]. Your claim is currently being reviewed by one of our specialist teams. These checks can take a little time, but once they’re finished we’ll be able to give you a clear update on the next steps.</div>
  <div class="qr-item">Hi [name]. I’ve checked your claim and at the moment we’re still waiting for some information before we can move things forward. Once we have it, we’ll be able to…</div>
  <div class="qr-item">Hi [name]. We’re waiting for an update from another party involved in the claim, which is why things are taking a little longer than usual. As soon as we receive their response, we’ll review it and let you know.</div>

  <div class="qr-divider"></div>

  <!-- Payments -->
  <div class="qr-label">Payments</div>
  <div class="qr-item">Hi [name]. I can confirm we’ve processed a payment relating to your claim. Depending on your bank, it may take a few working days to appear. What this payment covers is…</div>
  <div class="qr-item">Hi [name]. We’re getting everything ready for your payment but it hasn’t been released just yet. Before we can send it, we need to complete a couple of final checks…</div>
  <div class="qr-item">Hi [name]. I can see we’re due to return part or all of your excess. Once the payment’s been released, it should reach you within the usual banking timescales. Here’s how that will work…</div>

  <div class="qr-divider"></div>

  <!-- Repairs -->
  <div class="qr-label">Repairs</div>
  <div class="qr-item">Hi [name]. I’ve checked with the repairer and there’s currently a delay on your vehicle. The most common reasons are parts availability or workshop capacity. In your case, the delay is because…</div>
  <div class="qr-item">Hi [name]. The repairer is waiting for parts before they can carry on with the work. I know that’s frustrating, so I’ll outline what they’ve told us about timescales and what happens next…</div>
  <div class="qr-item">Hi [name]. Your repair booking is in place and I’d like to run through what will happen on the day, including drop-off, updates and collection…</div>

  <div class="qr-divider"></div>

  <!-- Liability -->
  <div class="qr-label">Liability</div>
  <div class="qr-item">Hi [name]. We’ve reviewed the details of the incident and reached a decision on liability. I’d like to explain what that means for your claim and how it could affect any costs or excess…</div>
  <div class="qr-item">Hi [name]. Liability for the incident is still being reviewed. We’re gathering information from everyone involved so we can make a fair decision. Once that’s complete, we’ll update you with the outcome.</div>
  <div class="qr-item">Hi [name]. The outcome is a split liability decision, which means responsibility is being shared between the parties involved. I’ll break down what that means in practical terms for you…</div>
</div>


<div aria-label="Phrase templates" id="phrasesPanel">
  <!-- Openers -->
  <div class="qr-label">Openers</div>
  <div class="qr-item">Hi [name]. Thanks for getting in touch - how can I help today?</div>
  <div class="qr-item">Hi [name]. Thanks for reaching out - let me take a look at this for you.</div>
  <div class="qr-item">Hi [name]. I really appreciate you getting in touch about this.</div>
  <div class="qr-item">Hi [name]. Thanks for your message - I’ll walk you through what’s going on.</div>

  <div class="qr-divider"></div>

  <!-- Empathy / Acknowledgement -->
  <div class="qr-label">Empathy / Acknowledgement</div>
  <div class="qr-item">I’m really sorry you’ve had to deal with this.</div>
  <div class="qr-item">I completely understand why you’re concerned.</div>
  <div class="qr-item">I’m sorry this has been such a stressful experience.</div>
  <div class="qr-item">That’s not the kind of experience we want you to have.</div>
  <div class="qr-item">Thank you for your patience while this has been going on.</div>
  <div class="qr-item">I know this probably isn’t how you hoped things would go.</div>
  <div class="qr-item">I appreciate you taking the time to explain what happened.</div>
  <div class="qr-item">I can see how frustrating that must have been.</div>

  <div class="qr-divider"></div>

  <!-- Reassurance / Ownership -->
  <div class="qr-label">Reassurance / Ownership</div>
  <div class="qr-item">Rest assured, I’m looking into this for you now.</div>
  <div class="qr-item">I’ll make sure this is checked properly before we move forward.</div>
  <div class="qr-item">I’ll keep an eye on this and update you as soon as anything changes.</div>
  <div class="qr-item">You’ve done the right thing by getting in touch with us.</div>
  <div class="qr-item">I’ll take ownership of this and see it through.</div>
  <div class="qr-item">I’m here to help you through each step.</div>
  <div class="qr-item">I’ll make sure your concerns are clearly noted on the claim.</div>
  <div class="qr-item">If I need anything else, I’ll let you know straight away.</div>

  <div class="qr-divider"></div>

  <!-- Setting expectations / Clarity -->
  <div class="qr-label">Setting expectations / Clarity</div>
  <div class="qr-item">To keep things clear, I’ll quickly summarise what will happen next.</div>
  <div class="qr-item">Just so you know what to expect over the next few days…</div>
  <div class="qr-item">I want to be upfront about the timescales involved here.</div>
  <div class="qr-item">I’ll explain this in plain English and avoid any jargon.</div>
  <div class="qr-item">If anything I’ve said isn’t clear, please let me know and I’ll rephrase it.</div>
  <div class="qr-item">I’ll break this down into a few simple steps for you.</div>
  <div class="qr-item">So we’re on the same page, here’s where things currently stand.</div>
  <div class="qr-item">If anything changes from what I’ve outlined, I’ll let you know.</div>

  <div class="qr-divider"></div>

  <!-- Softening bad news / Difficult updates -->
  <div class="qr-label">Softening bad news / Difficult updates</div>
  <div class="qr-item">I know this isn’t the update you were hoping for, and I’m sorry.</div>
  <div class="qr-item">I appreciate this may feel disappointing.</div>
  <div class="qr-item">I understand this isn’t the best news, but I’ll explain why.</div>
  <div class="qr-item">I know this might not be what you wanted to hear, so I’ll go through it carefully.</div>
  <div class="qr-item">I’m sorry we’re not able to do more here, and I’ll outline the options you still have.</div>
  <div class="qr-item">I appreciate this may feel unfair, so I’ll explain how we’ve reached this decision.</div>
  <div class="qr-item">I realise this may cause some inconvenience, and I’m sorry about that.</div>
  <div class="qr-item">If you’d like to talk through this in more detail, we can go through it step by step.</div>

  <div class="qr-divider"></div>

  <!-- Customer effort / Appreciation -->
  <div class="qr-label">Customer effort / Appreciation</div>
  <div class="qr-item">Thank you for sending that information so quickly.</div>
  <div class="qr-item">Thanks for sticking with us while we get this sorted.</div>
  <div class="qr-item">I really appreciate you taking the time to reply with these details.</div>
  <div class="qr-item">Thanks for bearing with me while I’ve checked everything.</div>
  <div class="qr-item">Your quick responses are really helping us move this along faster.</div>
  <div class="qr-item">Thank you for your patience while we’ve been looking into this.</div>
  <div class="qr-item">I appreciate you letting us know about this straight away.</div>
  <div class="qr-item">Thanks for giving me the chance to put this right.</div>

  <div class="qr-divider"></div>

  <!-- Collaboration / Partnership language -->
  <div class="qr-label">Collaboration / Partnership</div>
  <div class="qr-item">Let’s work through this together.</div>
  <div class="qr-item">Here’s what I’ll do from my side, and what I’ll need from you.</div>
  <div class="qr-item">We’ll take this one step at a time.</div>
  <div class="qr-item">I’ll handle the next part for you and then come back with an update.</div>
  <div class="qr-item">If you can do X, I’ll take care of the rest.</div>
  <div class="qr-item">I’ll make sure the right team has everything they need.</div>
  <div class="qr-item">We’ll keep things as simple as possible for you.</div>
  <div class="qr-item">If anything feels difficult or confusing, please tell me – that’s what I’m here for.</div>

  <div class="qr-divider"></div>

  <!-- Checking understanding / Offering more help -->
  <div class="qr-label">Checking understanding / Offering more help</div>
  <div class="qr-item">Does that all make sense so far?</div>
  <div class="qr-item">If anything isn’t clear, please let me know and I’ll explain it another way.</div>
  <div class="qr-item">Is there anything you’d like me to go over again?</div>
  <div class="qr-item">Have I missed anything that you were expecting us to cover?</div>
  <div class="qr-item">If you have any questions about this at any point, just reply to this message.</div>
  <div class="qr-item">If you’d prefer to speak to someone by phone about this, we can arrange that too.</div>
  <div class="qr-item">Please feel free to ask about anything that’s worrying you.</div>
  <div class="qr-item">I’m here if you need any more clarity on this.</div>

  <div class="qr-divider"></div>

  <!-- Closing / Comfort phrases -->
  <div class="qr-label">Closing / Comfort</div>
  <div class="qr-item">I hope this helps to put your mind at ease a little.</div>
  <div class="qr-item">I’ll stay with this until we reach the next stage for you.</div>
  <div class="qr-item">Thanks again for your patience while we sort this out.</div>
  <div class="qr-item">Take care, and please message us if anything else comes up.</div>
  <div class="qr-item">I’ll be back in touch as soon as I have more information.</div>
  <div class="qr-item">You’re always welcome to reach out if you’re unsure about anything.</div>
  <div class="qr-item">I’m glad we’ve been able to move this forward today.</div>
  <div class="qr-item">We really appreciate you being with us.</div>
</div>
<!-- Compact colour chooser for small screens (hidden on wide screens via CSS) -->
<div class="compact-colour-chooser" style="display:none;">
<label class="sr-only" for="colourSelect" style="position:absolute;width:1px;height:1px;overflow:hidden;clip:rect(0 0 0 0);white-space:nowrap;">Colourway</label>
<select aria-label="Colourway selection (compact)" id="colourSelect">
<option value="crown">The Crown</option>
<option value="classic">Rift</option>
<option value="sunburst">Sunburst</option>
<option value="teal">The Grove</option>
<option value="sahara">Sahara</option>
<option value="aurora">Aurora</option>
</select>
<button aria-label="Shuffle background pattern" class="compact-shuffle-btn" id="compactShuffleBtn" type="button">🎲</button>
</div>
</div>
</div>
<div class="textarea-shell">
<div aria-label="Your reply text" class="agent-textarea" contenteditable="true" id="agentInput" spellcheck="true" data-placeholder="Hi, thanks for reaching out, how can I help?"></div>
<button type="button" class="peek-btn" id="agentPeekBtn" aria-label="Preview draft on phone (hold)" title="Hold to preview">👁</button>
<button type="button" class="commit-btn commit-btn--agent" id="agentCommitBtn" aria-label="Lock reply bubble" title="Lock bubble">➤</button></div>
<div class="char-count-row">
  <div class="char-and-issues">
    <span id="mfLiveDot" class="mf-live-dot is-idle" aria-hidden="true" title="Analysis status"></span>

    <span class="mf-meter-badge char-counter" aria-label="Character count">
      Chars <span aria-live="polite" id="charCount">0</span>
    </span>

    <span class="mf-sep" aria-hidden="true">·</span>

    <span class="issue-counter toolbar-pill mf-meter-badge uk-counter"
          data-tooltip="Quick UK vs US spelling scan – hover issue to see details"
          id="ukIssueCounter" role="button" tabindex="0" title="UK spelling check">UK 0</span>

    <span class="mf-sep" aria-hidden="true">·</span>

    <span class="issue-counter toolbar-pill mf-meter-badge spell-counter"
          data-tooltip="Jargon & complex terms flagged – consider plain language alternatives"
          id="spellIssueCounter" role="button" tabindex="0" title="Jargon detector">Jargon 0</span>

    <button aria-pressed="true"
            class="toolbar-pill mf-meter-badge mf-guidance"
            data-tooltip="Toggle guidance highlighting on or off – Clean button always tidies formatting"
            id="spellToggleBtn" type="button" title="Checker toggle">Checker: OFF</button>

    <!-- Coaching master toggle moved to the bottom-most row (next to Phone focus) to avoid stretching this row -->
  </div>

  <div class="toolbar-divider" aria-hidden="true"></div>

  <div class="toolbar-right">
    <div class="char-actions">
      <button aria-label="Paste from clipboard into your reply" class="toolbar-pill mf-action-btn" id="pasteBtn" type="button">Paste</button>
      <button aria-label="Copy your reply with formatting" class="toolbar-pill mf-action-btn" id="copyBtn" type="button">Copy</button>
      <button aria-label="Clear both messages" class="toolbar-pill mf-action-btn" id="clearBtn" type="button">Clear</button>
    </div>
  </div>
</div>

<!-- Messenger Writer Insights drawer + notch (cloned from Notepad) -->
<div id="msWriterOverlay" class="ms-drawer-overlay" aria-hidden="true">
  <div class="ms-dim"></div>
  <aside id="msWriterDrawer" class="ms-drawer" aria-label="Writer Insights">
    <header class="np-drawer-header">
      <h2>Writer Insights</h2>
      <p>Readability · Structure · Tone · Clarity</p>
      <div class="ms-writer-role-row">
        <div class="ms-writer-role-toggle" role="radiogroup" aria-label="Writer insights source">
          <button type="button" class="ms-writer-role-btn active" data-role="agent" role="radio" aria-checked="true" title="Analyse the agent reply">Agent</button>
          <button type="button" class="ms-writer-role-btn" data-role="customer" role="radio" aria-checked="false" title="Analyse the customer message">Customer</button>
        </div>
        <div class="ms-writer-role-hint" id="msWriterRoleHint">Analysing: Agent reply</div>
      </div>
      <div class="np-summary-chips" id="msSummaryChips"></div>
      <button
        type="button"
        class="np-drawer-close-btn"
        id="msWriterDrawerClose"
        aria-label="Close writer insights panel"
      >
        ✕
      </button>
    </header>
    <div class="np-drawer-body" id="msWriterBody" role="region" aria-label="Writer insights content">
      <section class="np-drawer-section" id="msReadabilitySection"></section>
      <section class="np-drawer-section" id="msSentenceSection"></section>
      <section class="np-drawer-section" id="msWordInsightsSection"></section>
      <section class="np-drawer-section" id="msStructureSection"></section>
    </div>
  </aside>
</div>

<button
  id="msWriterNotch"
  class="ms-notch"
  type="button"
  title="Open writer insights"
  aria-label="Open writer insights"
  aria-expanded="false"
>
  ✎
</button>

<div class="font-size-row">
<div class="colourway-toggle-group">
<div aria-label="Colourway selection" class="pill-toggle" role="radiogroup">
<button aria-checked="true" aria-label="The Crown colourway" class="pill-button active" data-colour="crown" role="radio" type="button" data-label="Crown" title="The Crown"></button>
<button aria-checked="false" aria-label="Rift colourway" class="pill-button" data-colour="classic" role="radio" type="button" data-label="Rift" title="Rift"></button>
<button aria-checked="false" aria-label="Sunburst colourway" class="pill-button" data-colour="sunburst" role="radio" type="button" data-label="Sunburst" title="Sunburst"></button>
<button aria-checked="false" aria-label="The Grove colourway" class="pill-button" data-colour="teal" role="radio" type="button" data-label="Grove" title="The Grove"></button>
<button aria-checked="false" aria-label="Echo colourway" class="pill-button" data-colour="sahara" role="radio" type="button" data-label="Echo" title="Echo"></button>
<button aria-checked="false" aria-label="Aurora colourway" class="pill-button" data-colour="aurora" role="radio" type="button" data-label="Aurora" title="Aurora"></button>
</div>
<div aria-label="Theme and pattern toggle" class="theme-toggle">
<button aria-label="Shuffle colourway, theme and background pattern" class="dice-toggle" id="shuffleBtn" type="button" title="Surprise me!!">🎲</button>
<button aria-label="Light mode" aria-pressed="false" class="theme-btn" data-theme="light" type="button" title="Day mode">☀</button>
<button aria-label="Lunar mode" aria-pressed="true" class="theme-btn active" data-theme="lunar" type="button" title="Dusk mode">☁</button>
<button aria-label="Dark mode" aria-pressed="false" class="theme-btn" data-theme="dark" type="button" title="Night mode">🌙</button>

</div>
<div class="view-toggle" aria-label="View toggles">
  <button type="button" class="icon-pill" id="phoneSpotlightBtn" aria-pressed="false" title="Phone focus (center mobile preview)" data-tooltip="Phone focus">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.9" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
      <rect x="7" y="2.8" width="10" height="18.4" rx="2.2"></rect>
      <line x1="10" y1="5.8" x2="14" y2="5.8"></line>
      <circle cx="12" cy="18" r="0.9"></circle>
    </svg>
  </button>

  <!-- Coaching master toggle: shows/hides CX drawer + Writer Insights notches (OFF by default) -->
  <button
    type="button"
    class="icon-pill icon-pill--coaching"
    id="coachingMasterToggle"
    aria-pressed="false"
    title="Coaching toggle"
    data-tooltip="Show or hide coaching tools (CX drawer + Writer Insights) — hidden by default"
  >
    Coach
  </button>
</div>
<div class="bubble-add-group" aria-label="Add preview bubbles">
  <!-- Task 3: Removed unused customer/agent bubble add buttons -->
  <button type="button"
          class="bubble-add-btn bubble-add-btn--mlcx"
          id="mlcxToggleBtn"
          data-tooltip="Refresh MFCX analysis across customer + agent + notes"
          title="Sync CX"
          style="min-width:70px;padding:6px 12px;">
    <span class="bubble-add-dot"></span>
    <span class="bubble-add-plus">Sync CX</span>
  </button>
</div>
</div>

</div>
</div>
</div>
</section>
<!-- RIGHT PANEL: PHONE PREVIEW -->
<section aria-label="Messenger phone preview" class="preview-panel">
<div class="preview-badges">
  <div class="badge-pill">Mobile View</div>
</div>
      <div class="phone-frame" id="phoneFrame" style="width: 380px; min-width: 380px; max-width: 380px; height: 760px; min-height: 760px; max-height: 760px; aspect-ratio: auto; margin: 0 auto;">
<div class="phone-notch">
<div class="phone-speaker"></div>
<div class="phone-camera"></div>
</div>
<div class="phone-inner">
<div class="phone-top-bar">
<div class="phone-status">
<span class="phone-time">09:41</span>
<div class="status-pill">
<span class="status-dot"></span>
<span>Online</span>
</div>
</div>
<div class="phone-icons">
<div aria-hidden="true" class="signal-bars">
<span></span><span></span><span></span><span></span>
</div>
<div aria-hidden="true" class="battery">
<div class="battery-level"></div>
</div>
</div>
</div>
<div class="chat-header">
<div class="chat-header-left">
<div aria-hidden="true" class="back-btn">&lt;</div>
<div aria-hidden="true" class="avatar">CS</div>
<div class="chat-header-text">
<div class="chat-title">Customer Support</div>
<div class="chat-subtitle">Typically replies within an hour</div>
</div>
</div>
<div class="chat-header-right">
<span><span class="chat-header-dot"></span> Chats</span>
<span aria-hidden="true">⋮</span>
</div>
</div>
<div class="chat-body" id="chatBody">
  <div class="chat-scroll timeline" id="chatTimeline" aria-label="Chat timeline"></div>
  <div class="chatflow-legacy" data-chatflow-legacy hidden>

<section aria-label="Customer message preview" class="chat-section customer">
<div class="chat-section-label">CUSTOMER</div>
<div class="chat-scroll customer">
<div class="chat-bubble customer" id="customerBubble">
<p>Hi, I need help with my claim.</p>
</div>
</div>
</section>
<section aria-label="Your reply preview" class="chat-section agent">
<div class="chat-section-label">YOUR REPLY</div>
<div class="chat-scroll agent">
<div class="chat-bubble agent" id="agentBubble">
<p>Hi,<br>Thanks for reaching out, how can I help?</p>
</div>
</div>
</section>

  </div>
</div>
<div aria-hidden="true" class="chat-input-bar">
<div class="chat-input-shell">
<span class="chat-input-placeholder tip-text tip-fade-in" id="agentTipTicker">
                Agent tips will appear here…
              </span>
<div class="chat-input-icons">
<span class="chat-input-icon chat-input-send">▶</span>
</div>
</div>
</div>
<div class="home-bar">
<div class="home-pill"></div>
</div>
</div>
</div>
<div aria-label="Preview text size controls" class="phone-text-size-row">
<div aria-label="Preview text size controls" class="text-size-inline">
<span class="text-size-label">Text size</span>
<div aria-label="Preview text size" class="text-size-buttons" role="radiogroup">
<button aria-pressed="false" class="text-size-btn" data-size="xs" type="button">
<span>A</span>
</button>
<button aria-pressed="false" class="text-size-btn" data-size="sm" type="button">
<span>A</span>
</button>
<button aria-pressed="true" class="text-size-btn is-active" data-size="md" type="button">
<span>A</span>
</button>
<button aria-pressed="false" class="text-size-btn" data-size="lg" type="button">
<span>A</span>
</button>
</div>
</div>
</div>
</section>



<!-- Phase 19.4: Dev Lab panel (MLCX Debug + Library Editor) -->
<section aria-label="Developer Lab" class="panel dev-panel" data-current-view="mlcx">
<script>
  // Phase 19.7: Dev Lab view toggle logic (layout only)
  document.addEventListener('DOMContentLoaded', function() {
    const devPanel = document.querySelector('.dev-panel');
    if (!devPanel) return;

    const toggleBtns = Array.from(devPanel.querySelectorAll('.devlab-toggle-btn'));
    const views = Array.from(devPanel.querySelectorAll('.devlab-view'));


    // Phase D: Dev Lab “lockdown done right” (polish + safety)
    // Keep Dev Lab MLCX-only for now, but make it trivial to re-enable other views later.
    function getDevLabFlags(){
      return {
        showDictionaries: !!window.__DEVLAB_SHOW_DICTIONARIES,
        showLibraryEditor: !!window.__DEVLAB_SHOW_LIBRARY_EDITOR
      };
    }

    // Tie 2.0 tabs to the same flags (easy to split later if needed)
    const __DEVLAB_VIEW_ALLOWED = (view) => {
      const flags = getDevLabFlags();
      if (view === 'editor' || view === 'lib2') return flags.showLibraryEditor;
      if (view === 'dict' || view === 'dict2') return flags.showDictionaries;
      return true;
    };

    function applyDevLabFeatureFlags(){
      const row = devPanel.querySelector('.devlab-toggle-row');
      const btnEditor = devPanel.querySelector('.devlab-toggle-btn[data-view="editor"]');
      const btnLib2   = devPanel.querySelector('.devlab-toggle-btn[data-view="lib2"]');
      const btnDict   = devPanel.querySelector('.devlab-toggle-btn[data-view="dict"]');
      const btnDict2  = devPanel.querySelector('.devlab-toggle-btn[data-view="dict2"]');

      const flags = getDevLabFlags();
      const hideEditor = !flags.showLibraryEditor;
      const hideDict   = !flags.showDictionaries;

      [btnEditor, btnLib2].forEach(b => { if (b) b.classList.toggle('is-flag-hidden', hideEditor); });
      [btnDict, btnDict2].forEach(b => { if (b) b.classList.toggle('is-flag-hidden', hideDict); });

      // If only MLCX is enabled, hide the whole toggle row for a cleaner Dev Lab.
      const anyExtra = flags.showLibraryEditor || flags.showDictionaries;
      if (row) row.classList.toggle('is-flag-hidden', !anyExtra);
    }

    // Expose helper so you can flip flags in console and call this to unhide without refactor.
    devPanel.__applyDevLabFeatureFlags = applyDevLabFeatureFlags;

    function setDevView(view) {
      let next = (view || 'mlcx').trim() || 'mlcx';
      if (!__DEVLAB_VIEW_ALLOWED(next)) next = 'mlcx';

      devPanel.setAttribute('data-current-view', next);
      devPanel.setAttribute('data-dev-view', next);

      // Hide/show views defensively (works even if CSS is opinionated)
      views.forEach(v => {
        const isMatch = (v.getAttribute('data-dev-view') === next);
        v.hidden = !isMatch;
        // also keep inline display in sync for older CSS/layout assumptions
        v.style.display = isMatch ? '' : 'none';
      });

      toggleBtns.forEach(b => b.classList.toggle('is-active', b.getAttribute('data-view') === next));
    }

    // Expose a tiny debug hook (handy when Dev Lab "feels stuck")
    devPanel.__setDevView = setDevView;

    // Click wiring (event delegation + direct listeners as fallback)
    const toggleRow = devPanel.querySelector('.devlab-toggle-row');
    if (toggleRow) {
      toggleRow.addEventListener('click', (e) => {
        const btn = e.target && e.target.closest ? e.target.closest('.devlab-toggle-btn') : null;
        if (!btn) return;
        e.preventDefault();
        const view = btn.getAttribute('data-view');
        setDevView(view);
      });
    }
    toggleBtns.forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        setDevView(btn.getAttribute('data-view'));
      });
    });
    // Apply Phase D feature flags before selecting initial view
    applyDevLabFeatureFlags();
    const initialView = devPanel.getAttribute('data-current-view')
      || devPanel.getAttribute('data-dev-view')
      || 'mlcx';
    setDevView(initialView);

    // Phase 19.8: Wire Library Editor + Dictionaries (guarded so one failure doesn't break tabs)
    try { initDevLabLibraryEditor(); } catch (e) { console.warn('[DevLab] Library Editor init failed:', e); }
    try { initDevLabDictionaries(); } catch (e) { console.warn('[DevLab] Dictionaries init failed:', e); }
    try { initDevLabDictionaries2(); } catch (e) { console.warn('[DevLab] Dictionaries 2.0 init failed:', e); }
  
    try { initDevLabLibrary2(); } catch (e) { console.warn('[DevLab] Library 2.0 init failed:', e); }
});

  function initDevLabLibraryEditor() {
    const devlabView = document.querySelector(".devlab-view-editor");
    if (!devlabView) return;

    // Guard: prevent double-init (Horcrux calls init from multiple places)
    if (devlabView.__libraryEditorInitialised) return;

    // Cache DOM elements
    const searchInput      = devlabView.querySelector(".lib-search");
    const groupFilter      = devlabView.querySelector(".lib-group-filter");
    const statusButtons    = devlabView.querySelectorAll(".lib-status-button");
    const addNewBtn        = devlabView.querySelector(".lib-add-new");
    const listContainer    = devlabView.querySelector(".lib-template-list");
    const bulkDeleteBtn    = devlabView.querySelector(".bulk-delete");
    const bulkArchiveBtn   = devlabView.querySelector(".bulk-archive");
    const bulkRestoreBtn   = devlabView.querySelector(".bulk-restore");
    const bulkDuplicateBtn = devlabView.querySelector(".bulk-duplicate");

    // Phase 19.11: Deletion log UI refs
    const delLogEntries = devlabView.querySelector("#devDeletionLogEntries");
    const delLogCopyBtn = devlabView.querySelector("#devDeletionLogCopyBtn");

    // Phase 19.12b: Library type toggle
    const libraryTypeButtons = devlabView.querySelectorAll(".lib-library-button");

    const editorTitle   = devlabView.querySelector("#editor-title");
    const editorGroup   = devlabView.querySelector("#editor-group");
    const editorText    = devlabView.querySelector("#editor-text");
    const editorActive  = devlabView.querySelector("#editor-active");
    const editorSave    = devlabView.querySelector(".editor-save");
    const editorDup     = devlabView.querySelector(".editor-duplicate");
    const editorArch    = devlabView.querySelector(".editor-archive");
    const editorDelete  = devlabView.querySelector(".editor-delete");
    const previewBox    = devlabView.querySelector(".preview-content");
    const miniAnalysis  = devlabView.querySelector(".mini-analysis-content");

    // Module state
    let devlabLibraryType = "replies"; // "replies" | "phrases"
    let devlabSelection = new Set();
    let devlabCurrentId = null;
    let devlabStatusMode = "active"; // "active" or "archived"

    // Phase 19.11: helpers for deletion log
    function formatDeletionEntry(entry){
      const grp = entry.group || "";
      const id = entry.id || "";
      const label = entry.label || "";
      const text = entry.text || "";
      return `[group: ${grp}] [id: ${id}]\n`+
             `Label: "${label}"\n`+
             `Text:\n---\n${text}\n---\n`;
    }

    function renderDeletionLog(){
      if (!delLogEntries) return;
      if (!Array.isArray(mlcxDeletionLog) || mlcxDeletionLog.length === 0){
        delLogEntries.textContent = "No deletions recorded in this session.";
        return;
      }
      const combined = mlcxDeletionLog.map(formatDeletionEntry).join("\n");
      delLogEntries.textContent = combined;
    }

    function pushDeletionLog(item){
      if (!item) return;
      const label = (item.text || '').split(/\n/)[0].trim().slice(0, 120);
      mlcxDeletionLog.push({
        group: item.group || "",
        id: item.id || "",
        label: label || "",
        text: item.text || ""
      });
      renderDeletionLog();
    }

    // Enable controls
    if (searchInput) searchInput.disabled = false;
    if (groupFilter) groupFilter.disabled = false;
    if (addNewBtn) addNewBtn.disabled = false;
    statusButtons.forEach(btn => btn.disabled = false);

    // Helper: get current library
    function getDevlabLibrary() {
      return devlabLibraryType === "replies" ? repliesLibrary : phrasesLibrary;
    }

    // Helper: escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Helper: compute mini jargon snapshot
    function computeMiniJargonSnapshot(text) {
      if (!text || !text.trim()) {
        return "No analysis yet. Start typing to see jargon and UK/US signals.";
      }
      const wordCount = text.trim().split(/\s+/).length;
      return `Preview only: ${wordCount} words. Jargon/UKUS checks will plug in here in Phase 19.9.`;
    }

    // Helper: compute mini jargon snapshot
    function computeMiniJargonSnapshot(text) {
      if (!text || !text.trim()) {
        return "No analysis yet. Start typing to see jargon and UK/US signals.";
      }
      const wordCount = text.trim().split(/\s+/).length;
      return `Preview only: ${wordCount} words. Jargon/UKUS checks will plug in here in Phase 19.9.`;
    }

    // Phase 19.12b: Clear editor helper
    function clearDevlabEditor() {
      devlabCurrentId = null;
      if (editorTitle) editorTitle.textContent = "Select a template";
      if (editorGroup) editorGroup.value = "";
      if (editorText) editorText.value = "";
      if (editorActive) editorActive.checked = false;
      if (previewBox) previewBox.innerHTML = '<p class="preview-placeholder">Your template preview will appear here.</p>';
      if (miniAnalysis) miniAnalysis.textContent = "No analysis yet. This will show jargon and UK/US spellings for the current template in later phases.";
      if (editorSave) editorSave.disabled = true;
      if (editorDup) editorDup.disabled = true;
      if (editorArch) editorArch.disabled = true;
      if (editorDelete) editorDelete.disabled = true;
      if (editorGroup) editorGroup.disabled = true;
      if (editorText) editorText.disabled = true;
      if (editorActive) editorActive.disabled = true;
    }

    // Phase 19.12b: Set library type and refresh
    function setDevlabLibraryType(type) {
      devlabLibraryType = type;
      if (libraryTypeButtons && libraryTypeButtons.length) {
        libraryTypeButtons.forEach(btn => {
          const isActive = btn.dataset.library === type;
          btn.classList.toggle("lib-status-active", isActive);
        });
      }
      updateGroupFilter();
      updateEditorGroupDropdown();
      devlabCurrentId = null;
      devlabSelection.clear();
      renderDevlabList();
      clearDevlabEditor();
    }

    // Populate group filter
    function updateGroupFilter() {
      if (!groupFilter) return;
      const library = getDevlabLibrary();
      const groups = [...new Set(library.map(t => t.group).filter(Boolean))];
      groupFilter.innerHTML = '<option value="">All groups</option>' +
        groups.map(g => `<option value="${escapeHtml(g)}">${escapeHtml(g)}</option>`).join('');
    }

    // Populate editor group dropdown
    function updateEditorGroupDropdown() {
      if (!editorGroup) return;
      const library = getDevlabLibrary();
      const groups = [...new Set(library.map(t => t.group).filter(Boolean))];
      editorGroup.innerHTML = groups.map(g => `<option value="${escapeHtml(g)}">${escapeHtml(g)}</option>`).join('');
    }

    // Load template into editor
    function loadDevlabTemplate(id) {
      const item = getDevlabLibrary().find(t => t.id === id);
      if (!item) return;
      devlabCurrentId = id;

      editorTitle.textContent = `Editing: ${item.id}`;
      updateEditorGroupDropdown();
      editorGroup.value = item.group || "";
      editorText.value = item.text || "";
      editorActive.checked = !!item.active;

      previewBox.innerHTML = `<p>${escapeHtml(item.text || "No text yet.")}</p>`;
      miniAnalysis.textContent = computeMiniJargonSnapshot(item.text);

      // Enable buttons
      editorSave.disabled = false;
      editorDup.disabled = false;
      editorArch.disabled = false;
      editorDelete.disabled = false;
      editorGroup.disabled = false;
      editorText.disabled = false;
      editorActive.disabled = false;

      renderDevlabList();
    }

    // Render list
    function renderDevlabList() {
      if (!listContainer) return;
      
      const library = getDevlabLibrary();
      devlabSelection.clear();

      // Filter by group
      let filtered = library;
      const selectedGroup = groupFilter ? groupFilter.value : "";
      if (selectedGroup) {
        filtered = filtered.filter(t => t.group === selectedGroup);
      }

      // Filter by status
      if (devlabStatusMode === "active") {
        filtered = filtered.filter(t => t.active);
      }

      // Filter by search
      const searchTerm = searchInput ? searchInput.value.trim().toLowerCase() : "";
      if (searchTerm) {
        filtered = filtered.filter(t => 
          (t.text || "").toLowerCase().includes(searchTerm) ||
          (t.group || "").toLowerCase().includes(searchTerm) ||
          (t.id || "").toLowerCase().includes(searchTerm)
        );
      }

      listContainer.innerHTML = "";

      if (filtered.length === 0) {
        listContainer.innerHTML = '<p class="lib-empty-state">No templates match your filters.</p>';
        return;
      }

      filtered.forEach(item => {
        const row = document.createElement("div");
        row.className = "lib-template-item";
        row.dataset.id = item.id;
        if (devlabCurrentId === item.id) row.classList.add("is-selected");

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.className = "lib-template-checkbox";
        checkbox.addEventListener("change", (e) => {
          e.stopPropagation();
          if (checkbox.checked) {
            devlabSelection.add(item.id);
          } else {
            devlabSelection.delete(item.id);
          }
          updateBulkButtons();
        });

        const content = document.createElement("div");
        content.className = "lib-template-content";
        const shortenedText = (item.text || "Empty item").substring(0, 60) + ((item.text || "").length > 60 ? "..." : "");
        const statusLabel = item.active ? "" : " · Waiting room";
        content.innerHTML = `
          <div class="lib-template-text">${escapeHtml(shortenedText)}</div>
          <div class="lib-template-meta">${escapeHtml(item.group || "No group")} · ${escapeHtml(item.id)}${statusLabel}</div>
        `;
        content.addEventListener("click", () => {
          loadDevlabTemplate(item.id);
        });

        row.appendChild(checkbox);
        row.appendChild(content);
        listContainer.appendChild(row);
      });

      updateBulkButtons();
    }

    // Update bulk button states
    function updateBulkButtons() {
      const hasSelection = devlabSelection.size > 0;
      if (bulkDeleteBtn) bulkDeleteBtn.disabled = !hasSelection;
      if (bulkArchiveBtn) bulkArchiveBtn.disabled = !hasSelection;
      if (bulkRestoreBtn) bulkRestoreBtn.disabled = !hasSelection;
      if (bulkDuplicateBtn) bulkDuplicateBtn.disabled = !hasSelection;
    }

    // Status toggle
    if (statusButtons) {
      statusButtons.forEach(btn => {
        btn.addEventListener("click", () => {
          const mode = btn.dataset.mode;
          devlabStatusMode = mode;
          statusButtons.forEach(b => b.classList.toggle("lib-status-active", b === btn));
          renderDevlabList();
        });
      });
    }

    // Search input
    if (searchInput) {
      searchInput.addEventListener("input", () => {
        renderDevlabList();
      });
    }

    // Group filter
    if (groupFilter) {
      groupFilter.addEventListener("change", () => {
        renderDevlabList();
      });
    }

    // Add new template
    if (addNewBtn) {
      addNewBtn.addEventListener("click", () => {
        const library = getDevlabLibrary();
        const prefix = devlabLibraryType === "replies" ? "reply_" : "phrase_";
        const existingIds = library.map(t => t.id).filter(id => id.startsWith(prefix));
        const numbers = existingIds.map(id => parseInt(id.split("_")[1]) || 0);
        const nextNum = numbers.length > 0 ? Math.max(...numbers) + 1 : library.length + 1;
        const newId = `${prefix}${nextNum}`;

        const defaultGroup = devlabLibraryType === "replies" ? "Opening" : "Empathy";
        const newItem = {
          id: newId,
          group: defaultGroup,
          text: "",
          active: false // starts in waiting room
        };

        library.push(newItem);
        renderRepliesAndPhrasesFromLibrary();
        updateGroupFilter();
        renderDevlabList();
        loadDevlabTemplate(newId);
      });
    }

    // Save changes
    if (editorSave) {
      editorSave.addEventListener("click", () => {
        if (!devlabCurrentId) return;
        const library = getDevlabLibrary();
        const item = library.find(t => t.id === devlabCurrentId);
        if (!item) return;

        item.text = editorText.value.trim();
        item.group = editorGroup.value || item.group;
        item.active = editorActive.checked;

        renderRepliesAndPhrasesFromLibrary();
        renderDevlabList();
        miniAnalysis.textContent = computeMiniJargonSnapshot(item.text);
        previewBox.innerHTML = `<p>${escapeHtml(item.text || "No text yet.")}</p>`;
      });
    }

    // Duplicate current
    if (editorDup) {
      editorDup.addEventListener("click", () => {
        if (!devlabCurrentId) return;
        const library = getDevlabLibrary();
        const item = library.find(t => t.id === devlabCurrentId);
        if (!item) return;

        const prefix = devlabLibraryType === "replies" ? "reply_" : "phrase_";
        const existingIds = library.map(t => t.id).filter(id => id.startsWith(prefix));
        const numbers = existingIds.map(id => parseInt(id.split("_")[1]) || 0);
        const nextNum = numbers.length > 0 ? Math.max(...numbers) + 1 : library.length + 1;
        const newId = `${prefix}${nextNum}`;

        const duplicate = {
          id: newId,
          group: item.group,
          text: item.text + " (copy)",
          active: false // starts in waiting room
        };

        library.push(duplicate);
        renderRepliesAndPhrasesFromLibrary();
        updateGroupFilter();
        renderDevlabList();
        loadDevlabTemplate(newId);
      });
    }

    // Archive / Restore current
    if (editorArch) {
      editorArch.addEventListener("click", () => {
        if (!devlabCurrentId) return;
        const library = getDevlabLibrary();
        const item = library.find(t => t.id === devlabCurrentId);
        if (!item) return;

        item.active = !item.active;
        renderRepliesAndPhrasesFromLibrary();
        renderDevlabList();
        editorActive.checked = item.active;
      });
    }

    // Delete current
    if (editorDelete) {
      editorDelete.addEventListener("click", () => {
        if (!devlabCurrentId) return;
        if (!confirm("Delete this template? This cannot be undone.")) return;

        const library = getDevlabLibrary();
        const index = library.findIndex(t => t.id === devlabCurrentId);
        if (index !== -1) {
          // Phase 19.11: log deletion before removing
          const toDelete = library[index];
          pushDeletionLog(toDelete);
          library.splice(index, 1);
          devlabCurrentId = null;
          
          // Reset editor
          editorTitle.textContent = "Select a template";
          editorGroup.value = "";
          editorText.value = "";
          editorActive.checked = false;
          previewBox.innerHTML = '<p class="preview-placeholder">Your template preview will appear here.</p>';
          miniAnalysis.textContent = "No analysis yet. This will show jargon and UK/US spellings for the current template in later phases.";
          
          editorSave.disabled = true;
          editorDup.disabled = true;
          editorArch.disabled = true;
          editorDelete.disabled = true;
          editorGroup.disabled = true;
          editorText.disabled = true;
          editorActive.disabled = true;

          renderRepliesAndPhrasesFromLibrary();
          updateGroupFilter();
          renderDevlabList();
        }
      });
    }

    // Bulk delete
    if (bulkDeleteBtn) {
      bulkDeleteBtn.addEventListener("click", () => {
        if (devlabSelection.size === 0) return;
        if (!confirm(`Delete ${devlabSelection.size} template(s)? This cannot be undone.`)) return;

        const library = getDevlabLibrary();
        const idsToDelete = Array.from(devlabSelection);
        
        idsToDelete.forEach(id => {
          const index = library.findIndex(t => t.id === id);
          if (index !== -1){
            // Phase 19.11: log deletion before removing
            pushDeletionLog(library[index]);
            library.splice(index, 1);
          }
          if (devlabCurrentId === id) {
            devlabCurrentId = null;
            editorTitle.textContent = "Select a template";
            editorGroup.value = "";
            editorText.value = "";
            editorActive.checked = false;
            previewBox.innerHTML = '<p class="preview-placeholder">Your template preview will appear here.</p>';
            miniAnalysis.textContent = "No analysis yet.";
            editorSave.disabled = true;
            editorDup.disabled = true;
            editorArch.disabled = true;
            editorDelete.disabled = true;
            editorGroup.disabled = true;
            editorText.disabled = true;
            editorActive.disabled = true;
          }
        });

        devlabSelection.clear();
        renderRepliesAndPhrasesFromLibrary();
        updateGroupFilter();
        renderDevlabList();
      });
    }

    // Phase 19.11: copy deletion log to clipboard
    if (delLogCopyBtn){
      delLogCopyBtn.addEventListener("click", () => {
        const text = (Array.isArray(mlcxDeletionLog) && mlcxDeletionLog.length)
          ? mlcxDeletionLog.map(formatDeletionEntry).join("\n")
          : "";
        try {
          if (navigator.clipboard && navigator.clipboard.writeText){
            navigator.clipboard.writeText(text || "");
          } else {
            const temp = document.createElement("textarea");
            temp.value = text || "";
            document.body.appendChild(temp);
            temp.select();
            document.execCommand("copy");
            document.body.removeChild(temp);
          }
        } catch (err) {
          console.warn("Copy deletion log failed", err);
        }
      });
    }

    // Bulk archive
    if (bulkArchiveBtn) {
      bulkArchiveBtn.addEventListener("click", () => {
        if (devlabSelection.size === 0) return;
        const library = getDevlabLibrary();
        devlabSelection.forEach(id => {
          const item = library.find(t => t.id === id);
          if (item) item.active = false;
        });
        devlabSelection.clear();
        renderRepliesAndPhrasesFromLibrary();
        renderDevlabList();
        if (devlabCurrentId) {
          const item = library.find(t => t.id === devlabCurrentId);
          if (item) editorActive.checked = item.active;
        }
      });
    }

    // Bulk restore
    if (bulkRestoreBtn) {
      bulkRestoreBtn.addEventListener("click", () => {
        if (devlabSelection.size === 0) return;
        const library = getDevlabLibrary();
        devlabSelection.forEach(id => {
          const item = library.find(t => t.id === id);
          if (item) item.active = true;
        });
        devlabSelection.clear();
        renderRepliesAndPhrasesFromLibrary();
        renderDevlabList();
        if (devlabCurrentId) {
          const item = library.find(t => t.id === devlabCurrentId);
          if (item) editorActive.checked = item.active;
        }
      });
    }

    // Bulk duplicate
    if (bulkDuplicateBtn) {
      bulkDuplicateBtn.addEventListener("click", () => {
        if (devlabSelection.size === 0) return;
        const library = getDevlabLibrary();
        const itemsToDuplicate = Array.from(devlabSelection).map(id => library.find(t => t.id === id)).filter(Boolean);
        
        const prefix = devlabLibraryType === "replies" ? "reply_" : "phrase_";
        let nextNum = Math.max(...library.map(t => t.id).filter(id => id.startsWith(prefix)).map(id => parseInt(id.split("_")[1]) || 0), 0) + 1;

        itemsToDuplicate.forEach(item => {
          const newId = `${prefix}${nextNum++}`;
          const duplicate = {
            id: newId,
            group: item.group,
            text: item.text + " (copy)",
            active: false
          };
          library.push(duplicate);
        });

        devlabSelection.clear();
        renderRepliesAndPhrasesFromLibrary();
        updateGroupFilter();
        renderDevlabList();
      });
    }

    // Initial render
    updateGroupFilter();
    renderDevlabList();
    // Initial deletion log render
    if (typeof renderDeletionLog === 'function') renderDeletionLog();
  
    // Mark initialised after successful wiring
    devlabView.__libraryEditorInitialised = true;
}


function initDevLabDictionaries() {
    const dictView = document.querySelector('.devlab-view-dict');
    if (!dictView) return;

    const els = {
      meta: document.getElementById('dictMeta'),
  health: document.getElementById('dictHealth'),
      search: document.getElementById('dictSearch'),
      scope: document.getElementById('dictScope'),
      copyView: document.getElementById('dictCopyView'),
      copyJargon: document.getElementById('dictCopyJargon'),
      copyUkus: document.getElementById('dictCopyUkus'),
      copyItem: document.getElementById('dictCopyItem'),
      exportBtn: document.getElementById('dictExportJson'),
      listTitle: document.getElementById('dictListTitle'),
      listHint: document.getElementById('dictListHint'),
      list: document.getElementById('dictList'),
      empty: document.getElementById('dictEmptyState'),
      counts: document.getElementById('dictCounts'),
      detailWrapper: document.getElementById('dictDetailWrapper'),
      detailEmpty: document.getElementById('dictDetailEmpty'),
      detail: document.getElementById('dictDetail'),
      dTitle: document.getElementById('detailTitle'),
      dBadges: document.getElementById('detailBadges'),
      dBody: document.getElementById('detailBody'),
      dNotes: document.getElementById('detailNotes'),
      dPatternsPre: document.getElementById('detailPatternsPre'),
      dExample: document.getElementById('detailExample'),
      dSnippet: document.getElementById('detailCopySnippet'),
      dCopyBtn: document.getElementById('detailCopyBtn'),
      filterUkusType: document.getElementById('filterUkusType'),
    };

    const state = {
      section: 'jargon',
      jargonSev: 'ALL',
      search: '',
      scope: 'all',
      selectedKey: null, // `${kind}:${id}`
    };

    // Dict section switcher (Jargon / UK⇄US)
    const sectionBtns = Array.from(dictView.querySelectorAll('[data-dict-section]'));
    // Register click handlers for each section button to switch view
    sectionBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        const next = (btn.dataset.dictSection || '').trim();
        if (!next || next === state.section) return;
        state.section = next;
        state.selectedKey = null;
        // Toggle active states on buttons
        sectionBtns.forEach(b => b.classList.toggle('is-active', b === btn));
        showDetailEmpty();
        updateCounts();
        renderList();
      });
    });

    // Top‑bar wiring: hook search, scope and copy actions once (not inside forEach)
    if (els.search) {
      els.search.addEventListener('input', () => {
        state.search = els.search.value || '';
        state.selectedKey = null;
        showDetailEmpty();
        renderList();
      });
    }
    if (els.scope) {
      els.scope.addEventListener('change', () => {
        state.scope = els.scope.value || 'all';
        state.selectedKey = null;
        showDetailEmpty();
        renderList();
      });
    }
    if (els.copyView) {
      els.copyView.addEventListener('click', async () => {
        const payload = buildCopyViewText();
        try {
          const ok = await copyToClipboardRich(payload);
          els.copyView.textContent = ok ? 'Copied' : 'Copy View';
        } catch (e) {
          console.warn('[DevLab] Copy view failed:', e);
          els.copyView.textContent = 'Copy View';
        }
        setTimeout(() => { els.copyView.textContent = 'Copy View'; }, 900);
      });
    }

    function updateDictDebug(extra) {
      window.__dictDebug = {
        activeView: state.section,
        scope: state.scope,
        selectedKey: state.selectedKey,
        gridExists: !!document.getElementById('dictGrid'),
        lastRenderAt: new Date().toISOString(),
        ...(extra || {})
      };
      if (els.health && window.__dictDebug) {
        const dbg = window.__dictDebug;
        els.health.textContent = `view: ${dbg.activeView} • grid: ${dbg.gridExists ? 'ok' : 'missing'} • render: ${dbg.lastRenderAt}`;
      }
    }

    function safeText(v) { return (v == null) ? '' : String(v); }

    function getEngineAssetsSnapshot() {
      const eng = (typeof window !== 'undefined') ? window.ENGINE_ASSETS : null;
      if (eng && typeof eng === 'object') return eng;

      // Fallback: synthesize a minimal engine view from existing globals so the UI still works
      const fallback = { meta: {}, jargon: [], ukus: [] };
      try {
        fallback.jargon = legacyJargonItems().map(it => ({
          id: it.id,
          term: it.term,
          expansion: it.expansion,
          severity: it.severity || 'misc',
          source: it.source || 'AUTO',
          patterns: it.patterns || [],
          examples: it.example ? [it.example] : []
        }));
      } catch (_) {}

      try {
        fallback.ukus = legacyUkusItems().map(it => ({
          id: it.id,
          match: it.pattern || it.us,
          replace: it.replace || it.uk,
          type: it.type || 'misc',
          badge: it.badge || 'AUTO',
          notes: it.notes || ''
        }));
      } catch (_) {}

      return fallback;
    }


    function legacyJargonItems() {
      const arr = (typeof jargonPatterns !== 'undefined' && Array.isArray(jargonPatterns)) ? jargonPatterns : [];
      return arr.map((j, i) => {
        const pat = j.pattern;
        const patSrc = pat && pat.source ? pat.source : safeText(pat);
        let term = safeText(j.term || j.acronym || j.word || '');
        if (!term) {
          const m = patSrc.match(/\b([A-Za-z0-9]{2,})\b/);
          term = m ? m[1] : (patSrc ? patSrc.replace(/\W+/g, ' ').trim().slice(0, 24) : `jargon_${i+1}`);
        }
        const sev = (j.severity || 'HIGH');
        return {
          kind: 'jargon',
          id: j.id || `legacy_jargon_${i}`,
          term,
          severity: sev,
          expansion: safeText(j.suggestion || j.expansion || ''),
          notes: safeText(j.note || j.notes || ''),
          patterns: [patSrc || safeText(pat)],
          example: (j.example || (j.examples && j.examples[0]) || ''),
        };
      });
    }

    function engineJargonItems() {
      const eng = getEngineAssetsSnapshot();
      if (!eng || !Array.isArray(eng.jargon)) return legacyJargonItems();
      return eng.jargon.map((j, i) => ({
        kind: 'jargon',
        id: j.id || `eng_jargon_${i}`,
        term: safeText(j.term),
        severity: j.severity || 'HIGH',
        expansion: safeText(j.expansion),
        notes: safeText(j.notes),
        patterns: Array.isArray(j.patterns) ? j.patterns.map(safeText) : [],
        example: (j.examples && j.examples[0]) ? safeText(j.examples[0]) : safeText(j.example || ''),
      }));
    }

    function legacyUkusItems() {
      const out = [];
      if (typeof UKUS_RULES !== 'undefined' && UKUS_RULES && Array.isArray(UKUS_RULES.autoReplace)) {
        UKUS_RULES.autoReplace.forEach((r, i) => {
          const pat = r.pattern;
          const patSrc = pat && pat.source ? pat.source : safeText(pat);
          const rep = (typeof r.replacement === 'function') ? '[function]' : safeText(r.replacement);
          out.push({
            kind: 'ukus',
            id: r.id || `auto_${i}`,
            uk: rep,
            us: patSrc,
            type: r.type || 'misc',
            notes: 'Auto-replace rule (UK preferred).',
            patterns: [patSrc],
            badge: 'AUTO',
            example: '',
          });
        });
      }
      if (typeof UKUS_RULES !== 'undefined' && UKUS_RULES && Array.isArray(UKUS_RULES.manualCheck)) {
        UKUS_RULES.manualCheck.forEach((p, i) => {
          out.push({
            kind: 'ukus',
            id: p.id || `manual_${i}`,
            uk: safeText(p.uk),
            us: safeText(p.us),
            type: p.type || 'misc',
            notes: safeText(p.notes || 'Manual check (flag if US form used).'),
            patterns: [safeText(p.us)],
            badge: 'MANUAL',
            example: '',
          });
        });
      }
      return out;
    }

    function engineUkusItems() {
      const eng = getEngineAssetsSnapshot();
      const prettyToken = (s) => {
        if (!s) return '';
        return String(s)
          .replace(/\u0008/g, '\\b')
          .replace(/\\b/g, '\\b')
          .replace(/\\/g, '')
          .replace(/\s\+/g, ' ')
          .replace(/\(\?:/g, '(')
          .replace(/\)/g, ')')
          .replace(/\|/g, ' | ')
          .replace(/\s+/g, ' ')
          .trim();
      };

      return (eng.ukus || []).map((p, i) => {
        const mode = String(p.mode || p.badge || '').toUpperCase() === 'MANUAL' ? 'MANUAL' : 'AUTO';
        const matchVal = p.match?.value || p.pattern || p.us || '';
        const replaceType = p.replace?.type || (p.fn ? 'fn' : 'literal');
        const replaceVal = p.replace?.value || p.fn || p.uk || p.replacement || '';

        const rawUs = String(matchVal || '');
        const rawUk = (String(replaceType).toLowerCase() === 'fn') ? `[function] ${replaceVal}` : String(replaceVal || '');

        return {
          kind: 'ukus',
          id: p.id || `eng_ukus_${i}`,
          us: safeText(rawUs),
          uk: safeText(rawUk),
          usDisplay: prettyToken(rawUs),
          ukDisplay: prettyToken(rawUk),
          type: p.category || p.type || 'misc',
          notes: safeText(p.notes || (mode === 'AUTO' ? 'Auto rule (UK preferred).' : 'Manual check (flag if US form used).')),
          patterns: [safeText(rawUs)],
          badge: mode,
          example: Array.isArray(p.examples) ? safeText(p.examples[0] || '') : '',
        };
      });
    }

    function legacySafeWordsItems() {
      const words = [];
      if (typeof SAFE_WORDS !== 'undefined') {
        try {
          if (Array.isArray(SAFE_WORDS)) words.push(...SAFE_WORDS);
          else if (SAFE_WORDS instanceof Set) words.push(...Array.from(SAFE_WORDS));
        } catch(e) {}
      }
      return words.sort((a,b)=>String(a).localeCompare(String(b))).map((w, i) => ({
        kind: 'safewords',
        id: `sw_${i}`,
        term: safeText(w),
        notes: 'Safe word / allowlist term.',
        patterns: [safeText(w)],
      }));
    }

    function engineSafeWordsItems() {
      const eng = getEngineAssetsSnapshot();
      if (!eng || !Array.isArray(eng.safeWords)) return legacySafeWordsItems();
      return eng.safeWords.map((w, i) => ({
        kind: 'safewords',
        id: w.id || `eng_sw_${i}`,
        term: safeText(w.term),
        notes: safeText(w.notes || 'Safe word / allowlist term.'),
        patterns: [safeText(w.term)],
      }));
    }

    function legacyCoachingItems() {
      return [];
    }

    function getSectionItems(section) {
      switch(section) {
        case 'jargon': return engineJargonItems();
        case 'ukus': return engineUkusItems();
        default: return [];
      }
    }

    function applyFilters(items) {
      let out = items.slice();

      // scope filter (topbar) - if not "all" it overrides section
      if (state.scope && state.scope !== 'all') {
        out = out.filter(it => it.kind === state.scope);
      }

      // section-specific filters (none active for Phase B minimal view)

      // search filter
      const q = state.search.trim().toLowerCase();
      if (q) {
        out = out.filter(it => {
          const hay = [
            it.term, it.uk, it.us, it.expansion, it.notes,
            (it.patterns || []).join(' '),
            it.severity, it.type, it.badge
          ].map(safeText).join(' ').toLowerCase();
          return hay.includes(q);
        });
      }

      return out;
    }

    function setFiltersVisibility(section) {
      dictView.querySelectorAll('.dictFilterBlock').forEach(b => {
        const forSect = b.getAttribute('data-filter-for');
        b.style.display = (forSect === section) ? '' : 'none';
      });
    }

    function updateCounts() {
      const jargonCount = engineJargonItems().length;
      const ukusCount = engineUkusItems().length;

      els.counts.textContent = `Jargon: ${jargonCount} • UKUS: ${ukusCount}`;
      els.meta.textContent = `Loaded: ENGINE_ASSETS • Jargon ${jargonCount} • UKUS ${ukusCount} • Updated: ${new Date().toLocaleString()}`;

      updateDictDebug({ counts: { jargon: jargonCount, ukus: ukusCount } });
    }

    function renderList() {
      setFiltersVisibility(state.section);

      // Update title
      let title = '';
      if (state.section === 'jargon') title = `Jargon`;
      else if (state.section === 'ukus') title = `UK ⇄ US`;
      els.listTitle.textContent = title;

      // Get items
      const base = (state.section === 'all') ? [] : getSectionItems(state.section);
      const items = applyFilters(base);

      // Clear list
      els.list.innerHTML = '';

      if (!items.length) {
        els.empty.style.display = '';
      } else {
        els.empty.style.display = 'none';
      }

      items.forEach(it => {
        const row = document.createElement('button');
        row.type = 'button';
        row.className = 'dictItem';
        row.dataset.dictId = it.id;
        row.dataset.dictKind = it.kind;

        const left = document.createElement('div');
        const primary = document.createElement('div');
        primary.className = 'dictItemPrimary';
        primary.textContent = it.kind === 'ukus'
          ? `${safeText(it.usDisplay || it.us)} → ${safeText(it.ukDisplay || it.uk)}`
          : safeText(it.term || it.id);

        const secondary = document.createElement('div');
        secondary.className = 'dictItemSecondary';
        if (it.kind === 'jargon') secondary.textContent = safeText(it.expansion || it.notes || '');
        else if (it.kind === 'ukus') secondary.textContent = safeText(it.type || it.badge || '');
        else secondary.textContent = safeText(it.notes || '');

        left.appendChild(primary);
        left.appendChild(secondary);

        const badge = document.createElement('div');
        badge.className = 'dictItemBadge';
        badge.textContent = safeText(it.badge || it.type || '');
        if (!badge.textContent.trim()) badge.style.display = 'none';

        row.appendChild(left);
        row.appendChild(badge);

        // Tooltip for quick clarity
        if (it.kind === 'jargon') {
          row.title = `${safeText(it.term)} → ${safeText(it.expansion || '(no expansion)')}${it.notes ? ` - ${safeText(it.notes)}` : ''}`;
        } else if (it.kind === 'ukus') {
          row.title = `Prefer UK: ${safeText(it.ukDisplay || it.uk)} (avoid US: ${safeText(it.usDisplay || it.us)}) ${it.notes ? '- ' + safeText(it.notes) : ''}`;
        }

        const key = `${it.kind}:${it.id}`;
        if (state.selectedKey === key) row.classList.add('is-selected');

        row.addEventListener('click', () => {
          state.selectedKey = key;
          renderList();
          renderDetail(it);
        });

        els.list.appendChild(row);
      });

      // reset detail if selection no longer visible
      if (state.selectedKey && !items.some(it => `${it.kind}:${it.id}` === state.selectedKey)) {
        state.selectedKey = null;
        showDetailEmpty();
      }

      // enable copy view if items exist
      els.copyItem.disabled = !state.selectedKey;

      updateDictDebug({ visibleCount: items.length });
    }

    function chip(text) {
      const span = document.createElement('span');
      span.className = 'chip';
      span.textContent = text;
      return span;
    }

    function showDetailEmpty() {
      els.detailEmpty.style.display = '';
      els.detail.style.display = 'none';
      if (els.detailWrapper) els.detailWrapper.scrollTop = 0;
      els.copyItem.disabled = true;
    }

    function renderDetail(it) {
      els.detailEmpty.style.display = 'none';
      els.detail.style.display = '';
      if (els.detailWrapper) els.detailWrapper.scrollTop = 0;

      els.dTitle.textContent = it.kind === 'ukus'
        ? `${safeText(it.usDisplay || it.us)} → ${safeText(it.ukDisplay || it.uk)}`
        : safeText(it.term || it.id);

      els.dBadges.innerHTML = '';
      if (it.kind === 'jargon') els.dBadges.appendChild(chip('JARGON'));
      if (it.kind === 'ukus') {
        els.dBadges.appendChild(chip(it.badge || 'UKUS'));
        els.dBadges.appendChild(chip(it.type || 'misc'));
      }

      els.dBody.textContent = it.kind === 'jargon'
        ? safeText(it.expansion || '-')
        : it.kind === 'ukus'
          ? `Prefer UK spelling: “${safeText(it.ukDisplay || it.uk)}” (avoid US: “${safeText(it.usDisplay || it.us)}”).`
          : safeText(it.term || '-');

      els.dNotes.textContent = safeText(it.notes || '-');
      els.dPatternsPre.textContent = (it.patterns && it.patterns.length) ? it.patterns.join('\n') : '-';
      els.dExample.textContent = safeText(it.example || '-');

      // snippet
      if (it.kind === 'jargon') {
        const snippet = it.expansion ? `${safeText(it.expansion)} (${safeText(it.term)})` : safeText(it.term);
        els.dSnippet.value = `Use once like: “${snippet}”`;
      } else if (it.kind === 'ukus') {
        els.dSnippet.value = `Use UK spelling: ${safeText(it.ukDisplay || it.uk)}`;
      } else {
        els.dSnippet.value = safeText(it.term || '');
      }

      els.copyItem.disabled = false;
    }

    // Helper: normalize regex source string
    function normalizeRegexSource(src) {
      return String(src || "")
        .replace(/\\b/g, "")
        .replace(/^\^|\$$/g, "")
        .trim();
    }

    // Helper: turn a pattern/source into test tokens
    function makeTestTokensFromPattern(src) {
      const s0 = normalizeRegexSource(src);
      if (!s0 || s0.length < 2) return []; // Skip single chars

      // If it looks like a plain word already (3+ letters)
      if (!/[(\[\]|?+*\\]/.test(s0) && s0.length >= 3) {
        return [s0, s0 + "s", s0 + "ed", s0 + "ing", s0 + "d"].filter(t => t.length >= 3);
      }

      // Base token: take leading word chars until a meta char (must be 3+ letters)
      const baseMatch = s0.match(/^[a-zA-Z]{3,}/);
      const base = baseMatch ? baseMatch[0] : "";
      if (!base || base.length < 3) return [];

      const out = new Set([base]);

      // Handle simple char class like organi[sz]e or colo[u]?r
      const cc = s0.match(/^([a-zA-Z]{2,})\[([a-zA-Z]{1,3})\]\??([a-zA-Z]*)$/);
      if (cc) {
        const pre = cc[1], chars = cc[2].split(""), post = cc[3];
        chars.forEach(ch => {
          const variant = pre + ch + post;
          if (variant.length >= 3) {
            out.add(variant);
            out.add(variant + "s");
            out.add(variant + "ed");
            out.add(variant + "ing");
          }
        });
        // Also add version without the optional char
        if (s0.includes("?")) {
          const noOptional = pre + post;
          if (noOptional.length >= 3) {
            out.add(noOptional);
            out.add(noOptional + "s");
          }
        }
        return Array.from(out).filter(t => t.length >= 3);
      }

      // Handle alternation patterns: (or|our), (er|re), etc.
      const alt = s0.match(/^([a-zA-Z]{2,})\(([^)]+)\)([a-zA-Z]*)$/);
      if (alt) {
        const pre = alt[1], options = alt[2].split("|"), post = alt[3];
        options.forEach(opt => {
          const variant = pre + opt + post;
          if (variant.length >= 3) {
            out.add(variant);
            out.add(variant + "s");
            out.add(variant + "ed");
            out.add(variant + "ing");
          }
        });
        return Array.from(out).filter(t => t.length >= 3);
      }

      // Standard verb forms for base
      out.add(base + "s");
      out.add(base + "ed");
      out.add(base + "ing");
      if (base.endsWith("e")) out.add(base + "d");

      return Array.from(out).filter(t => t.length >= 3);
    }

    // Helper: build copy blob from token list
    function makeCopyBlob(lines) {
      return Array.from(new Set(lines.map(s => String(s).trim()).filter(Boolean)))
        .sort((a,b) => a.localeCompare(b))
        .join(" ");
    }

    
    function escapeHtml(str) {
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    async function copyToClipboardRich(text) {
      const payload = (text ?? '').toString();
      if (!payload.trim()) return false;

      // Provide BOTH plain-text + HTML so rich editors keep line breaks
      const html = `<pre style="white-space:pre-wrap;margin:0;font:inherit;">${escapeHtml(payload)}</pre>`;

      try {
        if (navigator.clipboard && navigator.clipboard.write && typeof ClipboardItem !== 'undefined') {
          const item = new ClipboardItem({
            'text/plain': new Blob([payload], { type: 'text/plain' }),
            'text/html': new Blob([html], { type: 'text/html' }),
          });
          await navigator.clipboard.write([item]);
          return true;
        }
      } catch (e) {
        // fall through to plain-text copy
      }
      return await copyToClipboard(payload);
    }

async function copyToClipboard(text) {
      const payload = (text ?? '').toString();
      if (!payload.trim()) return false;
      try {
        await navigator.clipboard.writeText(payload);
        return true;
      } catch(e) {
        try {
          const ta = document.createElement('textarea');
          ta.value = payload;
          ta.style.position = 'fixed';
          ta.style.left = '-9999px';
          document.body.appendChild(ta);
          ta.focus(); ta.select();
          const ok = document.execCommand('copy');
          document.body.removeChild(ta);
          return !!ok;
        } catch(_) { return false; }
      }
    }

    function buildCopyViewText() {
      const base = getSectionItems(state.section);
      const items = applyFilters(base);
      const header = `Dictionaries - ${state.section.toUpperCase()} (${items.length})`;
      const lines = [header, ''];
      items.forEach(it => {
        if (it.kind === 'jargon') lines.push(`• ${it.term} → ${it.expansion || '(no expansion)'}`);
        else if (it.kind === 'ukus') lines.push(`• ${it.usDisplay || it.us} → ${it.ukDisplay || it.uk} (${it.type || it.badge || 'misc'})`);
        else lines.push(`• ${it.term || it.id}`);
      });
      return lines.join('\r\n');
    }

    function buildCopySectionText(section) {
      // Copy should be paste-safe and "clean" (no bullets, no smart quotes).
      const eng = (typeof window !== 'undefined') ? window.ENGINE_ASSETS : null;

      if (section === 'ukus') {
        // Prefer a clean "base pairs" list for copy/paste (what the checker is designed to flag),
        // not raw regex patterns. This keeps the output human-readable and paste-safe.
        const out = [];
        const seen = new Set();

        function pushPair(us, uk) {
          const a = (us ?? '').toString().trim();
          const b = (uk ?? '').toString().trim();
          if (!a || !b) return;
          const key = (a.toLowerCase() + '->' + b.toLowerCase());
          if (seen.has(key)) return;
          seen.add(key);
          out.push(`${a} -> ${b}`);
        }

        // 1) Canonical pairs (most reliable for "base list")
        if (window.ENGINE_UKUS_CANONICAL && Array.isArray(window.ENGINE_UKUS_CANONICAL)) {
          window.ENGINE_UKUS_CANONICAL.forEach(p => {
            if (!p) return;
            pushPair(p.us, p.uk);
          });
        }

        // 2) Literal pairs inside ENGINE_ASSETS.ukus (in case canonical isn't present / differs)
        // Supports both legacy {us,uk} items and newer {match,replace} items (regex-ish).
        const arr = (eng && Array.isArray(eng.ukus)) ? eng.ukus : [];

        function _simplifyRegexWordPattern(pat) {
          // Turn things like "\bmeter(s)?\b" into {base:"meter", plural:true}
          const raw = String(pat || '');
          let s = raw.replace(/\\b/g, '').replace(/^\^|\$$/g, '').trim();
          // strip leading/trailing grouping wrappers
          s = s.replace(/^\(/, '(').replace(/\)$/, ')');
          // Only handle simple "word(s)?" plural + plain words.
          const m = s.match(/^([A-Za-z]+)\(s\)\?$/) || s.match(/^([A-Za-z]+)\(s\)\?$/);
          if (m) return { base: m[1], plural: true };
          // Common pattern: word(s)? with escaped parens already removed
          const m2 = s.match(/^([A-Za-z]+)\(s\)\?$/);
          if (m2) return { base: m2[1], plural: true };
          // Alternate: "meter(s)?"
          const m3 = s.match(/^([A-Za-z]+)\(s\)\?$/);
          if (m3) return { base: m3[1], plural: true };
          // Best-effort: remove common regex tokens and keep letters only
          const letters = s.replace(/\(\?:.*?\)/g,'').replace(/\(.*?\)/g,'').replace(/[^A-Za-z]/g,'');
          if (letters) return { base: letters, plural: false };
          return null;
        }

        function _simplifyReplacement(rep, isPlural) {
          // For "metre$1" with optional (s) capture, return "metre" or "metres"
          const r = String(rep || '').replace(/\$\d+/g, '').trim();
          if (!isPlural) return r;
          // If replacement already ends with 's', keep it; else add 's'
          if (!r) return r;
          return r.endsWith('s') ? r : (r + 's');
        }

        arr.forEach(item => {
          if (!item) return;

          // Legacy literal style
          if (item.us && item.uk) {
            pushPair(item.us, item.uk);
            return;
          }

          // Newer style: {match, replace}
          if (item.match && item.replace) {
            const simp = _simplifyRegexWordPattern(item.match);
            if (!simp || !simp.base) return;
            const ukBase = _simplifyReplacement(item.replace, false);
            if (ukBase) pushPair(simp.base, ukBase);

            if (simp.plural) {
              const ukPlural = _simplifyReplacement(item.replace, true);
              if (ukPlural) pushPair(simp.base + 's', ukPlural);
            }
            return;
          }

          // Fallback: previous type-based literal gate (kept for compatibility)
          const type = String(item.type || 'literal').toLowerCase();
          if (type === 'literal') {
            pushPair(item.us, item.uk);
          }
        });


        // 3) A few "derived base pairs" for regex/function families (so they show up in a base list)
        // This is intentionally conservative to avoid producing misleading mappings.
        arr.forEach(item => {
          if (!item) return;
          const type = String(item.type || '').toLowerCase();
          if (type === 'function') {
            const p = String(item.pattern || '');
            // Common -ize families: show base + a couple common inflections
            if (p.includes('organize')) { pushPair('organize','organise'); pushPair('organized','organised'); pushPair('organizing','organising'); }
            if (p.includes('recognize')) { pushPair('recognize','recognise'); pushPair('recognized','recognised'); pushPair('recognizing','recognising'); }
            if (p.includes('realize')) { pushPair('realize','realise'); pushPair('realized','realised'); pushPair('realizing','realising'); }
            if (p.includes('apologize')) { pushPair('apologize','apologise'); pushPair('apologized','apologised'); pushPair('apologizing','apologising'); }
            if (p.includes('criticize')) { pushPair('criticize','criticise'); pushPair('criticized','criticised'); pushPair('criticizing','criticising'); }
            if (p.includes('authorize')) { pushPair('authorize','authorise'); pushPair('authorized','authorised'); pushPair('authorizing','authorising'); }
            if (p.includes('specialize')) { pushPair('specialize','specialise'); pushPair('specialized','specialised'); pushPair('specializing','specialising'); }
            if (p.includes('privatize')) { pushPair('privatize','privatise'); pushPair('privatized','privatised'); pushPair('privatizing','privatising'); }
            if (p.includes('analyz')) { pushPair('analyze','analyse'); pushPair('analyzed','analysed'); pushPair('analyzing','analysing'); pushPair('analyzer','analyser'); }
          }
          if (type === 'regex') {
            const pat = String(item.pattern || '');
            // Double-L families
            if (pat.includes('travel(')) { pushPair('traveling','travelling'); pushPair('traveled','travelled'); pushPair('traveler','traveller'); }
            if (pat.includes('cancel(')) { pushPair('canceled','cancelled'); pushPair('canceling','cancelling'); }
            if (pat.includes('fuel(')) { pushPair('fueled','fuelled'); pushPair('fueling','fuelling'); }
            if (pat.includes('model(')) { pushPair('modeled','modelled'); pushPair('modeling','modelling'); pushPair('modeler','modeller'); }
            if (pat.includes('meter')) { pushPair('meter','metre'); pushPair('meters','metres'); }
            if (pat.includes('defense')) { pushPair('defense','defence'); pushPair('defenses','defences'); }
            if (pat.includes('offense')) { pushPair('offense','offence'); pushPair('offenses','offences'); }
            if (pat.includes('pretense')) { pushPair('pretense','pretence'); pushPair('pretenses','pretences'); }
          }
        });

        // NOTE: Some paste/sanitizer pipelines can strip newlines without inserting
        // spaces, which would concatenate items (e.g., "organiseorganised").
        // We add a trailing space before each newline so even if newlines are stripped,
        // items remain separated.
        return out
          .sort((a,b) => a.localeCompare(b))
          .map(line => `${line} `)
          .join('\r\n')
          .trim();
      }

      if (section === 'jargon') {
        const arr = (eng && Array.isArray(eng.jargon)) ? eng.jargon : [];
        return arr
          .map(item => {
            if (!item) return '';
            const term = item.term ? String(item.term) : '';
            const exp = item.expansion ? String(item.expansion) : '';
            return exp ? `${term} -> ${exp}` : term;
          })
          .filter(Boolean)
          .sort((a,b) => a.localeCompare(b))
          .map(line => `${line} `)
          .join('\r\n')
          .trim();
      }

      // Fallback: keep a short demo (so copy buttons still do something even if engine missing)
      if (section === 'demo') {
        return `Hi, I need help with my claim.\n\nThanks for reaching out — I can help. Could you confirm your policy number and the date of loss?`;
      }

      return '';
    }

if (els.copyJargon) {
      els.copyJargon.addEventListener('click', async () => {
        const ok = await copyToClipboard(buildCopySectionText('jargon'));
        els.copyJargon.textContent = ok ? 'Copied' : 'Copy Paste-Test (Jargon)';
        setTimeout(() => els.copyJargon.textContent = 'Copy Paste-Test (Jargon)', 850);
      });
    }

    if (els.copyUkus) {
      els.copyUkus.addEventListener('click', async () => {
        const payload = `US → UK

color → colour
flavor → flavour
honor → honour
labor → labour
neighbor → neighbour
behavior → behaviour
humor → humour
vigor → vigour
odor → odour
rumor → rumour

organize → organise
recognize → recognise
realize → realise
apologize → apologise
criticize → criticise
authorize → authorise
specialize → specialise
organization → organisation
globalization → globalisation
privatize → privatise

center → centre
meter → metre
fiber → fibre
liter → litre
somber → sombre
theater → theatre

dialog → dialogue
catalog → catalogue
analog → analogue
monolog → monologue
prolog → prologue

traveling → travelling
traveler → traveller
canceled → cancelled
canceling → cancelling
fueled → fuelled
modeling → modelling
jewelry → jewellery

defense → defence
license → licence
pretense → pretence
offense → offence

estrogen → oestrogen
pediatric → paediatric
encyclopedia → encyclopaedia
fetus → foetus
maneuver → manoeuvre

check → cheque
paycheck → pay cheque
checker → chequer

gray → grey
curb → kerb
tire → tyre
draft → draught
plow → plough
mold → mould
mustache → moustache
program → programme
sulfur → sulphur
aluminum → aluminium
diarrhea → diarrhoea
checkmark → tick
stroller → pushchair
apartment → flat
cookie → biscuit

If you want:
- US-only list
- UK-only list
- one-word-per-line version
- grouped vs fully flat`;
        const ok = await copyToClipboardRich(payload);
        els.copyUkus.textContent = ok ? 'Copied' : 'Copy Paste-Test (UK⇄US)';
        setTimeout(() => els.copyUkus.textContent = 'Copy Paste-Test (UK⇄US)', 900);
      });
}

    els.copyItem.addEventListener('click', async () => {
      const txt = els.dSnippet.value || '';
      const ok = await copyToClipboard(txt);
      els.copyItem.textContent = ok ? 'Copied' : 'Copy Item';
      setTimeout(() => els.copyItem.textContent = 'Copy Item', 850);
    });

    els.dCopyBtn.addEventListener('click', async () => {
      const txt = els.dSnippet.value || '';
      const ok = await copyToClipboard(txt);
      els.dCopyBtn.textContent = ok ? 'Copied' : 'Copy snippet';
      setTimeout(() => els.dCopyBtn.textContent = 'Copy snippet', 850);
    });

    // Initial
    updateCounts();
    showDetailEmpty();
    renderList();

</script>
  <div class="dev-header" style="margin-bottom:16px;display:flex;justify-content:space-between;align-items:flex-start;">
    <div>
      <h3 class="dev-title">DEV LAB</h3>
      <p class="dev-desc">Internal development tools for debugging MLCX analysis, testing demo scenarios, and managing templates.</p>
    </div>
    <button type="button" id="devLabDiceBtn" class="mlcx-dice-btn" aria-label="Load random demo scenario" title="Load random demo scenario">🎲</button>
  </div>

  <div class="devlab-toggle-row">
    <button type="button" class="devlab-toggle-btn" data-view="mlcx">MLCX DEBUG</button>
    <button type="button" class="devlab-toggle-btn" data-view="editor">LIBRARY EDITOR</button>
    
    <button type="button" class="devlab-toggle-btn" data-view="lib2">LIBRARY 2.0</button>
<button type="button" class="devlab-toggle-btn" data-view="dict">DICTIONARIES</button>
    <button type="button" class="devlab-toggle-btn" data-view="dict2">DICTIONARIES 2.0</button>
  </div>
  <div class="devlab-view devlab-view-dict" data-dev-view="dict" style="display:none;">
    <div id="dictTopbar">
      <div class="dictTopbarLeft">
        <h3 id="dictTitle">Dictionaries</h3>
        <div id="dictMeta">Loaded: ENGINE_ASSETS • Snapshot pending</div>
        <div id="dictHealth" class="dictTinyNote">Dict health: pending</div>
      </div>
      <div class="dictTopbarRight">
        <input id="dictSearch" type="text" placeholder="Search terms, notes, expansions…" />
        <select id="dictScope">
          <option value="all" selected>all</option>
          <option value="jargon">jargon</option>
          <option value="ukus">ukus</option>
        </select>
        <button id="dictCopyJargon" type="button" title="Copy paste-test tokens for jargon">Copy Paste-Test (Jargon)</button>
        <button id="dictCopyUkus" type="button" title="Copy paste-test tokens for UK⇄US">Copy Paste-Test (UK⇄US)</button>
        <button id="dictCopyView" type="button">Copy View</button>
        <button id="dictCopyItem" type="button" disabled>Copy Item</button>
        <button id="dictExportJson" type="button" disabled title="Phase A: export arrives later">Export JSON</button>
      </div>
    </div>

    <div id="dictGrid">
      <!-- Column 1: Index -->
      <div id="dictIndex" class="dictCard">
        <div class="dictSectionGroup">
          <button type="button" class="dictSectionBtn is-active" data-dict-section="jargon">Jargon</button>
          <button type="button" class="dictSectionBtn" data-dict-section="ukus">UK ⇄ US</button>
        </div>

        <div id="dictFilters" class="dictFilters">
          <!-- Jargon filters -->
          <div class="dictFilterBlock" data-filter-for="jargon" style="display:none;"></div>
          <div class="dictFilterBlock" data-filter-for="ukus" style="display:none;"></div>
        </div>

        <div id="dictCounts" class="dictCounts">Counts loading…</div>
      </div>

      <!-- Column 2: List -->
      <div id="dictListPanel" class="dictCard">
        <div class="dictListHeader">
          <div id="dictListTitle">Jargon - HIGH</div>
          <div id="dictListHint">Click an item to view details</div>
        </div>
        <div id="dictList" class="dictList"></div>
        <div id="dictEmptyState" class="dictEmpty" style="display:none;">No matches.</div>
      </div>

      <!-- Column 3: Details -->
      <div id="dictDetailPanel" class="dictCard">
        <div id="dictDetailWrapper" style="overflow:auto; height:100%; padding-right:4px;">
          <div id="dictDetailEmpty" class="dictEmpty">Select an item to view details.</div>

          <div id="dictDetail" style="display:none;">
          <div id="detailTitle" class="detailTitle">-</div>
          <div id="detailBadges" class="detailBadges"></div>

          <div class="detailBlock">
            <div class="detailLabel">Definition / Expansion</div>
            <div id="detailBody" class="detailBody">-</div>
          </div>

          <div class="detailBlock">
            <div class="detailLabel">Notes</div>
            <div id="detailNotes" class="detailNotes">-</div>
          </div>

          <details id="detailPatterns" class="detailPatterns">
            <summary>Patterns</summary>
            <pre id="detailPatternsPre" class="detailPre">-</pre>
          </details>

          <div class="detailBlock">
            <div class="detailLabel">Example</div>
            <div id="detailExample" class="detailExample">-</div>
          </div>

          <div class="detailBlock">
            <div class="detailLabel">Copy-ready snippet</div>
            <textarea id="detailCopySnippet" readonly rows="3"></textarea>
            <button id="detailCopyBtn" type="button">Copy snippet</button>
          </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  
<div class="devlab-view devlab-view-mlcx" data-dev-view="mlcx">
    <div class="dev-container">
      <div class="dev-left">
      
      <!-- MLCX Summary Debug -->
      <div style="margin-bottom:18px;">
        <h4 style="font-size:0.76rem;font-weight:600;text-transform:uppercase;letter-spacing:0.08em;color:var(--text-main);margin-bottom:8px;">MLCX State Summary</h4>
        <pre id="devMlcxSummary" class="dev-pre">No MLCX analysis yet. Type in any text area to trigger analysis.</pre>
      </div>

      <!-- Demo Text Blocks -->
      <div>
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
          <h4 style="font-size:0.76rem;font-weight:600;text-transform:uppercase;letter-spacing:0.08em;color:var(--text-main);margin:0;">Demo Scenarios</h4>
          <button type="button" id="devShuffleScenarioBtn" class="dev-shuffle-btn" title="Shuffle demo scenario" aria-label="Shuffle demo scenario">🔀</button>
        </div>
        <div id="devDemoBlocks"></div>
      </div>
    </div>
    
    <div class="dev-right">

      <div class="dev-card" id="devHealthCard">
        <div class="dev-card-header">
          <span>Health Check</span>
          <span id="devHealthStatus" class="dev-health-badge">OK</span>
        </div>
        <div class="dev-health-grid">
          <div class="dev-health-item">
            <div class="dev-health-label">Listeners wired</div>
            <div id="devHealthListeners" class="dev-health-value">-</div>
          </div>
          <div class="dev-health-item">
            <div class="dev-health-label">Safe mode</div>
            <div id="devHealthSafeMode" class="dev-health-value">OFF</div>
          </div>
          <div class="dev-health-item">
            <div class="dev-health-label">Last recompute</div>
            <div id="devHealthLastRecompute" class="dev-health-value">-</div>
          </div>
          <div class="dev-health-item">
            <div class="dev-health-label">Last input source</div>
            <div id="devHealthLastSource" class="dev-health-value">-</div>
          </div>
        </div>
        <div class="dev-health-actions">
          <button type="button" id="devHealthRunNow" class="fmt-btn" title="Run analysis once">Run analysis</button>
          <button type="button" id="devHealthToggleSafe" class="fmt-btn" title="Toggle safe mode">Toggle safe mode</button>
        </div>
        <div id="devHealthErrors" class="dev-health-errors" style="display:none;"></div>
      </div>

      <div class="dev-card">
        <div class="dev-card-header">
          <span>MLCX Analysis Engine</span>
        </div>
        <p>Real-time debugging for emotion, clarity, CX risk, and safety signal detection across all three text sources (customer, agent, notes).</p>
        <!-- (reverted) no local overrides here -->
        <ul>
          <li>Jargon & Cost Stress Test: Complex insurance terminology</li>
          <li>CiVC & Vulnerability: Mental health, financial, safeguarding triggers</li>
          <li>UK/US Spelling: Common transatlantic spelling variations</li>
        </ul>
        <div style="display:flex;gap:8px;margin-top:12px;">
          <button type="button" id="devCopyJargonTest" class="fmt-btn" style="flex:1;" title="Copy paste-test tokens for jargon">Copy Paste-Test (Jargon)</button>
          <button type="button" id="devCopyUkusTest" class="fmt-btn" style="flex:1;" title="Copy paste-test tokens for UK↔US">Copy Paste-Test (UK↔US)</button>
        </div>
      </div>
      
      <div class="dev-card">
        <div class="dev-card-header">
          <span>Usage Notes</span>
        </div>
        <p>Dev Lab is a dedicated layout mode. Toggle it with Alt + D or Ctrl/Cmd + Shift + D; Messenger is the default view.</p>
        <ul>
          <li>Press Alt + D or Ctrl/Cmd + Shift + D to enter/exit Dev Lab</li>
          <li>Messenger view stays the default split experience</li>
          <li>MLCX state updates automatically from your messenger inputs</li>
        </ul>
      </div>
    </div>
  </div>
  </div>
  
  <div class="devlab-view devlab-view-dict2" data-dev-view="dict2" style="display:none;">
    <div id="dict2Topbar">
      <div class="dictTopbarLeft">
        <h3 id="dict2Title">Dictionaries 2.0</h3>
        <div id="dict2Meta">View-only • Source: auto-detect</div>
        <div id="dict2Health" class="dictTinyNote">Ready</div>
      </div>
      <div class="dictTopbarRight">
        <input id="dict2Search" type="text" placeholder="Search terms, notes, expansions…" />
        <select id="dict2Section">
          <option value="ukus" selected>UK ⇄ US</option>
          <option value="jargon">Jargon</option>
        </select>
        <select id="dict2UkusDirection" title="Direction">
          <option value="US->UK" selected>US → UK</option>
          <option value="UK->US">UK → US</option>
        </select>
        <button id="dict2CopyList" type="button" title="Copy clean list">Copy List</button>
        <button id="dict2CopyJSON" type="button" title="Copy filtered JSON">Copy JSON</button>
        <button id="dict2CopyBundle" type="button" title="Copy combined bundle">Copy Bundle</button>
        <button id="dict2ExportJson" type="button" title="Download JSON snapshot">Export JSON</button>
      </div>
    </div>

    <div id="dict2Grid">
      <!-- Column 1: Index -->
      <div id="dict2Index" class="dictCard">
        <div class="dictSectionGroup">
          <button type="button" class="dict2SectionBtn is-active" data-d2-section="ukus">UK ⇄ US</button>
          <button type="button" class="dict2SectionBtn" data-d2-section="jargon">Jargon</button>
        </div>
        <div id="dict2Counts" class="dictCounts">Counts loading…</div>
        <div id="dict2Hint" class="dictTinyNote" style="margin-top:10px;">View-only. Uses engine/legacy data without mutating anything.</div>
      </div>

      <!-- Column 2: List -->
      <div id="dict2ListPanel" class="dictCard">
        <div class="dictListHeader">
          <div id="dict2ListTitle">UK ⇄ US</div>
          <div id="dict2ListHint">Click an item to view details</div>
        </div>
        <div id="dict2List" class="dictList"></div>
        <div id="dict2EmptyState" class="dictEmpty" style="display:none;">No matches.</div>
      </div>

      <!-- Column 3: Details -->
      <div id="dict2DetailPanel" class="dictCard">
        <div id="dict2DetailWrapper" style="overflow:auto; height:100%; padding-right:4px;">
          <div id="dict2DetailEmpty" class="dictEmpty">Select an item to view details.</div>

          <div id="dict2Detail" style="display:none;">
            <div id="dict2DetailTitle" class="detailTitle">-</div>
            <div id="dict2DetailBadges" class="detailBadges"></div>

            <div class="detailBlock">
              <div class="detailLabel">Definition / Expansion</div>
              <div id="dict2DetailBody" class="detailBody">-</div>
            </div>

            <div class="detailBlock">
              <div class="detailLabel">Notes</div>
              <div id="dict2DetailNotes" class="detailNotes">-</div>
            </div>

            <details id="dict2DetailPatterns" class="detailPatterns">
              <summary>Patterns</summary>
              <pre id="dict2DetailPatternsPre" class="detailPre">-</pre>
            </details>

            <div class="detailBlock">
              <div class="detailLabel">Copy-ready snippet</div>
              <textarea id="dict2CopySnippet" readonly rows="3"></textarea>
              <button id="dict2CopySnippetBtn" type="button">Copy snippet</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>


  <div class="devlab-view devlab-view-lib2" data-dev-view="lib2" style="display:none;">
    <div class="devlab-editor-container" id="lib2Container">
      <div class="devlab-editor-left devlab-card" id="lib2Left">
        <h3>Library 2.0</h3>
        <input type="text" class="lib-search" id="lib2Search" placeholder="Search templates…">
        <label class="lib-filter-label" for="lib2Kind">Kind</label>
        <select class="lib-group-filter" id="lib2Kind">
          <option value="all" selected>all</option>
          <option value="agent">agent</option>
          <option value="customer">customer</option>
          <option value="note">note</option>
          <option value="macro">macro</option>
        </select>
        <div class="lib-status-toggle" style="margin-top:10px;">
          <button type="button" class="lib-status-button lib-status-active is-active" id="lib2ShowActive">Active</button>
          <button type="button" class="lib-status-button" id="lib2ShowArchived">Archived</button>
        </div>
        <div class="dictTinyNote" id="lib2Meta" style="margin-top:12px;">Edit-ready • Stored locally • Copy-safe exports</div>
        <div style="display:flex;gap:8px;margin-top:12px;flex-wrap:wrap;">
          <button type="button" class="fmt-btn" id="lib2New" style="flex:1;min-width:120px;">+ New</button>
          <button type="button" class="fmt-btn" id="lib2Export" style="flex:1;min-width:120px;">Export JSON</button>
          <button type="button" class="fmt-btn" id="lib2Import" style="flex:1;min-width:120px;">Import JSON</button>
          <button type="button" class="fmt-btn" id="lib2CopyAll" style="flex:1;min-width:120px;">Copy All</button>
        </div>
      </div>

      <div class="devlab-editor-middle devlab-card" id="lib2Middle">
        <h3>Templates</h3>
        <button type="button" class="lib-add-new" id="lib2AddQuick">+ Add new template</button>
        <div class="lib-template-list" id="lib2List">
          <p class="lib-empty-state" id="lib2Empty">No templates yet.</p>
        </div>
        <div class="lib-bulk-actions" style="margin-top:10px;">
          <button type="button" class="bulk-duplicate" id="lib2Duplicate" disabled>Duplicate</button>
          <button type="button" class="bulk-archive" id="lib2Archive" disabled>Archive</button>
          <button type="button" class="bulk-restore" id="lib2Restore" disabled>Restore</button>
          <button type="button" class="bulk-delete" id="lib2Delete" disabled>Delete</button>
        </div>
      </div>

      <div class="devlab-editor-right devlab-card" id="lib2Right">
        <h3 id="lib2EditorTitle">Select a template</h3>

        <label for="lib2Title">Title</label>
        <input id="lib2Title" class="editor-title" type="text" placeholder="Template title" disabled>

        <label for="lib2KindEdit">Kind</label>
        <select id="lib2KindEdit" class="editor-group" disabled>
          <option value="agent">agent</option>
          <option value="customer">customer</option>
          <option value="note">note</option>
          <option value="macro">macro</option>
        </select>

        <label for="lib2Tags">Tags (comma separated)</label>
        <input id="lib2Tags" class="editor-title" type="text" placeholder="e.g. fnol, update, courtesy" disabled>

        <!-- Stock phrases & replies selector.  Allows users to insert built‑in phrases or replies used by the
             messenger panel.  Populated and wired up in initDevLabLibrary2. -->
        <label for="lib2Stock">Stock phrases &amp; replies</label>
        <select id="lib2Stock" class="editor-stock" disabled></select>

        <label for="lib2Content">Template</label>
        <textarea id="lib2Content" class="editor-text" placeholder="Type template content here…" disabled></textarea>

        <div class="lib-bulk-actions" style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap;">
          <button type="button" class="fmt-btn" id="lib2Save" disabled>Save</button>
          <button type="button" class="fmt-btn" id="lib2Copy" disabled>Copy</button>
        </div>
        <div class="dictTinyNote" id="lib2Status" style="margin-top:10px;">Ready</div>
      </div>
    </div>
  </div>

<div class="devlab-view devlab-view-editor" data-dev-view="editor" style="display:none;">
    <div class="devlab-editor-container">
      <!-- LEFT COLUMN: Navigation / Filters -->
      <div class="devlab-editor-left devlab-card">
          <h3>Library</h3>
          <input type="text" class="lib-search" placeholder="Search templates..." disabled>
          <label class="lib-filter-label">Group</label>
          <select class="lib-group-filter" disabled></select>
          <div class="lib-status-toggle">
             <button type="button" data-mode="active" class="lib-status-button lib-status-active" disabled>Active only</button>
             <button type="button" data-mode="archived" class="lib-status-button" disabled>Show archived</button>
          </div>

          <!-- Phase 19.11: Deletion Log (runtime-only) -->
          <details id="devDeletionLog" style="margin-top:14px;">
            <summary style="cursor:pointer;font-weight:600;">Deletion Log</summary>
            <div style="margin-top:8px;">
              <pre id="devDeletionLogEntries" class="dev-pre" style="white-space:pre-wrap;max-height:220px;overflow:auto;">No deletions recorded in this session.</pre>
              <button type="button" id="devDeletionLogCopyBtn" class="fmt-btn" style="margin-top:8px;">Copy deletion log to clipboard</button>
            </div>
          </details>
      </div>
      <!-- MIDDLE COLUMN: List -->
      <div class="devlab-editor-middle devlab-card">
          <h3>Templates</h3>
          <button type="button" class="lib-add-new" disabled>+ Add new template</button>
          <div class="lib-template-list">
              <!-- When there are no templates in the library this placeholder shows. Updated messaging for clarity. -->
              <p class="lib-empty-state">No templates loaded yet. Use the “Add new template” button to create one.</p>
          </div>
          <div class="lib-bulk-actions">
              <button type="button" class="bulk-delete" disabled>Delete selected</button>
              <button type="button" class="bulk-archive" disabled>Archive selected</button>
              <button type="button" class="bulk-restore" disabled>Restore selected</button>
              <button type="button" class="bulk-duplicate" disabled>Duplicate selected</button>
          </div>
      </div>
      <!-- RIGHT COLUMN: Editor -->
      <div class="devlab-editor-right devlab-card">
          <h3 id="editor-title">Select a template</h3>
          <label for="editor-group">Group</label>
          <select id="editor-group" class="editor-group" disabled></select>
          <label for="editor-text">Template text</label>
          <textarea id="editor-text" class="editor-text" placeholder="Select a template from the list to edit..." disabled></textarea>
          <div class="editor-toggle-row">
              <label for="editor-active">Active</label>
              <input id="editor-active" type="checkbox" class="editor-active" disabled>
          </div>
          <div class="editor-buttons">
              <button type="button" class="editor-save" disabled>Save changes</button>
              <button type="button" class="editor-duplicate" disabled>Duplicate</button>
              <button type="button" class="editor-archive" disabled>Archive</button>
              <button type="button" class="editor-delete" disabled>Delete</button>
          </div>
          <div class="editor-preview-box">
              <h4>Preview (Replies menu)</h4>
              <div class="preview-content">
                 <p class="preview-placeholder">Your template preview will appear here.</p>
              </div>
          </div>
          <div class="editor-mini-analysis">
             <h4>Jargon &amp; UK/US snapshot</h4>
             <p class="mini-analysis-content">No analysis yet. This will show jargon and UK/US spellings for the current template in later phases.</p>
          </div>
      </div>
    </div>
  </div>
</section>



<!-- Phase 16: MirrorFlow CX Notch + Sliding Drawer -->
<button type="button" class="cx-notch" id="cxNotchToggle" data-tooltip="Open CX insight drawer – live tone, vulnerability and flags" title="CX Drawer" aria-label="Open CX insight drawer">
  <span class="cx-notch-label">
    <span class="cx-notch-main">CX</span>
    <span class="cx-notch-echo">Ξ</span>
  </span>
</button>

<!-- CV Notch for Call Notes -->
<button type="button" class="cv-notch-callnotes" id="cvNotchCallnotesToggle" data-tooltip="Open CV insight drawer – vulnerability analysis from Call Notes" title="CV Drawer" aria-label="Open CV insight drawer">
  <span class="cv-notch-callnotes-label">
    <span class="cv-notch-callnotes-main">CV</span>
    <span class="cv-notch-callnotes-echo">⚠</span>
  </span>
</button>

<!-- CX Notch for Call Notes -->
<button type="button" class="cx-notch-callnotes" id="cxNotchCallnotesToggle" data-tooltip="Open CX insight drawer – live tone, flags & vulnerability from Call Notes" title="CX Drawer" aria-label="Open CX insight drawer">
  <span class="cx-notch-callnotes-label">
    <span class="cx-notch-callnotes-main">CX</span>
    <span class="cx-notch-callnotes-echo">Ξ</span>
  </span>
</button>

<div class="cx-drawer-overlay" id="cxDrawerOverlay" aria-hidden="true">
  <div class="cx-dim"></div>
  <aside class="cx-drawer" role="complementary" aria-label="CX · MLCX insight drawer">
    <header class="cx-drawer-header">
      <div class="cx-drawer-title-block">
        <h2 class="cx-drawer-title">CX · MFCX Insight</h2>
        <p class="cx-drawer-subtitle">Live tone, flags &amp; vulnerability snapshot</p>
      </div>
      <button type="button" class="cx-drawer-close-btn" id="cxDrawerClose" aria-label="Close CX insight drawer">✕</button>
    </header>
    <div class="cx-drawer-body" id="cxDrawerBody">
      <section class="cx-drawer-section">
        <h3 class="cx-drawer-section-title">Overview</h3>
        <!-- Phase 17: unified MLCX snapshot (rendered by shared brain) -->
        <div id="cxDrawerSnapshot" data-mlcx-snapshot="drawer" style="margin-top:6px;"></div>
      </section>
      <section class="cx-drawer-section">
        <h3 class="cx-drawer-section-title">Emotion &amp; tone</h3>
        <p class="cx-drawer-section-empty">
          Emotional chips and tone bands will appear here once wired to the full MLCX state.
        </p>
      </section>
      <section class="cx-drawer-section">
        <h3 class="cx-drawer-section-title" title="Customer Vulnerability">CV &amp; vulnerability</h3>
        <!-- MLCX Alpha – vulnerability summary wiring (non-destructive patch) -->
        <div class="mlcx-vulnerability-summary"></div>
      </section>
      <section class="cx-drawer-section">
        <h3 class="cx-drawer-section-title">Support flags &amp; next steps</h3>
        <div class="mlcx-highrisk-card" id="mlcxHighRiskCard">
          <div class="mlcx-highrisk-header">
            <div class="mlcx-highrisk-title">High-risk snippets</div>
            <div class="mlcx-highrisk-subtitle">Flagged phrases &amp; excerpts</div>
          </div>
          <div class="mlcx-highrisk-content" id="mlcxHighRiskContent">
            <div class="mlcx-highrisk-empty">
              No high-risk snippets detected yet. This panel will list key phrases as they're flagged.
            </div>
          </div>
        </div>
      </section>
      <!-- MLCX Alpha – vulnerability summary wiring (non-destructive patch) -->
      <section class="cx-drawer-section" style="margin-top:16px;display:none;">
        <h3 class="cx-drawer-section-title">Debug: Vulnerability State</h3>
        <pre class="mlcx-vulnerability-debug" style="font-size:0.68rem;line-height:1.4;color:rgba(148,163,184,0.92);background:rgba(15,23,42,0.6);padding:6px 8px;border-radius:6px;overflow-x:auto;max-height:200px;"></pre>
      </section>
    </div>
  </aside>
</div>

<!-- CV Drawer Overlay for Call Notes -->
<div class="cx-drawer-overlay" id="cvDrawerCallnotesOverlay" aria-hidden="true">
  <div class="cx-dim"></div>
  <aside class="cx-drawer" role="complementary" aria-label="CV · Vulnerability insight drawer">
    <header class="cx-drawer-header">
      <div class="cx-drawer-title-block">
        <h2 class="cx-drawer-title">CV · Vulnerability Insight</h2>
        <p class="cx-drawer-subtitle">Customer vulnerability analysis from Call Notes</p>
      </div>
      <button type="button" class="cx-drawer-close-btn" id="cvDrawerCallnotesClose" aria-label="Close CV insight drawer">✕</button>
    </header>
    <div class="cx-drawer-body" id="cvDrawerCallnotesBody">
      <section class="cx-drawer-section">
        <h3 class="cx-drawer-section-title">Vulnerability Overview</h3>
        <div id="cvCallnotesSnapshot" style="margin-top:6px;"></div>
      </section>
      <section class="cx-drawer-section">
        <h3 class="cx-drawer-section-title">Detected Areas</h3>
        <div class="mlcx-vulnerability-summary" id="cvCallnotesVulnSummary"></div>
      </section>
      <section class="cx-drawer-section">
        <h3 class="cx-drawer-section-title">High-Risk Indicators</h3>
        <div class="mlcx-highrisk-card">
          <div class="mlcx-highrisk-header">
            <div class="mlcx-highrisk-title">Critical phrases</div>
            <div class="mlcx-highrisk-subtitle">Safeguarding &amp; vulnerability triggers</div>
          </div>
          <div class="mlcx-highrisk-content" id="cvCallnotesHighRiskContent">
            <div class="mlcx-highrisk-empty">
              No high-risk indicators detected yet.
            </div>
          </div>
        </div>
      </section>
      <section class="cx-drawer-section">
        <h3 class="cx-drawer-section-title">Guidance</h3>
        <div id="cvCallnotesGuidanceContent">
          <p class="cx-drawer-section-empty">
            Guidance recommendations will appear based on detected vulnerabilities.
          </p>
        </div>
      </section>
    </div>
  </aside>
</div>

<!-- CX Drawer Overlay for Call Notes -->
<div class="cx-drawer-overlay" id="cxDrawerCallnotesOverlay" aria-hidden="true">
  <div class="cx-dim"></div>
  <aside class="cx-drawer" role="complementary" aria-label="CX · MFCX insight drawer">
    <header class="cx-drawer-header">
      <div class="cx-drawer-title-block">
        <h2 class="cx-drawer-title">CX · MFCX Insight</h2>
        <p class="cx-drawer-subtitle">Live tone, flags &amp; vulnerability from Call Notes</p>
      </div>
      <button type="button" class="cx-drawer-close-btn" id="cxDrawerCallnotesClose" aria-label="Close CX insight drawer">✕</button>
    </header>
    <div class="cx-drawer-body" id="cxDrawerCallnotesBody">
      <section class="cx-drawer-section">
        <h3 class="cx-drawer-section-title">Overview</h3>
        <div id="cxCallnotesSnapshot" style="margin-top:6px;"></div>
      </section>
      <section class="cx-drawer-section">
        <h3 class="cx-drawer-section-title">Emotion &amp; Tone</h3>
        <div id="cxCallnotesEmotionSection"></div>
      </section>
      <section class="cx-drawer-section">
        <h3 class="cx-drawer-section-title" title="Customer Vulnerability">CV &amp; Vulnerability</h3>
        <div class="mlcx-vulnerability-summary" id="cxCallnotesVulnSummary"></div>
      </section>
      <section class="cx-drawer-section">
        <h3 class="cx-drawer-section-title">Support Flags &amp; Next Steps</h3>
        <div class="mlcx-highrisk-card">
          <div class="mlcx-highrisk-header">
            <div class="mlcx-highrisk-title">High-risk snippets</div>
            <div class="mlcx-highrisk-subtitle">Flagged phrases &amp; excerpts</div>
          </div>
          <div class="mlcx-highrisk-content" id="cxCallnotesHighRiskContent">
            <div class="mlcx-highrisk-empty">
              No high-risk snippets detected yet.
            </div>
          </div>
        </div>
      </section>
      <section class="cx-drawer-section">
        <h3 class="cx-drawer-section-title">Coaching</h3>
        <div id="cxCallnotesCoachingContent">
          <p class="cx-drawer-section-empty">
            Coaching tips will appear based on your analysis.
          </p>
        </div>
      </section>
    </div>
  </aside>
</div>

</main>
</div>
<script>
  // Core elements
  const customerInput = document.getElementById("customerInput");
  const mlcxRails = document.getElementById("mlcxRails");
  const mlcxRailLeft = document.getElementById("mlcxRailLeft");
  const mlcxRailRight = document.getElementById("mlcxRailRight");
  const mlcxNotesInput = document.getElementById("mlcxNotesInput");
  const mlcxPillsRow = document.getElementById("mlcxPillsRow");
  const mlcxCoachPanel = document.getElementById("mlcxCoachPanel");
  const mlcxCoachSentence = document.getElementById("mlcxCoachSentence");
  const mlcxCoachMessage = document.getElementById("mlcxCoachMessage");
  const mlcxCoachClose = document.querySelector(".mlcx-coach-close");
  const cvModeBtn = document.getElementById("cvModeBtn");
  const cvOverlay = document.getElementById("cvOverlay");
  const cvOverlayClose = document.getElementById("cvOverlayClose");
  const cvContent = document.getElementById("cvContent");
  const mlcxExcerptBar = document.getElementById("mlcxExcerptBar");
  const cxDrawerBody = document.getElementById("cxDrawerBody");
  const agentInput = document.getElementById("agentInput");
  const customerBubble = document.getElementById("customerBubble");
  const DEFAULT_CUSTOMER_TEXT = "Hi, I need help with my claim.";
  const agentBubble = document.getElementById("agentBubble");
  // =========================
  // ChatFlow (Phase A + B)
  // - Commit bubbles from Customer + Agent inputs into a timeline
  // - Offline / single-file safe (no deps)
  // =========================
  const customerCommitBtn = document.getElementById("customerCommitBtn");
  const agentCommitBtn = document.getElementById("agentCommitBtn");

  const agentPeekBtn = document.getElementById("agentPeekBtn");
  function cfUpdatePeekUi(){
    if (agentPeekBtn){
      const on = !!(cfPeek.active && cfPeek.role === "agent");
      const locked = !!(cfPeek.locked && cfPeek.role === "agent");
      agentPeekBtn.classList.toggle("is-locked", locked);
      agentPeekBtn.setAttribute("aria-pressed", locked ? "true" : "false");
      agentPeekBtn.title = locked ? "Locked preview (click to unlock)" : "Hold to preview (click to lock)";
    }
  }

  function cfStartPeek(role, opts){
    const lock = !!(opts && opts.locked);
    cfPeek.active = true;
    cfPeek.role = role;
    if (lock) cfPeek.locked = true;
    cfPeek.text = cfGetDraftTextForRole(role);
    // Re-render timeline first so peek bubble always appears on top of latest state
    if (typeof cfRenderTimeline === "function") cfRenderTimeline();
    cfRenderPeekBubble();
    cfUpdatePeekUi();
  }
  function cfStopPeek(force=false){
    if (cfPeek.locked && !force) return;
    cfPeek.active = false;
    cfPeek.locked = false;
    cfPeek.role = null;
    cfPeek.text = "";
    cfClearPeekBubble();
    // restore normal typing indicator state
    if (typeof cfRenderTimeline === "function") cfRenderTimeline();
    cfUpdatePeekUi();
  }
  
  // Dismiss Peek Preview without re-rendering the whole timeline (used on commit)
  function cfDismissPeekOnCommit(role){
    if (!cfPeek || !cfPeek.role) return;
    if (role && cfPeek.role !== role) return;
    cfPeek.active = false;
    cfPeek.locked = false;
    cfPeek.role = null;
    cfPeek.text = "";
    cfClearPeekBubble();
  }




  // === Library 2.0 (Dev Lab) ===
  function initDevLabLibrary2(){
    const view = document.querySelector('.devlab-view-lib2');
    if (!view) return;
    if (view.__lib2Init) return;

    // Hydrate replies/phrases libraries so built‑in stock phrases are available.  If the
    // function is defined (it lives in a later script block), we call it once.  This
    // populates global arrays like window.repliesLibrary and window.phrasesLibrary.
    try {
      if (typeof hydrateLibrariesFromDOM === 'function') {
        hydrateLibrariesFromDOM();
      }
    } catch (e) {
      console.warn('[Library2] hydrateLibrariesFromDOM failed', e);
    }

    const LS_KEY = 'MF_ENGINE_ASSETS_LIBRARIES_V2';
    const now = () => Date.now();
    const uid = () => 'lib2_' + Math.random().toString(36).slice(2, 10) + '_' + now().toString(36);

    window.ENGINE_ASSETS = window.ENGINE_ASSETS || {};
    if (!window.ENGINE_ASSETS.libraries || !Array.isArray(window.ENGINE_ASSETS.libraries.items)) {
      window.ENGINE_ASSETS.libraries = { meta:{ version:'2.0', updatedAt: now() }, items: [] };
    }

    const state = {
      currentId: null,
      showArchived: false,
      dirty: false
    };

    const els = {
      search: document.getElementById('lib2Search'),
      kind: document.getElementById('lib2Kind'),
      showActive: document.getElementById('lib2ShowActive'),
      showArchived: document.getElementById('lib2ShowArchived'),
      meta: document.getElementById('lib2Meta'),
      list: document.getElementById('lib2List'),
      empty: document.getElementById('lib2Empty'),
      newBtn: document.getElementById('lib2New'),
      addQuick: document.getElementById('lib2AddQuick'),
      exportBtn: document.getElementById('lib2Export'),
      importBtn: document.getElementById('lib2Import'),
      copyAllBtn: document.getElementById('lib2CopyAll'),
      dupBtn: document.getElementById('lib2Duplicate'),
      archiveBtn: document.getElementById('lib2Archive'),
      restoreBtn: document.getElementById('lib2Restore'),
      deleteBtn: document.getElementById('lib2Delete'),
      editorTitle: document.getElementById('lib2EditorTitle'),
      title: document.getElementById('lib2Title'),
      kindEdit: document.getElementById('lib2KindEdit'),
      tags: document.getElementById('lib2Tags'),
      content: document.getElementById('lib2Content'),
      saveBtn: document.getElementById('lib2Save'),
      copyBtn: document.getElementById('lib2Copy'),
      status: document.getElementById('lib2Status')
    };

    // Additional element: stock phrase selector
    els.stock = document.getElementById('lib2Stock');

    const safeStr = (v) => (v == null ? '' : String(v));

    function escapeHtml(str){
      return safeStr(str)
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/\'/g,'&#39;');
    }

    function parseTags(raw){
      const s = safeStr(raw).trim();
      if (!s) return [];
      return s.split(',').map(x => x.trim()).filter(Boolean).slice(0, 20);
    }

    function loadFromStorage(){
      try{
        const raw = localStorage.getItem(LS_KEY);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        if (parsed && Array.isArray(parsed.items)) {
          window.ENGINE_ASSETS.libraries = parsed;
        }
      }catch(e){ console.warn('[Library2] load failed', e); }
    }

    function saveToStorage(){
      try{
        window.ENGINE_ASSETS.libraries.meta.updatedAt = now();
        localStorage.setItem(LS_KEY, JSON.stringify(window.ENGINE_ASSETS.libraries));
      }catch(e){ console.warn('[Library2] save failed', e); }
    }

    function ensureSeed(){
      const items = window.ENGINE_ASSETS.libraries.items;
      if (Array.isArray(items) && items.length) return;
      window.ENGINE_ASSETS.libraries.items = [
        { id: uid(), title: 'FNOL – First Contact', kind: 'agent', tags:['fnol','opening'], content: 'Hi, thanks for reaching out. I\'ll help you get this reported. Can you confirm what happened and when?', createdAt: now(), updatedAt: now(), archived: false },
        { id: uid(), title: 'Courtesy Update', kind: 'agent', tags:['update','courtesy'], content: 'Just a quick update — we\'re progressing this and I\'ll keep you posted as soon as the next step is confirmed.', createdAt: now(), updatedAt: now(), archived: false },
        { id: uid(), title: 'Customer Reassurance', kind: 'customer', tags:['reassure'], content: 'Thanks — that makes sense. I appreciate the update and will wait for your next message.', createdAt: now(), updatedAt: now(), archived: false }
      ];
      saveToStorage();
    }

    // Populate the stock phrase selector with built‑in quick replies.  This reads from
    // the global repliesLibrary (hydrated from the messenger panel).  It inserts a
    // placeholder and then an option for each active reply text, truncated for display.
    function populateStockSelect(){
      const sel = els.stock;
      if (!sel) return;
      sel.innerHTML = '';
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = '-- Select a built‑in phrase --';
      sel.appendChild(placeholder);
      const library = Array.isArray(window.repliesLibrary) ? window.repliesLibrary : [];
      library.forEach(item => {
        // Skip inactive or blank entries
        if (!item || !item.text || item.active === false) return;
        const opt = document.createElement('option');
        opt.value = item.text;
        opt.textContent = item.text.length > 60 ? item.text.slice(0,60) + '…' : item.text;
        sel.appendChild(opt);
      });
    }

    function getItems(){
      return Array.isArray(window.ENGINE_ASSETS.libraries.items) ? window.ENGINE_ASSETS.libraries.items : [];
    }

    function getFiltered(){
      const q = safeStr(els.search && els.search.value).trim().toLowerCase();
      const kind = safeStr(els.kind && els.kind.value || 'all');
      const items = getItems();
      return items.filter(it => {
        if (!state.showArchived && it.archived) return false;
        if (state.showArchived && !it.archived) return false;
        if (kind !== 'all' && safeStr(it.kind) !== kind) return false;
        if (!q) return true;
        const hay = (safeStr(it.title)+' '+safeStr(it.kind)+' '+safeStr((it.tags||[]).join(','))+' '+safeStr(it.content)).toLowerCase();
        return hay.includes(q);
      });
    }

    function setEditorEnabled(on){
      [els.title, els.kindEdit, els.tags, els.stock, els.content, els.saveBtn, els.copyBtn].forEach(el => {
        if (!el) return;
        el.disabled = !on;
      });
      [els.dupBtn, els.archiveBtn, els.restoreBtn, els.deleteBtn].forEach(el => {
        if (!el) return;
        el.disabled = !on;
      });
    }

    function markDirty(isDirty){
      state.dirty = !!isDirty;
      if (els.status) els.status.textContent = state.dirty ? 'Unsaved changes' : 'Ready';
    }

    function currentItem(){
      const id = state.currentId;
      return getItems().find(x => x.id === id) || null;
    }

    function loadItem(id){
      const it = getItems().find(x => x.id === id) || null;
      state.currentId = it ? it.id : null;
      if (!it){
        if (els.editorTitle) els.editorTitle.textContent = 'Select a template';
        if (els.title) els.title.value = '';
        if (els.tags) els.tags.value = '';
        if (els.content) els.content.value = '';
        setEditorEnabled(false);
        markDirty(false);
        return;
      }
      if (els.editorTitle) els.editorTitle.textContent = 'Editing: ' + safeStr(it.title || it.id);
      if (els.title) els.title.value = safeStr(it.title);
      if (els.kindEdit) els.kindEdit.value = safeStr(it.kind || 'agent');
      if (els.tags) els.tags.value = Array.isArray(it.tags) ? it.tags.join(', ') : safeStr(it.tags);
      if (els.content) els.content.value = safeStr(it.content);
      setEditorEnabled(true);
      markDirty(false);

      // archive button state
      if (els.archiveBtn && els.restoreBtn) {
        if (it.archived) {
          els.archiveBtn.disabled = true;
          els.restoreBtn.disabled = false;
        } else {
          els.archiveBtn.disabled = false;
          els.restoreBtn.disabled = true;
        }
      }
    }

    function render(){
      const filtered = getFiltered();
      const items = getItems();
      const activeCount = items.filter(i => !i.archived).length;
      const archCount = items.filter(i => i.archived).length;
      if (els.meta) {
        const ts = window.ENGINE_ASSETS.libraries.meta && window.ENGINE_ASSETS.libraries.meta.updatedAt ? window.ENGINE_ASSETS.libraries.meta.updatedAt : Date.now();
        els.meta.textContent = `Items: ${items.length} • Active: ${activeCount} • Archived: ${archCount} • Updated: ${new Date(ts).toLocaleString()}`;
      }

      if (!els.list) return;
      els.list.innerHTML = '';

      if (els.empty) {
        els.empty.style.display = filtered.length ? 'none' : '';
      }

      filtered.forEach(it => {
        const row = document.createElement('div');
        row.className = 'dev-editor-item' + (it.archived ? ' is-archived' : '') + (it.id === state.currentId ? ' is-selected' : '');
        row.dataset.id = it.id;

        const content = document.createElement('div');
        content.className = 'dev-editor-item-content';
        const preview = safeStr(it.content).trim();
        const truncated = preview.length > 70 ? preview.slice(0,70) + '…' : (preview || '(empty)');
        const meta = `${safeStr(it.kind||'')} · ${(it.tags||[]).slice(0,2).join(', ')}`;
        content.innerHTML = `<div class="dev-editor-item-preview">${escapeHtml(truncated)}</div><div class="dev-editor-item-meta">${escapeHtml(meta)}</div>`;
        row.appendChild(content);
        row.addEventListener('click', () => { loadItem(it.id); render(); });
        els.list.appendChild(row);
      });
    }

    function upsertCurrentFromEditor(){
      const it = currentItem();
      if (!it) return null;
      it.title = safeStr(els.title && els.title.value).trim() || it.title || it.id;
      it.kind = safeStr(els.kindEdit && els.kindEdit.value || it.kind || 'agent');
      it.tags = parseTags(els.tags && els.tags.value);
      it.content = safeStr(els.content && els.content.value);
      it.updatedAt = now();
      return it;
    }

    function createNew(){
      const it = { id: uid(), title: 'New template', kind: 'agent', tags: [], content: '', createdAt: now(), updatedAt: now(), archived: false };
      window.ENGINE_ASSETS.libraries.items.unshift(it);
      saveToStorage();
      loadItem(it.id);
      render();
      if (els.title) { els.title.focus(); els.title.select(); }
    }

    function duplicateCurrent(){
      const it = currentItem();
      if (!it) return;
      const copy = { ...it, id: uid(), title: (it.title || 'Template') + ' (Copy)', createdAt: now(), updatedAt: now(), archived: false };
      window.ENGINE_ASSETS.libraries.items.unshift(copy);
      saveToStorage();
      loadItem(copy.id);
      render();
    }

    function setArchived(val){
      const it = currentItem();
      if (!it) return;
      it.archived = !!val;
      it.updatedAt = now();
      saveToStorage();
      // if view filtered out, clear selection
      if ((state.showArchived && !it.archived) || (!state.showArchived && it.archived)) {
        loadItem(null);
      }
      render();
    }

    function deleteCurrent(){
      const it = currentItem();
      if (!it) return;
      const items = getItems();
      const idx = items.findIndex(x => x.id === it.id);
      if (idx >= 0) items.splice(idx, 1);
      state.currentId = null;
      saveToStorage();
      loadItem(null);
      render();
    }

    function copyText(text){
      const t = safeStr(text);
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(t).then(() => { try{ showToast('Copied', 'success'); }catch(e){} }).catch(() => {});
      }
    }

    function exportJSON(){
      const payload = window.ENGINE_ASSETS.libraries;
      const json = JSON.stringify(payload, null, 2);
      // download file
      try{
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'ENGINE_ASSETS.libraries.v2.json';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }catch(e){
        // fallback: copy
        copyText(json);
      }
    }

    function importJSON(){
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'application/json';
      input.addEventListener('change', () => {
        const file = input.files && input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          try{
            const parsed = JSON.parse(String(reader.result || ''));
            if (!parsed || !Array.isArray(parsed.items)) throw new Error('Invalid shape');
            window.ENGINE_ASSETS.libraries = parsed;
            saveToStorage();
            loadItem(null);
            render();
            try{ showToast('Imported', 'success'); }catch(e){}
          }catch(e){
            try{ showToast('Import failed', 'error'); }catch(_){}
          }
        };
        reader.readAsText(file);
      });
      input.click();
    }

    function copyAll(){
      const items = getItems().filter(it => !it.archived);
      const lines = items.map(it => `# ${it.title}\n${it.content}`);
      copyText(lines.join('\n\n'));
    }

    // Bind events
    function bind(){
      if (els.search) els.search.addEventListener('input', () => render());
      if (els.kind) els.kind.addEventListener('change', () => render());

      // When the stock selector changes, insert the chosen phrase into the content area and mark dirty
      if (els.stock) {
        els.stock.addEventListener('change', () => {
          const v = els.stock.value || '';
          if (v && els.content) {
            els.content.value = v;
            markDirty(true);
          }
        });
      }

      if (els.showActive && els.showArchived) {
        els.showActive.addEventListener('click', () => {
          state.showArchived = false;
          els.showActive.classList.add('is-active');
          els.showArchived.classList.remove('is-active');
          loadItem(null);
          render();
        });
        els.showArchived.addEventListener('click', () => {
          state.showArchived = true;
          els.showArchived.classList.add('is-active');
          els.showActive.classList.remove('is-active');
          loadItem(null);
          render();
        });
      }

      if (els.newBtn) els.newBtn.addEventListener('click', createNew);
      if (els.addQuick) els.addQuick.addEventListener('click', createNew);
      if (els.exportBtn) els.exportBtn.addEventListener('click', exportJSON);
      if (els.importBtn) els.importBtn.addEventListener('click', importJSON);
      if (els.copyAllBtn) els.copyAllBtn.addEventListener('click', copyAll);

      if (els.saveBtn) els.saveBtn.addEventListener('click', () => {
        const it = upsertCurrentFromEditor();
        if (!it) return;
        saveToStorage();
        markDirty(false);
        render();
        try{ showToast('Saved', 'success'); }catch(e){}
      });

      if (els.copyBtn) els.copyBtn.addEventListener('click', () => {
        const it = currentItem();
        if (!it) return;
        copyText(it.content);
      });

      if (els.dupBtn) els.dupBtn.addEventListener('click', duplicateCurrent);
      if (els.archiveBtn) els.archiveBtn.addEventListener('click', () => setArchived(true));
      if (els.restoreBtn) els.restoreBtn.addEventListener('click', () => setArchived(false));
      if (els.deleteBtn) els.deleteBtn.addEventListener('click', deleteCurrent);

      // mark dirty
      [els.title, els.kindEdit, els.tags, els.content].forEach(el => {
        if (!el) return;
        el.addEventListener('input', () => markDirty(true));
        el.addEventListener('change', () => markDirty(true));
      });
    }

    // boot
    loadFromStorage();
    ensureSeed();
    // Populate the stock phrase selector now that the libraries are loaded
    populateStockSelect();
    bind();
    loadItem(null);
    render();

    view.__lib2Init = true;
  }

function initDevLabDictionaries2() {
  const dictView = document.querySelector('.devlab-view-dict2');
  if (!dictView) return;
  if (dictView.__dict2Initialised) return;

  const els = {
    meta: document.getElementById('dict2Meta'),
    health: document.getElementById('dict2Health'),
    search: document.getElementById('dict2Search'),
    sectionSelect: document.getElementById('dict2Section'),
    dir: document.getElementById('dict2UkusDirection'),
    copyList: document.getElementById('dict2CopyList'),
    copyJSON: document.getElementById('dict2CopyJSON'),
    copyBundle: document.getElementById('dict2CopyBundle'),
    exportBtn: document.getElementById('dict2ExportJson'),
    counts: document.getElementById('dict2Counts'),
    listTitle: document.getElementById('dict2ListTitle'),
    listHint: document.getElementById('dict2ListHint'),
    list: document.getElementById('dict2List'),
    empty: document.getElementById('dict2EmptyState'),
    detailEmpty: document.getElementById('dict2DetailEmpty'),
    detail: document.getElementById('dict2Detail'),
    dTitle: document.getElementById('dict2DetailTitle'),
    dBadges: document.getElementById('dict2DetailBadges'),
    dBody: document.getElementById('dict2DetailBody'),
    dNotes: document.getElementById('dict2DetailNotes'),
    dPatterns: document.getElementById('dict2DetailPatternsPre'),
    dSnippet: document.getElementById('dict2CopySnippet'),
    dCopyBtn: document.getElementById('dict2CopySnippetBtn'),
  };

  const state = {
    section: 'ukus',
    search: '',
    dir: 'US->UK',
    selectedKey: null,
  };

  function safeText(v){ return (v==null)? '' : String(v); }

  function legacyJargon(){
    const arr = (typeof jargonPatterns !== 'undefined' && Array.isArray(jargonPatterns)) ? jargonPatterns : [];
    return arr.map((j,i)=>{
      const pat = j.pattern;
      const patSrc = pat && pat.source ? pat.source : safeText(pat);
      const term = safeText(j.term || j.acronym || j.word || '').trim() || (patSrc ? patSrc.replace(/\W+/g,' ').trim().slice(0,24) : `jargon_${i+1}`);
      return {
        kind:'jargon',
        id: j.id || `legacy_jargon_${i}`,
        term,
        severity: safeText(j.severity || 'misc'),
        expansion: safeText(j.suggestion || j.expansion || ''),
        notes: safeText(j.note || j.notes || ''),
        patterns: [patSrc].filter(Boolean),
      };
    });
  }

  function legacyUkus(){
    const out=[];
    if (typeof UKUS_RULES !== 'undefined' && UKUS_RULES && Array.isArray(UKUS_RULES.autoReplace)) {
      UKUS_RULES.autoReplace.forEach((r,i)=>{
        const pat = r.pattern;
        const patSrc = pat && pat.source ? pat.source : safeText(pat);
        out.push({
          kind:'ukus',
          id: r.id || `legacy_ukus_${i}`,
          us: safeText(r.us || ''),
          uk: safeText(r.uk || ''),
          pattern: patSrc,
          replace: safeText(r.replace || ''),
          type: safeText(r.type || 'misc'),
          notes: safeText(r.notes || ''),
          badge: safeText(r.badge || r.source || 'AUTO')
        });
      });
    }
    return out;
  }

  function getSources(){
    const eng = (typeof window !== 'undefined') ? window.ENGINE_ASSETS : null;
    const src = { sourceName: 'legacy', jargon: [], ukus: [] };
    if (eng && typeof eng === 'object') {
      const j = Array.isArray(eng.jargon) ? eng.jargon : null;
      const u = Array.isArray(eng.ukus) ? eng.ukus : null;
      if (j || u) {
        src.sourceName = 'ENGINE_ASSETS';
        if (j) src.jargon = j.map((it,i)=>({
          kind:'jargon',
          id: it.id || `eng_jargon_${i}`,
          term: safeText(it.term),
          expansion: safeText(it.expansion),
          severity: safeText(it.severity || 'HIGH'),
          notes: safeText(it.notes || ''),
          patterns: Array.isArray(it.patterns) ? it.patterns.map(safeText) : [],
        }));
        if (u) src.ukus = u.map((it,i)=>({
          kind:'ukus',
          id: it.id || `eng_ukus_${i}`,
          match: safeText(it.match || it.pattern || it.us),
          replace: safeText(it.replace || it.uk),
          type: safeText(it.type || 'misc'),
          notes: safeText(it.notes || ''),
          badge: safeText(it.badge || it.source || 'AUTO')
        }));
      }
    }

    if (!src.jargon.length) src.jargon = legacyJargon();
    if (!src.ukus.length) src.ukus = legacyUkus();

    // Derive readable pairs for UKUS when possible
    src.ukus = src.ukus.map((it)=>{
      let us='', uk='';
      if (it.us || it.uk) { us = safeText(it.us); uk = safeText(it.uk); }
      else {
        const m = safeText(it.match);
        const r = safeText(it.replace);
        // best-effort: pull a plain token from regex like \bcolor\b
        const token = (m.match(/\b([A-Za-z]{2,})\b/)||[])[1] || m.replace(/\\b/g,'').replace(/[^A-Za-z]/g,'').slice(0,30);
        us = token;
        uk = r.replace(/\$\d+/g,'').replace(/[^A-Za-z]/g,'').slice(0,30);
      }
      return { ...it, us, uk };
    });

    return src;
  }

  const data = getSources();
  if (els.meta) els.meta.textContent = `View-only • Source: ${data.sourceName}`;

  // UI: section buttons (left rail)
  const sectionBtns = Array.from(dictView.querySelectorAll('[data-d2-section]'));
  sectionBtns.forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const next = (btn.dataset.d2Section||'').trim();
      if (!next || next===state.section) return;
      state.section = next;
      state.selectedKey = null;
      sectionBtns.forEach(b=>b.classList.toggle('is-active', b===btn));
      if (els.sectionSelect) els.sectionSelect.value = next;
      showDetailEmpty();
      updateCounts();
      renderList();
    });
  });

  if (els.sectionSelect) {
    els.sectionSelect.addEventListener('change', ()=>{
      state.section = els.sectionSelect.value || 'ukus';
      state.selectedKey = null;
      sectionBtns.forEach(b=>b.classList.toggle('is-active', (b.dataset.d2Section||'')===state.section));
      showDetailEmpty();
      updateCounts();
      renderList();
    });
  }

  if (els.dir) {
    els.dir.addEventListener('change', ()=>{
      state.dir = els.dir.value || 'US->UK';
      if (state.section==='ukus') renderList();
    });
  }

  if (els.search) {
    els.search.addEventListener('input', ()=>{
      state.search = els.search.value || '';
      state.selectedKey = null;
      showDetailEmpty();
      renderList();
    });
  }

  function showDetailEmpty(){
    if (els.detail) els.detail.style.display='none';
    if (els.detailEmpty) els.detailEmpty.style.display='block';
  }

  function showDetail(){
    if (els.detailEmpty) els.detailEmpty.style.display='none';
    if (els.detail) els.detail.style.display='block';
  }

  function filterItems(arr){
    const q = (state.search||'').trim().toLowerCase();
    if (!q) return arr;
    return arr.filter(it=>{
      const hay = [it.term, it.expansion, it.notes, it.us, it.uk, it.match, it.replace, it.type, it.badge].map(safeText).join(' | ').toLowerCase();
      return hay.includes(q);
    });
  }

  function updateCounts(){
    const jn = filterItems(data.jargon).length;
    const un = filterItems(data.ukus).length;
    if (els.counts) els.counts.textContent = `UK ⇄ US: ${un} • Jargon: ${jn}`;
    if (els.listTitle) els.listTitle.textContent = (state.section==='ukus') ? 'UK ⇄ US' : 'Jargon';
    if (els.listHint) els.listHint.textContent = 'Click an item to view details';
  }

  function renderList(){
    const isUk = state.section==='ukus';
    const items = filterItems(isUk ? data.ukus : data.jargon);
    if (!els.list) return;
    els.list.innerHTML='';
    if (els.empty) els.empty.style.display = items.length ? 'none' : 'block';

    const max = Math.min(items.length, 1000);
    for (let i=0;i<max;i++){
      const it = items[i];
      const row = document.createElement('button');
      row.type='button';
      row.className='dictRow';
      row.style.width='100%';
      row.style.textAlign='left';
      row.style.background='transparent';
      row.style.border='none';
      row.style.padding='10px 10px';
      row.style.cursor='pointer';
      row.style.borderBottom='1px solid rgba(255,255,255,0.06)';
      const key = `${it.kind}:${it.id}`;
      row.dataset.key = key;

      let title='';
      let sub='';
      if (isUk){
        const a = state.dir==='US->UK' ? it.us : it.uk;
        const b = state.dir==='US->UK' ? it.uk : it.us;
        title = `${safeText(a)} → ${safeText(b)}`;
        sub = safeText(it.type || it.badge || '');
      } else {
        title = safeText(it.term);
        sub = safeText(it.expansion);
      }
      row.innerHTML = `<div style="font-weight:700;">${escapeHtml(title)}</div><div style="opacity:0.78; font-size:12px; margin-top:2px;">${escapeHtml(sub)}</div>`;

      row.addEventListener('click', ()=>{
        state.selectedKey = key;
        renderDetail(it);
        // highlight selection
        Array.from(els.list.querySelectorAll('button.dictRow')).forEach(b=>b.classList.toggle('is-selected', b.dataset.key===key));
      });
      els.list.appendChild(row);
    }

    if (els.health) els.health.textContent = `view: ${state.section} • items: ${items.length} • src: ${data.sourceName}`;
  }

  function escapeHtml(text){
    const div=document.createElement('div');
    div.textContent = safeText(text);
    return div.innerHTML;
  }

  function renderDetail(it){
    if (!it) { showDetailEmpty(); return; }
    showDetail();
    if (els.dTitle) {
      if (state.section==='ukus') {
        const a = state.dir==='US->UK' ? it.us : it.uk;
        const b = state.dir==='US->UK' ? it.uk : it.us;
        els.dTitle.textContent = `${safeText(a)} → ${safeText(b)}`;
      } else {
        els.dTitle.textContent = safeText(it.term);
      }
    }
    if (els.dBadges) {
      const badges=[];
      if (it.severity) badges.push(it.severity);
      if (it.type) badges.push(it.type);
      if (it.badge) badges.push(it.badge);
      els.dBadges.innerHTML = badges.map(b=>`<span class="detailBadge">${escapeHtml(b)}</span>`).join('');
    }
    if (els.dBody) {
      if (state.section==='ukus') {
        els.dBody.textContent = `Replace: ${safeText(it.us)} → ${safeText(it.uk)}`;
      } else {
        els.dBody.textContent = safeText(it.expansion || '');
      }
    }
    if (els.dNotes) els.dNotes.textContent = safeText(it.notes || '');
    if (els.dPatterns) {
      const pats = it.patterns || [];
      const p = Array.isArray(pats) ? pats : [pats];
      els.dPatterns.textContent = p.map(safeText).filter(Boolean).join('\n');
    }
    if (els.dSnippet) {
      if (state.section==='ukus') els.dSnippet.value = `${safeText(it.us)} -> ${safeText(it.uk)}`;
      else els.dSnippet.value = `${safeText(it.term)} -> ${safeText(it.expansion||'')}`;
    }
  }

  function buildCopyList(){
    const isUk = state.section==='ukus';
    const items = filterItems(isUk ? data.ukus : data.jargon);
    if (isUk) {
      return items.map(it=>{
        const a = state.dir==='US->UK' ? it.us : it.uk;
        const b = state.dir==='US->UK' ? it.uk : it.us;
        return `${safeText(a)} -> ${safeText(b)}`.trim();
      }).filter(Boolean).join('\n');
    }
    return items.map(it=>{
      const exp = safeText(it.expansion||'').trim() || '(no expansion)';
      return `${safeText(it.term)} -> ${exp}`.trim();
    }).filter(Boolean).join('\n');
  }

  function buildCopyJSON(){
    const isUk = state.section==='ukus';
    const items = filterItems(isUk ? data.ukus : data.jargon);
    return JSON.stringify(items, null, 2);
  }

  function buildCopyBundle(){
    const prevSection = state.section;
    const prevDir = state.dir;

    state.section='ukus';
    const ukus = buildCopyList();
    state.section='jargon';
    const jargon = buildCopyList();

    state.section=prevSection;
    state.dir=prevDir;

    return `=== UKUS ===\n${ukus}\n\n=== JARGON ===\n${jargon}`.trim();
  }

  async function copyBtnFeedback(btn, text){
    if (!btn) return;
    const label = btn.textContent;
    try {
      const ok = await copyToClipboardRich(text);
      btn.textContent = ok ? 'Copied' : label;
    } catch (e) {
      console.warn('[DevLab] dict2 copy failed:', e);
    }
    setTimeout(()=>{ btn.textContent = label; }, 900);
  }

  if (els.copyList) els.copyList.addEventListener('click', ()=>copyBtnFeedback(els.copyList, buildCopyList()));
  if (els.copyJSON) els.copyJSON.addEventListener('click', ()=>copyBtnFeedback(els.copyJSON, buildCopyJSON()));
  if (els.copyBundle) els.copyBundle.addEventListener('click', ()=>copyBtnFeedback(els.copyBundle, buildCopyBundle()));

  if (els.dCopyBtn) els.dCopyBtn.addEventListener('click', ()=>copyBtnFeedback(els.dCopyBtn, els.dSnippet ? els.dSnippet.value : ''));

  if (els.exportBtn) {
    els.exportBtn.addEventListener('click', ()=>{
      const payload = {
        meta: { exportedAt: new Date().toISOString(), source: data.sourceName },
        ukus: filterItems(data.ukus),
        jargon: filterItems(data.jargon)
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `mirrorflow_dictionaries2_snapshot_${Date.now()}.json`;
      document.body.appendChild(a);
      a.click();
      setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
    });
  }

  // Sync direction selector visibility
  function syncDirVisibility(){
    if (!els.dir) return;
    els.dir.style.display = (state.section==='ukus') ? '' : 'none';
  }

  // Initial render
  updateCounts();
  renderList();
  syncDirVisibility();

  // Keep dir selector in sync
  const _origRender = renderList;
  renderList = function(){
    syncDirVisibility();
    return _origRender();
  };

  dictView.__dict2Initialised = true;
}

function cfRefreshPeek(){
    if (!cfPeek.active || !cfPeek.role) return;
    cfPeek.text = cfGetDraftTextForRole(cfPeek.role);
    // Just update bubble by re-rendering it (cheap)
    cfRenderPeekBubble();
  }

  if (agentPeekBtn){
    const maybeStart = () => { if (!cfPeek.locked) cfStartPeek("agent"); };
    const maybeStop  = () => { if (!cfPeek.locked) cfStopPeek(); };

    agentPeekBtn.addEventListener("mouseenter", maybeStart);
    agentPeekBtn.addEventListener("mouseleave", maybeStop);

    agentPeekBtn.addEventListener("pointerdown", (e) => {
      // press-and-hold preview (mobile + desktop)
      e.preventDefault();
      if (!cfPeek.locked) cfStartPeek("agent");
    });
    agentPeekBtn.addEventListener("pointerup", () => { if (!cfPeek.locked) cfStopPeek(); });
    agentPeekBtn.addEventListener("pointercancel", () => { if (!cfPeek.locked) cfStopPeek(); });

    // Click toggles lock (pin preview + keep it updating while you type)
    agentPeekBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      const isLocked = (cfPeek.locked && cfPeek.role === "agent");
      if (isLocked){
        cfStopPeek(true);
      } else {
        cfPeek.locked = true;
        cfStartPeek("agent", { locked:true });
      }
    });
  }

  // Click-out cancels a locked Peek Preview (ghost bubble), similar to Mars draft previews
  document.addEventListener("pointerdown", (e) => {
    if (!cfPeek || !cfPeek.locked || !cfPeek.role) return;
    // Ignore clicks on the peek button or inside the editor itself
    const t = e.target;
    if (agentPeekBtn && (t === agentPeekBtn || agentPeekBtn.contains(t))) return;
    if (agentInput && (t === agentInput || agentInput.contains(t))) return;
    // If click is inside phone timeline, also ignore (so user can scroll/read)
    if (chatTimeline && (t === chatTimeline || chatTimeline.contains(t))) return;
    // Otherwise, treat as "click out" and dismiss the ghost
    if (typeof cfStopPeek === "function") cfStopPeek(true);
  });

// Esc unlocks any locked peek
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && cfPeek.locked){
      cfStopPeek(true);
    }
  }, true);


  // While peeking, keep preview synced with edits (only while peek is active)
  document.addEventListener("input", () => { if (cfPeek.active || cfPeek.locked) cfRefreshPeek(); }, true);

  const chatTimeline = document.getElementById("chatTimeline");

  window.chatFlow = window.chatFlow || {
    enabled: true,
    nextId: 1,
    turns: [] // {id, role:'customer'|'agent', text?:string, html?:string}
  };
  // Legacy placeholder bubbles (static) live here:
  //   #customerBubble (p) and #agentBubble (p)
  // For ChatFlow we seed these into the timeline as placeholder turns,
  // then the FIRST commit replaces them instead of adding duplicates.
  function cfSeedPlaceholders(force=false){
    if (!force && window.chatFlow.turns && window.chatFlow.turns.length) return;
    const custP = document.querySelector("#customerBubble p");
    const agentP = document.querySelector("#agentBubble p");
    const custText = cfNormalizeCustomer((custP?.textContent || "").trim()) || "Hi, I need help with my claim.";
    const agentHtml = cfNormalizeAgentHtml((agentP?.innerHTML || "").trim()) || "Hi,<br>Thanks for reaching out, how can I help?";

    // Reset id counter if we're fully resetting (keeps ids small/predictable)
    if (force){
      window.chatFlow.nextId = 1;
      window.chatFlow.turns = [];
    }

    window.chatFlow.turns = [
      { id: cfNewId(), role: "customer", text: custText, isPlaceholder: true },
      { id: cfNewId(), role: "agent", html: agentHtml, isPlaceholder: true }
    ];

    // Enable timeline mode visually (hides legacy 2-bubble preview blocks)
    document.documentElement.classList.add("chatflow-enabled");
  }

  function cfConsumePlaceholder(role, payload){
    const idx = window.chatFlow.turns.findIndex(t => t.role === role && t.isPlaceholder);
    if (idx === -1) return false;
    window.chatFlow.turns[idx] = { ...window.chatFlow.turns[idx], ...payload, isPlaceholder: false };
    return true;
  }

  function cfResetAll(){
    // Clear inputs
    if (customerInput) customerInput.value = "";
    if (agentInput) agentInput.innerHTML = "";
    // Reset timeline back to placeholders
    cfSeedPlaceholders(true);
    cfRender();
  }


  function cfNewId(){
    const id = "t" + window.chatFlow.nextId;
    window.chatFlow.nextId += 1;
    return id;
  }

  function cfNormalizeCustomer(text){
    return (text || "").trim();
  }

  function cfNormalizeAgentHtml(html){
    let h = (html || "");
    h = cleanHtml(h);
    // if only <br> or whitespace, treat as empty
    if (!h.replace(/<br\s*\/?>/gi, "").trim()) return "";
    return h;
  }

  function cfSeedIfEmpty(){
    if (!window.chatFlow.enabled) return;
    if (window.chatFlow.turns.length) return;

    const seedCustomer = cfNormalizeCustomer(getCustomerText());
    const seedAgentHtml = "<p>Hi,<br>Thanks for reaching out, how can I help?</p>";

    if (seedCustomer) window.chatFlow.turns.push({ id: cfNewId(), role: "customer", text: seedCustomer });
    window.chatFlow.turns.push({ id: cfNewId(), role: "agent", html: seedAgentHtml });
  }

  function cfRender(){
    if (!window.chatFlow.enabled || !chatTimeline) return;
    cfSeedIfEmpty();

    chatTimeline.innerHTML = "";
    window.chatFlow.turns.forEach((turn) => {
      const bubble = document.createElement("div");
      bubble.className = "chat-bubble " + (turn.role === "agent" ? "agent" : "customer") + " is-draggable";
      bubble.draggable = true;
      bubble.dataset.turnId = turn.id;
      bubble.dataset.role = turn.role;
      if (turn.isPlaceholder) bubble.dataset.placeholder = "1";

      if (turn.role === "agent"){
        bubble.innerHTML = turn.html || "<p></p>";
      } else {
        const safe = textToHtml(turn.text || "");
        bubble.innerHTML = "<p>" + safe + "</p>";
      }
      chatTimeline.appendChild(bubble);
    });

    // Always keep scrolled to bottom after render
    cfMaybeRenderTyping();

    chatTimeline.scrollTop = chatTimeline.scrollHeight;
  }

  
  // === Draft Peek Preview (hold 👁 to preview on phone) ===
  // Default mode remains dots/typing indicator. Peek preview is deliberate + momentary.
  const cfPeek = { active:false, locked:false, role:null, text:"" };

  function cfGetDraftTextForRole(role){
    if (role === "customer"){
      return (customerInput && customerInput.value ? customerInput.value : "").trim();
    }
    // agent (contenteditable)
    const raw = agentInput ? (agentInput.innerText || agentInput.textContent || "") : "";
    return raw.replace(/\u00a0/g," ").trim();
  }

  function cfClearPeekBubble(){
    const existing = document.getElementById("cfPeekBubble");
    if (existing) existing.remove();
  }

  function cfRenderPeekBubble(){
    cfClearPeekBubble();
    if (!cfPeek.active || !cfPeek.role) return;

    const txt = cfPeek.text || "";
    if (!txt.trim()) return;

    // If timeline isn't present yet, skip
    if (!chatTimeline) return;

    const bubble = document.createElement("div");
    bubble.id = "cfPeekBubble";
    bubble.className = "chat-bubble " + (cfPeek.role === "customer" ? "customer" : "agent") + " is-peek";
    bubble.setAttribute("aria-label", "Draft preview (not sent)");
    bubble.innerHTML = "<p>" + textToHtml(txt) + "</p>";
    chatTimeline.appendChild(bubble);

    // keep in view
    chatTimeline.scrollTop = chatTimeline.scrollHeight;
  }


// === Typing indicator (smallest change, biggest UX win) ===
// Since ChatFlow only commits bubbles on "Send", we show an in-timeline typing bubble
// while the Customer/Agent editors are being used.
window.chatFlowTyping = window.chatFlowTyping || {
  role: null,           // "customer" | "agent"
  active: false,
  focus: { customer: false, agent: false }
};

function cfGetAgentHasText(){
  if (!agentInput) return false;
  // contenteditable often contains <br> when "empty"
  const t = (agentInput.textContent || "").replace(/\u00a0/g, " ").trim();
  return t.length > 0;
}

function cfGetCustomerHasText(){
  if (!customerInput) return false;
  return (customerInput.value || "").trim().length > 0;
}

function cfRenderTypingBubble(role, show){
  if (!chatTimeline) return;

  const id = role === "agent" ? "cfTypingAgent" : "cfTypingCustomer";
  const otherId = role === "agent" ? "cfTypingCustomer" : "cfTypingAgent";

  // Remove the other side's typing bubble (keeps UX clean)
  const other = document.getElementById(otherId);
  if (other && other.parentNode) other.parentNode.removeChild(other);

  // --- Placeholder takeover mode ---
  // If the relevant side still has a placeholder turn, we "take it over" (replace text with dots)
  // instead of adding a new bubble. This makes it obvious which bubble will be replaced on first send.
  const placeholder = chatTimeline.querySelector('.chat-bubble.' + (role === 'agent' ? 'agent' : 'customer') + '[data-placeholder="1"]');

  // Remove any existing floating typing bubble for this role (or cleanup on hide)
  let node = document.getElementById(id);

  if (!show){
    // Restore placeholder if we previously took it over
    if (placeholder && placeholder.classList.contains('typing')){
      if (placeholder.dataset.origHtml){
        placeholder.innerHTML = placeholder.dataset.origHtml;
        delete placeholder.dataset.origHtml;
      }
      placeholder.classList.remove('typing');
      placeholder.removeAttribute('role');
      placeholder.removeAttribute('aria-live');
      placeholder.removeAttribute('aria-label');
    }
    if (node && node.parentNode) node.parentNode.removeChild(node);
    return;
  }

  if (placeholder){
    // Take over placeholder bubble
    if (!placeholder.dataset.origHtml) placeholder.dataset.origHtml = placeholder.innerHTML;
    placeholder.classList.add('typing');
    placeholder.setAttribute('role', 'status');
    placeholder.setAttribute('aria-live', 'polite');
    placeholder.setAttribute('aria-label', (role === 'agent' ? 'Agent' : 'Customer') + ' is typing');
    placeholder.innerHTML = '<div class="typing-dots" aria-hidden="true"><span></span><span></span><span></span></div>';
    // Ensure floating bubble is removed if it exists
    if (node && node.parentNode) node.parentNode.removeChild(node);
    chatTimeline.scrollTop = chatTimeline.scrollHeight;
    return;
  }

  // --- Fallback: append a dedicated typing bubble at the end ---
  if (!node){
    node = document.createElement("div");
    node.id = id;
    node.className = "chat-bubble " + (role === "agent" ? "agent" : "customer") + " typing";
    node.setAttribute("role", "status");
    node.setAttribute("aria-live", "polite");
    node.setAttribute("aria-label", (role === "agent" ? "Agent" : "Customer") + " is typing");
    node.innerHTML = '<div class="typing-dots" aria-hidden="true"><span></span><span></span><span></span></div>';
  }

  chatTimeline.appendChild(node);
  chatTimeline.scrollTop = chatTimeline.scrollHeight;
}

function cfMaybeRenderTyping(){
    if (typeof cfPeek !== "undefined" && cfPeek.active) return;
  // Called at the end of cfRender() after timeline re-renders
  const st = window.chatFlowTyping;
  if (!st || !st.active || !st.role) return;
  cfRenderTypingBubble(st.role, true);
}

function cfUpdateTyping(role){
  const st = window.chatFlowTyping;
  if (!st) return;

  const hasText = (role === "agent") ? cfGetAgentHasText() : cfGetCustomerHasText();
  const hasFocus = st.focus && st.focus[role];

  const shouldShow = !!(hasFocus && hasText);
  st.role = shouldShow ? role : (st.role === role ? null : st.role);
  st.active = shouldShow;

  cfRenderTypingBubble(role, shouldShow);
}

// Wire customer typing listeners
if (customerInput){
  customerInput.addEventListener("focus", () => {
    window.chatFlowTyping.focus.customer = true;
    cfUpdateTyping("customer");
  });
  customerInput.addEventListener("blur", () => {
    window.chatFlowTyping.focus.customer = false;
    cfRenderTypingBubble("customer", false);
    if (window.chatFlowTyping.role === "customer"){
      window.chatFlowTyping.role = null;
      window.chatFlowTyping.active = false;
    }
    // [MF:PHASE-F][OWNER:INPUT_CUSTOMER] BLUR: runRecomputeNow (immediate, no debounce)
    if (typeof runRecomputeNow === "function") runRecomputeNow("customer:blur");
  });
  // [MF:PHASE-F][OWNER:INPUT_CUSTOMER] PRIMARY WIRING LOCATION
  // INPUT: LIGHT updates + 160ms trailing heavy recompute
  customerInput.addEventListener("input", () => {
    // LIGHT: typing indicator UI
    cfUpdateTyping("customer");
    renderCustomer(); // LIGHT render (no heavy analysis)
    // Guard: skip heavy scheduling during IME composition
    if (window.__mf_isComposing === true) return;
    // [MF:PHASE-F][OWNER:INPUT_CUSTOMER] Schedule heavy recompute (160ms trailing debounce)
    if (typeof scheduleRecompute === "function") scheduleRecompute("customer:input");
  });
  // [MF:PHASE-F][OWNER:INPUT_CUSTOMER] Composition guards
  customerInput.addEventListener("compositionstart", () => { window.__mf_isComposing = true; });
  customerInput.addEventListener("compositionend", () => {
    window.__mf_isComposing = false;
    if (typeof scheduleRecompute === "function") scheduleRecompute("customer:compositionend");
  });
}

// Wire agent typing listeners
if (agentInput){
  agentInput.addEventListener("focus", () => {
    window.chatFlowTyping.focus.agent = true;
    cfUpdateTyping("agent");
  });
  // [MF:PHASE-F][OWNER:INPUT_AGENT] BLUR: immediate recompute (primary at line 14082)
  agentInput.addEventListener("blur", () => {
    window.chatFlowTyping.focus.agent = false;
    cfRenderTypingBubble("agent", false);
    if (window.chatFlowTyping.role === "agent"){
      window.chatFlowTyping.role = null;
      window.chatFlowTyping.active = false;
    }
    // [MF:PHASE-F][OWNER:INPUT_AGENT] BLUR: runRecomputeNow (immediate, no debounce)
    if (typeof runRecomputeNow === "function") runRecomputeNow("agent:blur");
  });
  // NOTE: agentInput input/composition listeners are PRIMARY at line ~19059 (consolidated wiring location)
  // [MF:PHASE-F][OWNER:INPUT_AGENT] KEYUP: LIGHT only (peek preview sync, no heavy recompute)
  agentInput.addEventListener("keyup", () => {
    cfUpdateTyping("agent");
    if (typeof cfRefreshPeek === "function" && cfPeek && cfPeek.active && cfPeek.role === "agent") cfRefreshPeek();
  }); // Keep peek preview synced for contenteditable
}

function cfCommitCustomer(){
  // If a Peek Preview ghost is showing for this role, remove it before committing
  if (typeof cfDismissPeekOnCommit === 'function') cfDismissPeekOnCommit('customer');

    // Hide typing indicator on commit
    cfRenderTypingBubble("customer", false);
    if (window.chatFlowTyping){ window.chatFlowTyping.active = false; if (window.chatFlowTyping.role === "customer") window.chatFlowTyping.role = null; }
    if (!customerInput) return;
    const t = cfNormalizeCustomer(customerInput.value);
    if (!t) return;

    // If we still have a placeholder customer turn, replace it instead of adding a new one.
    const replaced = cfConsumePlaceholder("customer", { text: t, html: undefined });
    if (!replaced){
      window.chatFlow.turns.push({ id: cfNewId(), role: "customer", text: t });
    }

    customerInput.value = "";
    renderCustomer(); // keeps legacy + MLCX state happy
    cfRender();
  }

  function cfCommitAgent(){
  // If a Peek Preview ghost is showing for this role, remove it before committing
  if (typeof cfDismissPeekOnCommit === 'function') cfDismissPeekOnCommit('agent');
    // Hide typing indicator on commit
    cfRenderTypingBubble("agent", false);
    if (window.chatFlowTyping){ window.chatFlowTyping.active = false; if (window.chatFlowTyping.role === "agent") window.chatFlowTyping.role = null; }
    if (!agentInput) return;
    const h = cfNormalizeAgentHtml(agentInput.innerHTML || "");
    if (!h) return;

    // If we still have a placeholder agent turn, replace it instead of adding a new one.
    const replaced = cfConsumePlaceholder("agent", { html: h, text: undefined });
    if (!replaced){
      window.chatFlow.turns.push({ id: cfNewId(), role: "agent", html: h });
    }

    agentInput.innerHTML = "";
    renderAgent(); // keeps legacy counters happy
    cfRender();
    // [MF:PHASE-F] COMMIT: runRecomputeNow (immediate)
    if (typeof runRecomputeNow === "function") runRecomputeNow("agent:commit");
  }

  // Drag + drop reorder (Phase B)
  let cfDragId = null;

  function cfFindIdx(id){
    return window.chatFlow.turns.findIndex(t => t.id === id);
  }

  function cfHandleDragStart(evt){
    const el = evt.target.closest?.(".chat-bubble");
    if (!el) return;
    cfDragId = el.dataset.turnId || null;
    el.classList.add("is-dragging");
    try{ evt.dataTransfer.effectAllowed = "move"; evt.dataTransfer.setData("text/plain", cfDragId || ""); }catch(_){}
  }

  function cfHandleDragEnd(evt){
    const el = evt.target.closest?.(".chat-bubble");
    if (el) el.classList.remove("is-dragging");
    cfDragId = null;
    chatTimeline?.querySelectorAll?.(".chat-bubble.is-drop-target")?.forEach(n => n.classList.remove("is-drop-target"));
  }

  function cfHandleDragOver(evt){
    if (!cfDragId) return;
    const target = evt.target.closest?.(".chat-bubble");
    if (!target || !chatTimeline.contains(target)) return;
    evt.preventDefault();
    chatTimeline.querySelectorAll(".chat-bubble.is-drop-target").forEach(n => n.classList.remove("is-drop-target"));
    target.classList.add("is-drop-target");
  }

  function cfHandleDrop(evt){
    if (!cfDragId) return;
    const target = evt.target.closest?.(".chat-bubble");
    if (!target) return;
    evt.preventDefault();

    const dropId = target.dataset.turnId;
    if (!dropId || dropId === cfDragId) return;

    const from = cfFindIdx(cfDragId);
    const to = cfFindIdx(dropId);
    if (from < 0 || to < 0) return;

    const [moved] = window.chatFlow.turns.splice(from, 1);
    window.chatFlow.turns.splice(to, 0, moved);

    cfRender();
  }

  if (customerCommitBtn) customerCommitBtn.addEventListener("click", cfCommitCustomer);
  if (agentCommitBtn) agentCommitBtn.addEventListener("click", cfCommitAgent);

  // Seed the timeline with the two static placeholder bubbles (so first commits REPLACE them).
  cfSeedPlaceholders(false);
  cfRender();

  // Make Clear behave like a "full refresh" for ChatFlow too
  // NOTE: This file already declares `const clearBtn = document.getElementById("clearBtn")`
  // later in the main wiring block. We use a uniquely named reference here to avoid
  // redeclaration errors that would stop the entire script from running.
  const cfClearBtn = document.getElementById("clearBtn");
  if (cfClearBtn){
    cfClearBtn.addEventListener("click", () => {
      // Let existing clear logic run, then reset ChatFlow
      setTimeout(() => cfResetAll(), 0);
    });
  }


  if (chatTimeline){
    chatTimeline.addEventListener("dragstart", cfHandleDragStart);
    chatTimeline.addEventListener("dragend", cfHandleDragEnd);
    chatTimeline.addEventListener("dragover", cfHandleDragOver);
    chatTimeline.addEventListener("drop", cfHandleDrop);
  }

  const charCount = document.getElementById("charCount");
  const clearBtn = document.getElementById("clearBtn");
  const copyBtn = document.getElementById("copyBtn");
  const pasteBtn = document.getElementById("pasteBtn");
  const notepadPasteBtn = document.querySelector('.notepad-tools [data-action="np-paste"]');
  const notepadCopyBtn = document.querySelector('.notepad-tools [data-action="np-copy"]');
  const notepadClearBtn = document.querySelector('.notepad-tools [data-action="np-clear"]');
  const npEditor = document.getElementById("notepadInput");
  const npStats = {
    words: document.getElementById("npWords"),
    chars: document.getElementById("npChars"),
    time: document.getElementById("npReadTime"),
    sentences: document.getElementById("npSentences")
  };
  const npUkCheckBtn = document.getElementById("npUkCheck");
  const npFlaggerBtn = document.getElementById("npFlagger");
  const npHintsToggleBtn = document.getElementById("npHintsToggle");
  const npCopyCustomerBtn = document.getElementById("npCopyCustomer");
  const npCopyAgentBtn = document.getElementById("npCopyAgent");
  const npCopyBothBtn = document.getElementById("npCopyBoth");
  const npClearBtn = document.getElementById("npClear");
  const npDrawerOverlay = document.getElementById("npDrawerOverlay");
  const npDrawer = document.getElementById("notepadInsightsDrawer");
  const npNotch = document.getElementById("npInsightsNotch");
  const msWriterOverlay = document.getElementById("msWriterOverlay");
  const msWriterDrawer = document.getElementById("msWriterDrawer");
  const msWriterNotch = document.getElementById("msWriterNotch");
  const msWriterCloseBtn = document.getElementById("msWriterDrawerClose");
  const writerTargets = {
    notepad: {
      summaryChips: document.getElementById("npSummaryChips"),
      readability: document.getElementById("npReadabilitySection"),
      sentence: document.getElementById("npSentenceSection"),
      wordInsights: document.getElementById("npWordInsightsSection"),
      structure: document.getElementById("npStructureSection")
    },
    messenger: {
      summaryChips: document.getElementById("msSummaryChips"),
      readability: document.getElementById("msReadabilitySection"),
      sentence: document.getElementById("msSentenceSection"),
      wordInsights: document.getElementById("msWordInsightsSection"),
      structure: document.getElementById("msStructureSection")
    }
  };

  // Writer Insights (Messenger): role-aware source selector (Agent vs Customer)
  window.__msWriterRole = window.__msWriterRole || "agent";

  function getMessengerCustomerTextPlain(){
    const el = document.getElementById("customerInput");
    return el && typeof el.value === "string" ? el.value : "";
  }

  function getMessengerAgentTextPlainForWriter(){
    const el = document.getElementById("agentInput");
    if (!el) return "";
    // agentInput is a contenteditable div (not a textarea) so we must read textContent/innerText
    const raw = (typeof el.innerText === "string") ? el.innerText : (el.textContent || "");
    return String(raw || "").replace(/\u00A0/g, " ").trimEnd();
  }

  function getMessengerWriterSourceText(role){
    return role === "customer" ? getMessengerCustomerTextPlain() : getMessengerAgentTextPlainForWriter();
  }

  function setMsWriterRole(role){
    const next = role === "customer" ? "customer" : "agent";
    window.__msWriterRole = next;

    const hint = document.getElementById("msWriterRoleHint");
    if (hint) hint.textContent = next === "customer" ? "Analysing: Customer message" : "Analysing: Agent reply";

    const btns = document.querySelectorAll("#msWriterDrawer .ms-writer-role-btn[data-role]");
    btns.forEach(btn => {
      const isActive = btn.getAttribute("data-role") === next;
      btn.classList.toggle("active", isActive);
      btn.setAttribute("aria-checked", isActive ? "true" : "false");
    });

    // refresh insights via unified scheduler (role-specific)
    if (typeof scheduleRecompute === "function") scheduleRecompute("msWriterRole");
  }

  function wireMsWriterRoleToggle(){
    const drawer = document.getElementById("msWriterDrawer");
    if (!drawer) return;
    const btns = drawer.querySelectorAll(".ms-writer-role-btn[data-role]");
    if (!btns || !btns.length) return;
    btns.forEach(btn => {
      btn.addEventListener("click", () => setMsWriterRole(btn.getAttribute("data-role")));
    });
  }
  const colourButtons = document.querySelectorAll(".pill-button[data-colour]");
  const themeButtons = document.querySelectorAll(".theme-toggle button");
  const addCustomerBubbleBtn = document.getElementById("addCustomerBubbleBtn");
  const addAgentBubbleBtn = document.getElementById("addAgentBubbleBtn");
  const mlcxToggleBtn = document.getElementById("mlcxToggleBtn");
  let npHintsMuted = false;
  let notepadInsightsTimer = null;
  let messengerInsightsTimer = null;
  const isNotepadLayout = () => (document.body?.dataset?.layout === "notepad");
  const isMessengerLayout = () => (document.body?.dataset?.layout === "split");

  // ======================
  // Notepad editor helpers
  // ======================
  function getNotepadText() {
    return npEditor ? (npEditor.innerText || "") : "";
  }

  function setNotepadContent(text) {
    if (!npEditor) return;
    npEditor.textContent = text || "";
    if (isNotepadLayout()) {
      updateNotepadStats();
    }
  }

  function setNpStat(node, value) {
    if (node) {
      node.textContent = value;
    }
  }

  function updateNotepadStats() {
    if (!npEditor) return;
    const text = getNotepadText();
    const words = text.trim() ? text.trim().split(/\s+/).length : 0;
    const chars = text.length;
    const sentences = (text.match(/[.!?]+/g) || []).length;
    const minutesFloat = words / 200;
    let timeLabel;
    if (words === 0) {
      timeLabel = "Reading time: 0 min";
    } else if (minutesFloat < 0.5) {
      timeLabel = "Reading time: < 1 min";
    } else {
      const mins = Math.round(minutesFloat);
      timeLabel = `Reading time: ${mins} min${mins > 1 ? "s" : ""}`;
    }
    setNpStat(npStats.words, `Words: ${words}`);
    setNpStat(npStats.chars, `Characters: ${chars}`);
    setNpStat(npStats.sentences, `Sentences: ${sentences}`);
    setNpStat(npStats.time, timeLabel);
    runNotepadInsights(text);
  }

  function runNotepadInsights(text) {
    if (notepadInsightsTimer) {
      clearTimeout(notepadInsightsTimer);
    }
    const snapshotText = typeof text === "string" ? text : "";
    notepadInsightsTimer = window.setTimeout(() => {
      doNotepadInsights(snapshotText);
    }, 500);
  }

  function runMessengerInsights(text, context) {
    if (messengerInsightsTimer) {
      clearTimeout(messengerInsightsTimer);
    }
    const snapshotText = typeof text === "string" ? text : "";
    const ctx = context && typeof context === "object" ? context : { mode: "messenger", role: (window.__msWriterRole || "agent") };
    messengerInsightsTimer = window.setTimeout(() => {
      renderWriterInsights(snapshotText, writerTargets.messenger, ctx);
    }, 260);
  }function renderWriterInsights(text, targets, context) {
    const safeText = typeof text === "string" ? text : "";
    const slots = targets || writerTargets.notepad;
    const ctx = context && typeof context === "object" ? context : { mode: (targets === writerTargets.messenger ? "messenger" : "notepad"), role: "agent" };
    updateReadability(safeText, slots?.readability);
    updateSentenceDiagnostics(safeText, slots?.sentence);
    updateWordInsights(safeText, slots?.wordInsights);
    updateStructureSuggestions(safeText, slots?.structure);
    updateNotepadSummaryChips(safeText, slots?.summaryChips);
    updateToneEmpathyCoaching(safeText, slots?.readability, ctx);
  }function doNotepadInsights(text) {
    renderWriterInsights(text, writerTargets.notepad, { mode: "notepad", role: "agent" });
  }

  function updateReadability(text, nodeOverride) {
    const node = nodeOverride || document.getElementById("npReadabilitySection");
    if (!node) return;
    if (!text.trim()) {
      node.innerHTML = "<p>Start typing to see readability guidance.</p>";
      return;
    }
    const words = text.trim().split(/\s+/).length;
    const sentences = Math.max(1, (text.match(/[.!?]+/g) || []).length);
    const average = words / sentences;
    let tone = "Balanced";
    if (average < 12) tone = "Punchy";
    else if (average > 22) tone = "Dense";
    node.innerHTML = `<p><strong>${tone}</strong> tone · avg sentence length ${average.toFixed(1)} words. Aim for 12–18 words for confident clarity.</p>`;
  }

  function updateSentenceDiagnostics(text, nodeOverride) {
    const node = nodeOverride || document.getElementById("npSentenceSection");
    if (!node) return;
    if (!text.trim()) {
      node.innerHTML = "<p>Write a few sentences to spot rhythm issues.</p>";
      return;
    }
    const sentences = text.split(/(?<=[.!?])\s+/).map(s => s.trim()).filter(Boolean);
    const longOnes = sentences.filter(s => s.split(/\s+/).length > 28);
    if (!longOnes.length) {
      node.innerHTML = "<p>No long sentences detected - flow looks controlled.</p>";
      return;
    }
    const preview = longOnes.slice(0, 2).map((s, idx) => `<li>Sentence ${idx + 1}: ${s.slice(0, 80)}${s.length > 80 ? "…" : ""}</li>`).join("");
    node.innerHTML = `<p>${longOnes.length} long sentence${longOnes.length > 1 ? "s" : ""} could be split:</p><ul>${preview}</ul>`;
  }

  function updateWordInsights(text, nodeOverride) {
    const node = nodeOverride || document.getElementById("npWordInsightsSection");
    if (!node) return;
    if (!text.trim()) {
      node.innerHTML = "<p>Repeated words and jargon will appear here.</p>";
      return;
    }
    const counts = {};
    text.toLowerCase().split(/[^a-zA-Z']+/).filter(token => token.length > 3).forEach(token => {
      counts[token] = (counts[token] || 0) + 1;
    });
    const ranked = Object.entries(counts).filter(([, count]) => count > 2).sort((a, b) => b[1] - a[1]).slice(0, 3);
    if (!ranked.length) {
      node.innerHTML = "<p>No heavy repetition spotted. Nice variety.</p>";
      return;
    }
    const list = ranked.map(([word, count]) => `<li><strong>${word}</strong> appears ${count}× - consider a synonym.</li>`).join("");
    node.innerHTML = `<p>Repeated language to review:</p><ul>${list}</ul>`;
  }

  function updateStructureSuggestions(text, nodeOverride) {
    const node = nodeOverride || document.getElementById("npStructureSection");
    if (!node) return;
    if (!text.trim()) {
      node.innerHTML = "<p>Paragraph spacing tips will show here.</p>";
      return;
    }
    const paragraphs = text.split(/\n{2,}/).map(p => p.trim()).filter(Boolean);
    const suggestions = [];
    if (paragraphs.length < 3) {
      suggestions.push("Break ideas into 3+ paragraphs to avoid walls of text.");
    }
    if (paragraphs.some(p => p.split(/\s+/).length > 80)) {
      suggestions.push("At least one paragraph is quite long - consider bulleting key steps.");
    }
    if (!suggestions.length) {
      node.innerHTML = "<p>Structure looks balanced. Keep highlighting next steps.</p>";
      return;
    }
    node.innerHTML = `<ul>${suggestions.map(s => `<li>${s}</li>`).join("")}</ul>`;
  }

  /* Tone / Empathy augment from LID + CV */
  
  /* Tone / Empathy coaching: role-aware (Agent vs Customer) */
  function updateToneEmpathyCoaching(text, sectionOverride, context) {
    const section = sectionOverride || document.getElementById("npReadabilitySection");
    if (!section) return;

    const ctx = context && typeof context === "object" ? context : { mode: "notepad", role: "agent" };
    const role = ctx.role === "customer" ? "customer" : "agent";
    const mode = ctx.mode === "messenger" ? "messenger" : "notepad";

    const old = section.querySelector(".np-lidcv-coaching");
    if (old) old.remove();

    const safeText = typeof text === "string" ? text : "";
    const hasText = safeText.trim().length > 0;
    if (!hasText) return;

    

    // Prefer MFCX Brain v2 coaching if available (short + consistent)
    try {
      const v2State = window.mlcxState && window.mlcxState.brainV2 ? window.mlcxState.brainV2 : null;
      if (v2State){
        const cust = v2State.customer || null;
        const ag   = v2State.agent || null;

        // In messenger mode, agent coaching is driven by CUSTOMER needs, then checks AGENT draft gaps.
        const useCustomer = (mode === "messenger");
        const customerLines = (cust && Array.isArray(cust.insights)) ? cust.insights : [];
        const agentLines = (ag && Array.isArray(ag.insights)) ? ag.insights : [];
        const praiseLines = (ag && Array.isArray(ag.praise)) ? ag.praise : [];

        const container = document.createElement("div");
        container.className = "np-lidcv-coaching";
        container.style.marginTop = "10px";
        container.style.padding = "10px 12px";
        container.style.borderRadius = "12px";
        container.style.background = "rgba(255,255,255,0.06)";
        container.style.border = "1px solid rgba(255,255,255,0.10)";

        const heading = (role === "customer")
          ? "What to respond to"
          : "Writing coach tips";

        let body = "";
        const lines = [];
        if (role === "customer"){
          // customer view: always show what they’re signalling (anchors)
          customerLines.slice(0, 3).forEach(x => lines.push(x));
        } else {
          // agent view: show customer anchors first (messenger), then agent draft gaps
          if (useCustomer) customerLines.slice(0, 2).forEach(x => lines.push(x));
          agentLines.slice(0, 3 - lines.length).forEach(x => lines.push(x));
          if (praiseLines.length) body += `<p style="margin:0 0 6px 0;"><strong>${praiseLines[0]}</strong></p>`;
        }

        if (!lines.length){
          body += `<p style="margin:0;">No major concerns detected - keep it clear, simple, and step‑by‑step.</p>`;
        } else {
          body += `<ul style="margin:0; padding-left:1.15em;">${lines.map(l => `<li style="margin:0 0 4px 0;">${l}</li>`).join("")}</ul>`;
        }

        container.innerHTML = `<p style="margin:0 0 6px 0;"><strong>${heading}</strong></p>${body}`;
        section.appendChild(container);
        return;
      }
    } catch (e) {
      // fall through to legacy coaching below
    }

// In messenger mode, agent coaching should be driven by the CUSTOMER message signals.
    const customerText = mode === "messenger" ? getMessengerCustomerTextPlain() : safeText;
    const agentText = safeText;

    const customerSnap = buildNotepadInsightSnapshot(customerText);
    const agentSnap = buildNotepadInsightSnapshot(agentText);

    if (!customerSnap.hasText && !agentSnap.hasText) return;

    const toTitle = (s) => (s ? s.charAt(0).toUpperCase() + s.slice(1) : "");
    const listJoin = (arr) => arr.filter(Boolean).join(" & ");

    const lidToParts = (lid) => {
      if (!lid || !lid.hasLid) return [];
      const parts = [];
      if (lid.loss) parts.push("loss");
      if (lid.inconvenience) parts.push("inconvenience");
      if (lid.distress) parts.push("distress");
      return parts;
    };

    const cvToParts = (cv) => {
      if (!cv || !cv.hasVulnerability) return [];
      const parts = [];
      for (const [key, value] of Object.entries(cv)) {
        if (key === "hasVulnerability") continue;
        if (value === "possible" || value === "clear") parts.push(toTitle(key));
      }
      return parts;
    };

    const lidParts = lidToParts(customerSnap.lid);
    const cvParts = cvToParts(customerSnap.cv);

    const hasEmpathy = /\b(sorry|i\s+understand|i\s+know\s+this\s+is|i\s+appreciate|thanks\s+for\s+letting\s+us\s+know|that\s+must\s+be)\b/i.test(agentText);
    const hasNextSteps = /(next\s+step|here\s*'?s\s+what\s+we\s+can\s+do|we\s+will|i\s+can|please\s+send|could\s+you\s+confirm|to\s+help\s+me)\b/i.test(agentText);
    const hasQuestions = /\?/.test(agentText);

    let html = "";

    if (role === "customer") {
      // CUSTOMER VIEW: summarise signals and translate them into response anchors.
      const blocks = [];

      if (lidParts.length) {
        blocks.push(`<p><strong>What they're feeling:</strong> Signs of ${listJoin(lidParts)}.</p>`);
      }
      if (cvParts.length) {
        blocks.push(`<p><strong>Possible vulnerability:</strong> ${listJoin(cvParts)} - keep the response simple, calm, and non‑pressuring.</p>`);
      }

      // Basic intent scan
      const intent = [];
      const lower = customerText.toLowerCase();
      if (/\brefund|money back|reimburse|cost|price|excess|pay\b/.test(lower)) intent.push("cost / payment concern");
      if (/\bwhen|how long|timeline|eta|today|tomorrow\b/.test(lower)) intent.push("timeline question");
      if (/\bupdate|status|progress|any news\b/.test(lower)) intent.push("status update request");
      if (/\bcomplain|unhappy|not happy|frustrat|angry\b/.test(lower)) intent.push("complaint tone");
      if (/\bcall\s+me|phone|ring\b/.test(lower)) intent.push("wants a call");
      if (intent.length) {
        blocks.push(`<p><strong>Likely intent:</strong> ${intent.join(", ")}.</p>`);
      }

      const anchors = [];
      anchors.push("Open with an acknowledgement + apology where appropriate.");
      anchors.push("Confirm what you understand (1 short line).");
      anchors.push("Give 1–3 clear next steps (bullets) + what you need from them.");
      anchors.push("Set expectation on timeframes and when you’ll update them.");
      html = `<div class="np-lidcv-coaching">
        <p style="margin:0 0 6px;"><strong>Customer lens</strong> - translate this into a clean reply.</p>
        ${blocks.join("")}
        <p style="margin:8px 0 6px;"><strong>Reply anchors:</strong></p>
        <ul>${anchors.map(a => `<li>${a}</li>`).join("")}</ul>
      </div>`;
    } else {
      // AGENT VIEW: coach based on customer signals + agent clarity.
      const blocks = [];

      if (lidParts.length && !hasEmpathy) {
        blocks.push(`<p><strong>Empathy required:</strong> Customer expresses ${listJoin(lidParts)} - add a short acknowledgement in line 1.</p>`);
      } else if (lidParts.length) {
        blocks.push(`<p><strong>Empathy check:</strong> Customer signals ${listJoin(lidParts)} - good to acknowledge early (you already do).</p>`);
      }

      if (cvParts.length) {
        blocks.push(`<p><strong>Consider vulnerability:</strong> ${listJoin(cvParts)} - keep instructions simple, avoid pressure, offer options.</p>`);
      }

      if (agentSnap.hasText) {
        const notes = [];
        if (!hasNextSteps) notes.push("Add a clear 'next step' line (what you'll do + what you need).");
        if (!hasQuestions) notes.push("If you need info, ask 1–2 focused questions (avoid a long list).");
        if (agentText.split(/\n/).filter(l => l.trim()).length < 2) notes.push("Break into short paragraphs (mobile-friendly).");

        if (notes.length) {
          blocks.push(`<p><strong>Clarity tweak:</strong></p><ul>${notes.map(n => `<li>${n}</li>`).join("")}</ul>`);
        }
      }

      if (blocks.length) {
        html = `<div class="np-lidcv-coaching">${blocks.join("")}</div>`;
      }
    }

    if (html) section.insertAdjacentHTML("beforeend", html);
  }
/* -------------------------------
     NOTEPAD INSIGHTS: LID DETECTOR
     ------------------------------- */
  function detectLidSignals(text) {
    const lower = (text || "").toLowerCase();

    const lossTerms = [
      "lost income", "losing income", "lost wages", "lost money", "out of pocket",
      "i can't work", "can't work", "unable to work", "written off", "total loss",
      "my car is gone", "stolen", "taken from me", "lost my", "damage to", "ruined"
    ];

    const inconvenienceTerms = [
      "i can't get", "can't get to work", "can't go", "no transport", "stuck",
      "delayed", "waiting", "still not resolved", "again", "keep waiting",
      "inconvenient", "massive inconvenience"
    ];

    const distressTerms = [
      "really upset", "furious", "angry", "stressed", "stressed out",
      "ridiculous", "unacceptable", "disgusted", "worried", "anxious",
      "can't sleep", "this has impacted me", "i'm panicking", "panic",
      "this is affecting me", "this has affected me"
    ];

    function checkBank(bank) {
      let hits = 0;
      for (const t of bank) {
        if (lower.includes(t)) hits++;
      }
      return hits;
    }

    const loss = checkBank(lossTerms);
    const inconvenience = checkBank(inconvenienceTerms);
    const distress = checkBank(distressTerms);

    const total = loss + inconvenience + distress;

    let severity = "none";
    if (total === 1) severity = "warn";
    if (total >= 2) severity = "high";

    return {
      loss: loss > 0,
      inconvenience: inconvenience > 0,
      distress: distress > 0,
      severity,
      hasLid: total > 0
    };
  }

  /* -----------------------------------------
     NOTEPAD INSIGHTS: VULNERABILITY DETECTOR
     ----------------------------------------- */
  function detectVulnerabilitySignals(text) {
    const lower = (text || "").toLowerCase();

    const healthTerms = [
      "hospital", "surgery", "recovering", "disabled", "disability",
      "chronic pain", "mental health", "depression", "anxiety", "ptsd",
      "terminal", "ill", "unwell", "sick"
    ];

    const capabilityTerms = [
      "i don't understand", "this is confusing", "i struggle", "i can't read this",
      "too complicated", "english isn't my first language", "dyslexia"
    ];

    const resilienceTerms = [
      "lost my job", "lost my partner", "death in the family", "passed away",
      "divorce", "can't cope", "going through a lot", "multiple issues"
    ];

    const digitalTerms = [
      "no wifi", "no internet", "can't use the app", "don't know how to",
      "old phone", "can't log in"
    ];

    const financialTerms = [
      "can't pay", "behind on bills", "struggling financially", "in debt",
      "arrears", "missed rent", "missed mortgage"
    ];

    function detect(bank) {
      let hits = 0;
      for (const term of bank) {
        if (lower.includes(term)) hits++;
      }
      if (hits === 0) return "none";
      if (hits === 1) return "possible";
      return "clear";
    }

    const res = {
      health: detect(healthTerms),
      capability: detect(capabilityTerms),
      resilience: detect(resilienceTerms),
      digital: detect(digitalTerms),
      financial: detect(financialTerms)
    };

    res.hasVulnerability = ["possible", "clear"].some(level => Object.values(res).includes(level));

    return res;
  }

  function buildNotepadInsightSnapshot(text) {
    const raw = text || "";
    const lower = raw.toLowerCase();

    const wordCount = raw.trim() ? raw.trim().split(/\s+/).length : 0;
    const sentenceCount = Math.max(1, (raw.match(/[.!?]+/g) || []).length);
    const avgSentenceLen = wordCount ? wordCount / sentenceCount : 0;

    let toneLabel = "Balanced";
    let toneLevel = "ok";
    if (avgSentenceLen < 12) {
      toneLabel = "Punchy";
      toneLevel = "ok";
    } else if (avgSentenceLen > 22 && avgSentenceLen <= 30) {
      toneLabel = "Dense";
      toneLevel = "warn";
    } else if (avgSentenceLen > 30) {
      toneLabel = "Very dense";
      toneLevel = "high";
    }

    const localJargon = [
      "indemnity",
      "liability",
      "underwriting",
      "policy wording",
      "non-fault",
      "mta",
      "endorsement",
      "premium",
      "excess"
    ];

    const localCost = [
      "charge",
      "fees",
      "cost",
      "increase",
      "deductible",
      "excess",
      "outstanding",
      "arrears",
      "debit",
      "payment plan"
    ];

    const localClarity = [
      "as per",
      "further to",
      "notwithstanding",
      "in respect of",
      "pursuant to",
      "aforementioned"
    ];

    const globalScope = typeof window !== "undefined" ? window : globalThis;

    const normaliseTriggerCollection = (source, fallback) => {
      if (!Array.isArray(source) || !source.length) {
        return fallback;
      }
      const mapped = source
        .map(entry => {
          if (!entry) return null;
          if (entry instanceof RegExp) return entry;
          if (typeof entry === "string") return entry;
          if (typeof entry === "object") {
            if (entry.phrase) return entry.phrase;
            if (entry.keyword) return entry.keyword;
            if (entry.pattern instanceof RegExp) return entry.pattern;
            if (entry.pattern && typeof entry.pattern === "string") return entry.pattern;
          }
          return null;
        })
        .filter(Boolean);
      return mapped.length ? mapped : fallback;
    };

    const escapeRegex = (value) => value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

    const countHits = (haystack, terms) => {
      const uniq = new Set();
      for (const term of terms) {
        if (!term) continue;
        if (term instanceof RegExp) {
          const flags = term.flags?.includes("g") ? term.flags : `${term.flags || ""}g`;
          const regex = new RegExp(term.source, flags);
          const matches = haystack.match(regex);
          if (matches && matches.length) {
            matches.forEach(m => {
              const key = (m || "").toLowerCase().trim();
              if (key) uniq.add(key);
            });
          }
          continue;
        }
        const clean = term.toString().trim();
        if (!clean) continue;
        const regex = new RegExp(`\\b${escapeRegex(clean)}\\b`, "gi");
        const matches = haystack.match(regex);
        if (matches && matches.length) {
          matches.forEach(m => {
            const key = (m || "").toLowerCase().trim();
            if (key) uniq.add(key);
          });
        }
      }
      return uniq.size;
    };

    const jargonSource = normaliseTriggerCollection(globalScope?.jargonTriggers, localJargon);
    const costSource = normaliseTriggerCollection(globalScope?.costStressTriggers, localCost);
    const claritySource = normaliseTriggerCollection(globalScope?.clarityTriggers, localClarity);

    const jargonHits = countHits(lower, jargonSource);
    const costHits = countHits(lower, costSource);
    const clarityHits = countHits(lower, claritySource);

    const levelFromCount = (count) => {
      if (count === 0) return "ok";
      if (count <= 3) return "warn";
      return "high";
    };

    return {
      hasText: !!raw.trim(),
      toneLabel,
      toneLevel,
      jargonHits,
      jargonLevel: levelFromCount(jargonHits),
      costHits,
      costLevel: levelFromCount(costHits),
      clarityHits,
      clarityLevel: levelFromCount(clarityHits),
      lid: detectLidSignals(raw),
      cv: detectVulnerabilitySignals(raw)
    };
  }

  function updateNotepadSummaryChips(text, containerOverride) {
    const container = containerOverride || document.getElementById("npSummaryChips");
    if (!container) return;

    const snapshot = buildNotepadInsightSnapshot(text);

    if (!snapshot.hasText) {
      container.innerHTML = "";
      return;
    }

    const chips = [];

    const tooltips = {
      tone: "Average sentence length; Balanced = 12–22 words for clear delivery.",
      jargon: "Unique jargon terms detected; aim for plain language where possible.",
      cost: "Money/fees references that may worry customers; keep them clear.",
      clarity: "Formal or legalistic phrases that can be simplified.",
      lid: "Loss/Inconvenience/Distress signals; acknowledge and respond with care.",
      cv: "Customer vulnerability cues (health, financial, digital, etc.)."
    };

    chips.push({
      label: "Tone",
      value: snapshot.toneLabel,
      level: snapshot.toneLevel,
      tooltip: tooltips.tone
    });

    chips.push({
      label: "Jargon",
      value: snapshot.jargonHits === 0
        ? "Clean"
        : `${snapshot.jargonHits} ${snapshot.jargonHits === 1 ? "term" : "terms"}`,
      level: snapshot.jargonLevel,
      tooltip: tooltips.jargon
    });

    chips.push({
      label: "Cost",
      value: snapshot.costHits === 0
        ? "Light"
        : `${snapshot.costHits} ${snapshot.costHits === 1 ? "ref" : "refs"}`,
      level: snapshot.costLevel,
      tooltip: tooltips.cost
    });

    chips.push({
      label: "Clarity",
      value: snapshot.clarityHits === 0
        ? "Plain"
        : `${snapshot.clarityHits} ${snapshot.clarityHits === 1 ? "phrase" : "phrases"}`,
      level: snapshot.clarityLevel,
      tooltip: tooltips.clarity
    });

    // LID chip
    if (snapshot.lid && snapshot.lid.hasLid) {
      const lidParts = [];
      if (snapshot.lid.loss) lidParts.push("Loss");
      if (snapshot.lid.inconvenience) lidParts.push("Inconv");
      if (snapshot.lid.distress) lidParts.push("Distress");
      const lidValue = lidParts.join(" · ") || "Signal";
      chips.push({
        label: "LID",
        value: lidValue,
        level: snapshot.lid.severity || "warn",
        tooltip: tooltips.lid
      });
    }

    // Vulnerability chip
    if (snapshot.cv && snapshot.cv.hasVulnerability) {
      const strongest = [];
      for (const [key, value] of Object.entries(snapshot.cv)) {
        if (key === "hasVulnerability") continue;
        if (["possible", "clear"].includes(value)) {
          strongest.push(key.charAt(0).toUpperCase() + key.slice(1));
        }
      }
      chips.push({
        label: "CV",
        value: (strongest.slice(0, 2).join(" · ")) || "Signal",
        level: "warn",
        tooltip: tooltips.cv
      });
    }

    container.innerHTML = chips.map(chip => {
      const levelClass =
        chip.level === "high"
          ? "np-summary-chip--high"
          : chip.level === "warn"
          ? "np-summary-chip--warn"
          : "np-summary-chip--ok";

      return (
        `<span class="np-summary-chip ${levelClass}" title="${chip.tooltip || ""}">
          ${chip.label}: ${chip.value}
        </span>`
      );
    }).join("");
  }

  async function pasteIntoNotepadFromClipboard() {
    if (!navigator.clipboard?.readText || !npEditor) return;
    try {
      const text = await navigator.clipboard.readText();
      if (!text) return;
      npEditor.focus();
      document.execCommand("insertText", false, text);
      updateNotepadStats();
    } catch (error) {
      console.warn("Notepad paste failed", error);
    }
  }

  async function copyNotepadToClipboard() {
    if (!navigator.clipboard?.writeText) return;
    try {
      await navigator.clipboard.writeText(getNotepadText());
    } catch (error) {
      console.warn("Notepad copy failed", error);
    }
  }

  function clearNotepadEditor() {
    setNotepadContent("");
  }

  function cleanNotepadContent() {
    if (!npEditor) return;
    const tidy = getNotepadText()
      .split(/\n/)
      .map(line => line.trimEnd())
      .join("\n")
      .replace(/\n{3,}/g, "\n\n")
      .trim();
    setNotepadContent(tidy);
  }

  function openNotepadDrawer() {
    if (!npDrawerOverlay || !npDrawer) return;
    npDrawerOverlay.classList.add("is-open");
    npDrawerOverlay.setAttribute("aria-hidden", "false");
    npNotch?.setAttribute("aria-expanded", "true");

    // stop pulsing when drawer is open
    npNotch?.classList.remove("cx-notch-pulse");
    npNotch?.classList.add("is-hot");
  }

  function closeNotepadDrawer() {
    if (!npDrawerOverlay || !npDrawer) return;
    npDrawerOverlay.classList.remove("is-open");
    npDrawerOverlay.setAttribute("aria-hidden", "true");
    npNotch?.setAttribute("aria-expanded", "false");

    npNotch?.classList.remove("is-hot");

    // resume pulsing when drawer is closed
    npNotch?.classList.add("cx-notch-pulse");
  }

  function openMessengerDrawer() {
    if (!msWriterOverlay || !msWriterDrawer || !isMessengerLayout()) return;
    msWriterOverlay.classList.add("is-open");
    msWriterOverlay.setAttribute("aria-hidden", "false");
    msWriterNotch?.setAttribute("aria-expanded", "true");

    msWriterNotch?.classList.remove("cx-notch-pulse");
    msWriterNotch?.classList.add("is-hot");
    document.body.classList.add("writer-drawer-open");

    wireMsWriterRoleToggle();
    setMsWriterRole(window.__msWriterRole || "agent");
  }

  function closeMessengerDrawer() {
    if (!msWriterOverlay || !msWriterDrawer) return;
    msWriterOverlay.classList.remove("is-open");
    msWriterOverlay.setAttribute("aria-hidden", "true");
    msWriterNotch?.setAttribute("aria-expanded", "false");

    msWriterNotch?.classList.remove("is-hot");
    document.body.classList.remove("writer-drawer-open");

    if (isMessengerLayout()) {
      msWriterNotch?.classList.add("cx-notch-pulse");
    } else {
      msWriterNotch?.classList.remove("cx-notch-pulse");
    }
  }

  function toggleNotepadDrawer() {
    if (!npDrawerOverlay) return;
    if (npDrawerOverlay.classList.contains("is-open")) {
      closeNotepadDrawer();
    } else {
      openNotepadDrawer();
    }
  }

  function toggleMessengerDrawer() {
    if (!msWriterOverlay) return;
    if (msWriterOverlay.classList.contains("is-open")) {
      closeMessengerDrawer();
    } else {
      openMessengerDrawer();
    }
  }

  if (npEditor) {
    npEditor.addEventListener("input", () => {
      if (isNotepadLayout()) {
        updateNotepadStats();
      }
    });
  }

  // Click on highlighted words in Notepad to show the same tooltip behaviour as Messenger
  if (npEditor) {
    npEditor.addEventListener("click", (event) => {
      if (!isNotepadLayout()) return;
      const target = event.target;
      if (!target || !target.classList) return;
      if (target.classList.contains("spell-issue") || target.classList.contains("uk-issue")) {
        event.stopPropagation();
        if (typeof showIssueTooltip === "function") {
          showIssueTooltip(target);
        }
      }
    });
  }

  // Toolbar buttons route through applyFormat; no extra listeners needed here.

  npCopyCustomerBtn?.addEventListener("click", () => {
    if (!isNotepadLayout()) return;
    const text = customerInput ? (customerInput.value || "") : "";
    setNotepadContent(text);
  });

  npCopyAgentBtn?.addEventListener("click", () => {
    if (!isNotepadLayout()) return;
    const text = agentInput ? (agentInput.innerText || agentInput.textContent || "") : "";
    setNotepadContent(text);
  });

  npCopyBothBtn?.addEventListener("click", () => {
    if (!isNotepadLayout()) return;
    const customerText = customerInput ? (customerInput.value || "") : "";
    const agentText = agentInput ? (agentInput.innerText || agentInput.textContent || "") : "";
    const combined = [customerText, agentText].filter(Boolean).join("\n\n");
    setNotepadContent(combined);
  });

  npClearBtn?.addEventListener("click", () => {
    if (!isNotepadLayout()) return;
    clearNotepadEditor();
  });

  /* UK Spelling Check - Notepad Only */
  npUkCheckBtn?.addEventListener("click", () => {
    if (!isNotepadLayout() || !npEditor) return;

    try {
      stripColoursAndIssueMarks(npEditor);
      if (typeof markUkIssues === "function") {
        markUkIssues(npEditor);
      }
      runNotepadInsights(getNotepadText());
      updateNotepadStats();
    } catch (err) {
      console.warn("Notepad UK check failed:", err);
    }
  });

  /* Full Flagger Engine - Notepad Only */
  npFlaggerBtn?.addEventListener("click", () => {
    if (!isNotepadLayout() || !npEditor) return;

    try {
      stripColoursAndIssueMarks(npEditor);
      if (typeof markAllIssues === "function") {
        markAllIssues(npEditor);
      }
      if (typeof markJargonIssues === "function") {
        markJargonIssues(npEditor);
      }
      runNotepadInsights(getNotepadText());
      updateNotepadStats();
    } catch (err) {
      console.warn("Notepad flagger failed:", err);
    }
  });

  /* Toggle inline coaching hints */
  npHintsToggleBtn?.addEventListener("click", () => {
    if (!isNotepadLayout() || !npEditor) return;

    npHintsMuted = !npHintsMuted;

    npHintsToggleBtn.dataset.state = npHintsMuted ? "off" : "on";
    npHintsToggleBtn.textContent = npHintsMuted ? "Hints OFF" : "Hints ON";

    try {
      stripColoursAndIssueMarks(npEditor);
      if (!npHintsMuted) {
        if (typeof markUkIssues === "function") {
          markUkIssues(npEditor);
        }
        if (typeof markAllIssues === "function") {
          markAllIssues(npEditor);
        }
        if (typeof markJargonIssues === "function") {
          markJargonIssues(npEditor);
        }
      }
      runNotepadInsights(getNotepadText());
      updateNotepadStats();
    } catch (err) {
      console.warn("Notepad hints toggle failed:", err);
    }
  });

  npNotch?.addEventListener("click", () => {
    if (!isNotepadLayout()) return;
    toggleNotepadDrawer();
  });

  const npDim = npDrawerOverlay?.querySelector(".np-dim");
  npDim?.addEventListener("click", () => {
    if (!isNotepadLayout()) return;
    closeNotepadDrawer();
  });

  const npCloseBtn = npDrawerOverlay?.querySelector(".np-drawer-close-btn");
  npCloseBtn?.addEventListener("click", () => {
    if (!isNotepadLayout()) return;
    closeNotepadDrawer();
  });

  msWriterNotch?.addEventListener("click", () => {
    if (!isMessengerLayout()) return;
    toggleMessengerDrawer();
  });

  const msDim = msWriterOverlay?.querySelector(".ms-dim");
  msDim?.addEventListener("click", () => {
    if (!isMessengerLayout()) return;
    closeMessengerDrawer();
  });

  msWriterCloseBtn?.addEventListener("click", () => {
    if (!isMessengerLayout()) return;
    closeMessengerDrawer();
  });

  if (isNotepadLayout() && !npDrawerOverlay?.classList.contains("is-open")) {
    npNotch?.classList.add("cx-notch-pulse");
  }

  if (isMessengerLayout() && !msWriterOverlay?.classList.contains("is-open")) {
    msWriterNotch?.classList.add("cx-notch-pulse");
  }

  if (isMessengerLayout()) {
    // [MF:P-F] Route initial layout Writer Insights through scheduler, not direct
    if (typeof scheduleRecompute === "function") scheduleRecompute("layout:init");
  }

  document.addEventListener("layoutchange", (event) => {
    const mode = event.detail?.mode || document.body.dataset.layout;
    if (mode === "notepad") {
      updateNotepadStats();
      if (npDrawerOverlay && !npDrawerOverlay.classList.contains("is-open")) {
        npNotch?.classList.add("cx-notch-pulse");
      }
      closeMessengerDrawer();
    } else if (mode === "split") {
      closeNotepadDrawer();
      if (msWriterOverlay && !msWriterOverlay.classList.contains("is-open")) {
        msWriterNotch?.classList.add("cx-notch-pulse");
      }
      // [MF:P-F] Route layout change Writer Insights through scheduler
      if (typeof scheduleRecompute === "function") scheduleRecompute("layout:change-split");
    } else {
      closeNotepadDrawer();
      closeMessengerDrawer();
    }
  });

  document.addEventListener("keydown", (event) => {
    if (event.key === "Escape") {
      if (isNotepadLayout()) {
        closeNotepadDrawer();
      }
      if (isMessengerLayout()) {
        closeMessengerDrawer();
      }
    }
  });

  // Phase 19.11: Runtime-only Dev Lab deletion log
  const mlcxDeletionLog = [];


  // --- MLCX core state (Phase 1 scaffold) ---
  const mlcxState = {
    rawText: "",
    sentences: [],
    totalChars: 0,
    source: "customer", // "customer" | "notes"
    // MLCX Alpha – vulnerability summary wiring (non-destructive patch)
    vulnerability: {
      hasFlag: false,
      categories: [],
      severity: 'none',
      phrases: [],
      notes: ''
    }
  };
  let mlcxCoaching = true;

  function splitIntoSentences(text) {
    if (!text) return [];
    // Normalise line breaks
    const normalised = text.replace(/\r\n/g, "\n");
    const pieces = normalised
      .split(/\n+/)
      .map(p => p.trim())
      .filter(Boolean);

    const sentences = [];
    for (const piece of pieces) {
      const matches = piece.match(/[^.!?]+[.!?]?/g);
      if (matches) {
        for (const m of matches) {
          const s = m.trim();
          if (s.length) sentences.push(s);
        }
      } else if (piece.length) {
        sentences.push(piece);
      }
    }
    return sentences;
  }


  
  // --- Phase 12: MLCX + CiVC category meta + trigger dictionaries ---
  const mlcxCategoryMeta = {
    frustration: { key: "frustration", label: "Frustration", icon: "\u26a1", tagClass: "mlcx-tag--frustration" },
    confusion:   { key: "confusion",   label: "Confusion",   icon: "\u2753", tagClass: "mlcx-tag--confusion" },
    anxiety:     { key: "anxiety",     label: "Anxiety",     icon: "\u26a0", tagClass: "mlcx-tag--anxiety" },
    urgency:     { key: "urgency",     label: "Urgency",     icon: "\u23f1", tagClass: "mlcx-tag--urgency" },
    cost:        { key: "cost",        label: "Cost stress", icon: "\ud83d\udcb0", tagClass: "mlcx-tag--cost" },
    routing:     { key: "routing",     label: "Routing / keywords", icon: "\ud83e\udde9", tagClass: "mlcx-tag--routing" }
  };
  
  // Expose globally for snippet chip rendering
  window.mlcxCategoryMeta = mlcxCategoryMeta;

  const civcCategoryMeta = {
    financial:    { key: "financial",    label: "Financial difficulty",          icon: "\ud83d\udcb8", tagClass: "civc-tag--financial",  supportFlag: "D - Financial Difficulty" },
    mentalHealth: { key: "mentalHealth", label: "Mental health / emotional",     icon: "\ud83d\udc97", tagClass: "civc-tag--mental",     supportFlag: "B - Mental / Emotional" },
    safeguarding: { key: "safeguarding", label: "Safeguarding",                  icon: "\ud83d\udea8", tagClass: "civc-tag--safeguarding",supportFlag: "A - Safeguarding / Risk of harm" },
    disability:   { key: "disability",   label: "Disability / health",           icon: "\u267f",        tagClass: "civc-tag--disability", supportFlag: "C - Disability / Health" },
    bereavement:  { key: "bereavement",  label: "Bereavement",                   icon: "\ud83d\udd6f", tagClass: "civc-tag--bereavement",supportFlag: "E - Bereavement" },
    language:     { key: "language",     label: "Language barrier",              icon: "\ud83c\udf0d", tagClass: "civc-tag--language",   supportFlag: "F - Language / Communication" },
    digital:      { key: "digital",      label: "Digital exclusion",             icon: "\ud83d\udcbb", tagClass: "civc-tag--digital",    supportFlag: "G - Digital exclusion" }
  };

  // High-level emotional / CX triggers (MLCX)
  const mlcxLibrary = {
    frustration: {
      meta: mlcxCategoryMeta.frustration,
      triggers: [
        "fed up", "this is ridiculous", "not happy", "sick of this",
        "keeps happening", "frustrating", "angry", "upset"
      ],
      why: "Signals irritation or anger with the process or outcome.",
      guidance: "Acknowledge the frustration clearly, slow your pace, and explain what you'll do next."
    },
    confusion: {
      meta: mlcxCategoryMeta.confusion,
      triggers: [
        "not sure what happens next", "don\'t understand", "confused",
        "which one is correct", "this makes no sense", "no one explained",
        "i\'m lost", "what does that mean"
      ],
      why: "Customer is unsure about steps, decisions or jargon.",
      guidance: "Check understanding in plain language, recap key steps, and avoid new jargon."
    },
    anxiety: {
      meta: mlcxCategoryMeta.anxiety,
      triggers: [
        "this is giving me anxiety", "panic attacks", "really worried",
        "keeping me up at night", "stressed out", "can\'t cope"
      ],
      why: "Signals emotional strain or possible mental health pressure.",
      guidance: "Soft tone, shorter sentences, clear reassurance about what you can control today."
    },
    urgency: {
      meta: mlcxCategoryMeta.urgency,
      triggers: [
        "asap", "as soon as possible", "urgent", "right now",
        "today", "immediately", "straight away", "by tomorrow"
      ],
      why: "Customer is under time pressure or perceives delay risk.",
      guidance: "Set realistic timeframes, avoid over-promising, and state when you'll update them."
    },
    cost: {
      meta: mlcxCategoryMeta.cost,
      triggers: [
        "can\'t afford", "no money", "lost my job", "charges", "fees",
        "excess", "write off", "written off", "pay for this myself",
        "unfair", "too expensive"
      ],
      why: "Cost / fairness concerns, potential financial difficulty.",
      guidance: "Explain costs slowly, link to policy wording, and signpost support where available."
    },
    routing: {
      meta: mlcxCategoryMeta.routing,
      triggers: [
        "ombudsman", "complaint", "cancel my policy", "speak to a manager",
        "legal advice", "go to the fca", "take this further"
      ],
      why: "Signals escalation, complaints, or routing to specialist teams.",
      guidance: "Capture key phrases accurately, follow escalation pathways and log concerns clearly."
    }
  };

  // CiVC-style vulnerability indicators
  const civcLibrary = {
    financial: {
      meta: civcCategoryMeta.financial,
      triggers: ["can\'t afford", "no money", "lost my job", "benefits", "in debt", "bailiffs"],
      why: "Money stress or difficulty meeting regular costs.",
      guidance: "Avoid pressure, outline options calmly, and consider setting expectations over more than one call."
    },
    mentalHealth: {
      meta: civcCategoryMeta.mentalHealth,
      triggers: ["anxiety", "panic attacks", "depression", "overwhelmed", "can\'t cope", "struggling mentally"],
      why: "Possible mental health or emotional wellbeing issues.",
      guidance: "Keep tone calm, avoid rushing, signpost to internal mental health / wellbeing guidance where appropriate."
    },
    safeguarding: {
      meta: civcCategoryMeta.safeguarding,
      triggers: ["not safe", "abuse", "domestic violence", "threatening me", "police involved", "children at risk"],
      why: "Potential risk of harm to the customer or others.",
      guidance: "Follow safeguarding playbook immediately and alert the appropriate internal team."
    },
    disability: {
      meta: civcCategoryMeta.disability,
      triggers: ["disability", "disabled", "chronic illness", "long-term condition", "hospital", "wheelchair"],
      why: "Health or disability factors that may affect communication or decision-making.",
      guidance: "Check preferred communication style and pace; adapt explanations and reasonable adjustments."
    },
    bereavement: {
      meta: civcCategoryMeta.bereavement,
      triggers: ["my partner passed away", "my husband died", "my wife died", "lost my mum", "lost my dad", "funeral"],
      why: "Recent loss or bereavement.",
      guidance: "Use soft empathy, slow down, and reference bereavement-specific guidance or teams if available."
    },
    language: {
      meta: civcCategoryMeta.language,
      triggers: ["english is not my first language", "not good with english", "struggling to understand you", "can someone translate"],
      why: "Language or communication barriers.",
      guidance: "Speak more slowly, avoid jargon, confirm understanding, and consider translation or written follow-up."
    },
    digital: {
      meta: civcCategoryMeta.digital,
      triggers: ["don\'t have email", "no internet", "can\'t use the app", "not good with computers", "no smartphone"],
      why: "Customer may be excluded from digital-only processes.",
      guidance: "Offer non-digital routes where possible and avoid assuming access to apps or email."
    }
  };

  // Phase 19.13B: Shared coaching cards configuration (used by both MLCX Notepad + CX drawer)
  const mlcxCoachCards = {
    emotion: {
      title: "Emotion detection",
      pillar: "TONE",
      body: "Use this card to track frustration, anxiety, anger or relief in the customer's story.",
      bullets: [
        "Note any phrases that sound upset, worried or exhausted.",
        "Think what reassurance would actually help here."
      ],
      suggestedWording: "I can see why that's frustrating. Let me help you get this sorted."
    },
    clarity: {
      title: "Confusion flags",
      pillar: "CLARITY",
      body: "Capture parts of the claim where the customer is unsure what will happen next.",
      bullets: [
        "Write down any questions they ask more than once.",
        "Note steps that feel complex or easy to mis-hear."
      ],
      suggestedWording: "Let me break that down step by step. Does that make sense so far?"
    },
    cxRisk: {
      title: "Jargon & Cost",
      pillar: "CX RISK",
      body: "Keep track of any technical terms, fees or excesses you mention.",
      bullets: [
        "Highlight words the customer reacted to.",
        "Think about how you'd explain each one in plain language."
      ],
      suggestedWording: "The excess is the amount you pay first before we cover the rest. In your case, that's £X."
    },
    safety: {
      title: "CiVC & Support",
      pillar: "SAFETY",
      body: "Use this space to note anything that might point to vulnerability or extra support needs.",
      bullets: [
        "Health, bereavement, money worries, domestic issues or anything heavy.",
        "Link what you hear to the right Support Flag and next step."
      ],
      suggestedWording: "I want to make sure you have the support you need. Would it help if I arranged a callback or put you in touch with our specialist team?"
    }
  };

  function analyseHybridText(rawText) {
    const text = (rawText || "").toLowerCase();
    const mlcxHits = new Set();
    const civcHits = new Set();
    const supportFlags = new Set();
    const hitPhrases = [];

    if (!text) {
      return { mlcxHits: [], civcHits: [], supportFlags: [], hitPhrases: [] };
    }

    function scanLibrary(lib, hitSet, collectFlags) {
      Object.keys(lib).forEach((key) => {
        const entry = lib[key];
        if (!entry || !Array.isArray(entry.triggers)) return;
        entry.triggers.forEach((phrase) => {
          const needle = phrase.toLowerCase();
          if (needle && text.includes(needle)) {
            hitSet.add(key);
            hitPhrases.push({ category: key, phrase });
            if (collectFlags && entry.meta && entry.meta.supportFlag) {
              supportFlags.add(entry.meta.supportFlag);
            }
          }
        });
      });
    }

    scanLibrary(mlcxLibrary, mlcxHits, false);
    scanLibrary(civcLibrary, civcHits, true);

    // MLCX Alpha – vulnerability summary wiring (non-destructive patch)
    // Build vulnerability summary from CiVC hits
    const hasVulnerability = civcHits.size > 0;
    const categories = [];
    const phrases = [];
    let severity = 'none';
    let notes = '';

    if (hasVulnerability) {
      // Extract category labels
      civcHits.forEach(key => {
        const entry = civcLibrary[key];
        if (entry && entry.meta) {
          categories.push(entry.meta.label);
        }
      });

      // Extract sample phrases (first 5)
      phrases.push(...hitPhrases.slice(0, 5).map(h => h.phrase));

      // Compute severity heuristic
      const totalFlags = civcHits.size;
      const hasSafeguarding = civcHits.has('safeguarding');
      const hasMentalHealth = civcHits.has('mentalHealth');
      const hasFinancial = civcHits.has('financial');

      if (hasSafeguarding || totalFlags >= 3) {
        severity = 'high';
      } else if (hasMentalHealth || hasFinancial || totalFlags >= 2) {
        severity = 'medium';
      } else if (totalFlags >= 1) {
        severity = 'low';
      }

      // Generate summary note
      if (severity === 'high') {
        notes = 'High vulnerability concern detected – consider slowing down, offering extra support, and following safeguarding steps where appropriate.';
      } else if (severity === 'medium') {
        notes = 'Possible vulnerability indicators – consider offering extra time, checking understanding, and signposting to support if needed.';
      } else {
        notes = 'Low-level vulnerability signal detected – stay alert and adapt your approach as the conversation develops.';
      }
    }

    // Update mlcxState.vulnerability
    if (window.mlcxState) {
      mlcxState.vulnerability = {
        hasFlag: hasVulnerability,
        categories: categories,
        severity: severity,
        phrases: phrases,
        notes: notes
      };
    }

    return {
      mlcxHits: Array.from(mlcxHits),
      civcHits: Array.from(civcHits),
      supportFlags: Array.from(supportFlags),
      hitPhrases
    };
  }

  // Phase 20: Global CX Sync function - combines all text sources and refreshes all surfaces
  function runGlobalCxSync() {
    try {
      // Helper to strip HTML (fallback if htmlToPlain not yet available)
      const stripHtml = (html) => {
        const temp = document.createElement("div");
        temp.innerHTML = html;
        return temp.textContent || temp.innerText || "";
      };
      
      // Gather all text sources
      const customerText = (document.getElementById("customerInput")?.value || "").trim();
      const agentHtml = document.getElementById("agentInput")?.innerHTML || "";
      const agentText = (typeof htmlToPlain === "function" ? htmlToPlain(agentHtml) : stripHtml(agentHtml)).trim();
      const notesText = (document.querySelector(".mlcx-notes-input")?.value || "").trim();
      
      // Combine all sources
      const combined = [customerText, agentText, notesText].filter(Boolean).join("\n\n");
      
      // Run MLCX/CiVC analysis
      const analysis = analyseHybridText(combined);
      window.mlcxHybridAnalysis = analysis;
      console.log("[Global CX Sync]", analysis);
      
      // Update all MLCX surfaces
      buildCvContent(analysis);
      renderVulnerabilitySummary();
      renderVulnerabilityDebug();
      
      // Refresh Call Notes counters
      updateCallNotesIssueCounters(notesText);
      
      // Refresh Messenger UK/Jargon highlights and counters
      const agentInput = document.getElementById("agentInput");
      if (agentInput && typeof applyHighlighting === "function") {
        applyHighlighting();
      }
      if (typeof updateIssueCounters === "function") {
        updateIssueCounters();
      }
      
      console.log("[CX Sync] Complete - all surfaces refreshed");
    } catch (err) {
      console.warn("[CX Sync] Error during sync:", err);
    }
  }

  // [MF:PHASE-F][OWNER:INPUT_NOTES] PRIMARY WIRING LOCATION
  // Notes input: LIGHT updates + 160ms trailing heavy recompute
  if (mlcxNotesInput) {
    mlcxNotesInput.addEventListener("input", () => {
      // Guard: skip heavy scheduling during IME composition
      if (window.__mf_isComposing === true) return;
      // [MF:PHASE-F][OWNER:INPUT_NOTES] Schedule heavy recompute (160ms trailing debounce)
      // This reason triggers full recompute including CV drawer via mainHeavyRecomputePipeline
      if (typeof scheduleRecompute === "function") scheduleRecompute("notes:input");
    });
    // [MF:PHASE-F][OWNER:INPUT_NOTES] Composition guards
    mlcxNotesInput.addEventListener("compositionstart", () => { window.__mf_isComposing = true; });
    mlcxNotesInput.addEventListener("compositionend", () => {
      window.__mf_isComposing = false;
      if (typeof scheduleRecompute === "function") scheduleRecompute("notes:compositionend");
    });

    // Pull UK/US rules from the live engine-backed UKUS_RULES object
    function getUkusRuleList() {
      const rules = [];
      const source = (typeof globalThis !== 'undefined' && 'UKUS_RULES' in globalThis) ? globalThis.UKUS_RULES : undefined;
      try {
        if (source && Array.isArray(source.autoReplace)) rules.push(...source.autoReplace);
        if (source && Array.isArray(source.manualCheck)) rules.push(...source.manualCheck);
      } catch (_) {}
      return rules;
    }

    function summarizeUkusMatches(text, sampleLimit = 5) {
      const target = text || '';
      const rules = getUkusRuleList();
      let count = 0;
      const examples = [];
      rules.forEach(rule => {
        if (!rule || !(rule.pattern instanceof RegExp)) return;
        const pat = new RegExp(rule.pattern.source, 'gi');
        if (pat.test(target)) {
          count++;
          if (examples.length < sampleLimit) {
            examples.push(rule.us || rule.id || rule.pattern.source);
          }
        }
      });
      return { count, examples };
    }

    // Task 1: Update Call Notes issue counters (UK/Jargon/Flags)
    function updateCallNotesIssueCounters(text) {
      const mlcxCharCount = document.getElementById('mlcxCharCount');
      const mlcxUkCounter = document.getElementById('mlcxUkIssueCounter');
      const mlcxFlagsCounter = document.getElementById('mlcxFlagsCounter');
      
      if (!text) text = '';
      
      // Character count
      if (mlcxCharCount) {
        mlcxCharCount.textContent = String(text.length);
      }
      
      // UK vs US spelling issues (engine-sourced)
      const { count: ukCount } = summarizeUkusMatches(text, 0);
      if (mlcxUkCounter) {
        mlcxUkCounter.textContent = `UK checks: ${ukCount}`;
      }
      
      // Jargon/flags count (reuse existing jargon list)
      const jargonWords = ['excess', 'deductible', 'liability', 'surcharge', 'compliance', 'premium', 'settlement', 'valuation', 'escalate', 'escalation'];
      let flagsCount = 0;
      const lower = text.toLowerCase();
      jargonWords.forEach(word => {
        if (lower.includes(word)) flagsCount++;
      });
      if (mlcxFlagsCounter) {
        mlcxFlagsCounter.textContent = `Flags: ${flagsCount}`;
      }
    }
    
    // Initial update
    updateCallNotesIssueCounters(mlcxNotesInput.value);

    // Optional: simple Hints toggle for Call Notes strip
    const callnotesHintsToggleBtn = document.getElementById("callnotesHintsToggleBtn");
    if (callnotesHintsToggleBtn) {
      callnotesHintsToggleBtn.addEventListener("click", () => {
        const pressed = callnotesHintsToggleBtn.getAttribute("aria-pressed") === "true";
        const nextPressed = !pressed;
        callnotesHintsToggleBtn.setAttribute("aria-pressed", String(nextPressed));
        callnotesHintsToggleBtn.textContent = nextPressed ? "Hints on" : "Hints off";
      });
    }

    // Phase 20: Wire Call Notes Sync CX button
    const mlcxNotesSyncBtn = document.getElementById("mlcxNotesSyncBtn");
    if (mlcxNotesSyncBtn) {
      mlcxNotesSyncBtn.addEventListener("click", runGlobalCxSync);
    }

    // Notes toolbar actions: Paste / Copy / Clear
    const notesActionButtons = document.querySelectorAll("[data-notes-action]");
    notesActionButtons.forEach((btn) => {
      const action = btn.getAttribute("data-notes-action");
      btn.addEventListener("click", () => {
        if (!mlcxNotesInput) return;

        if (action === "clear") {
          // Clear the notes and reset all MLCX dashboards to a clean slate
          mlcxNotesInput.value = "";
          const emptyAnalysis = { mlcxHits: [], civcHits: [], supportFlags: [], hitPhrases: [] };
          window.mlcxHybridAnalysis = emptyAnalysis;
          try {
            buildCvContent(emptyAnalysis);
          } catch (err) {
            console.warn("MLCX clear: buildCvContent failed", err);
          }
          mlcxNotesInput.focus();
          return;
        }

        if (action === "copy") {
          const value = mlcxNotesInput.value || "";
          try {
            if (navigator.clipboard && navigator.clipboard.writeText) {
              navigator.clipboard.writeText(value);
              showToast("Call Notes copied!", "success");
            } else {
              const temp = document.createElement("textarea");
              temp.value = value;
              document.body.appendChild(temp);
              temp.select();
              document.execCommand("copy");
              document.body.removeChild(temp);
              showToast("Call Notes copied!", "success");
            }
          } catch (err) {
            console.warn("MLCX copy failed:", err);
          }
          mlcxNotesInput.focus();
          return;
        }

        if (action === "paste") {
          if (navigator.clipboard && navigator.clipboard.readText) {
            navigator.clipboard.readText().then((clip) => {
              if (!clip) {
                mlcxNotesInput.focus();
                return;
              }
              const start = typeof mlcxNotesInput.selectionStart === "number"
                ? mlcxNotesInput.selectionStart
                : mlcxNotesInput.value.length;
              const end = typeof mlcxNotesInput.selectionEnd === "number"
                ? mlcxNotesInput.selectionEnd
                : mlcxNotesInput.value.length;
              const current = mlcxNotesInput.value || "";
              mlcxNotesInput.value =
                current.slice(0, start) + clip + current.slice(end);

              const caret = start + clip.length;
              mlcxNotesInput.selectionStart = caret;
              mlcxNotesInput.selectionEnd = caret;

              const analysis = analyseHybridText(mlcxNotesInput.value);
              window.mlcxHybridAnalysis = analysis;
              try {
                buildCvContent(analysis);
                if (typeof updateCallNotesCxDrawer === "function") {
                  updateCallNotesCxDrawer(analysis);
                }
              } catch (err) {
                console.warn("MLCX paste: buildCvContent failed", err);
              }
            }).catch((err) => {
              console.warn("MLCX paste failed:", err);
              mlcxNotesInput.focus();
            });
          } else {
            // Fallback: no programmatic paste support, just focus for Ctrl+V
            mlcxNotesInput.focus();
          }
        }
      });
    });

    // Phase 19.13A: Helper for visual feedback on sync buttons
    function flashSyncButton(btn) {
      if (!btn) return;
      const originalText = btn.textContent;
      const originalBg = btn.style.background;
      const originalColor = btn.style.color;
      
      btn.textContent = "✓ Copied";
      btn.style.background = "radial-gradient(circle at top, #10b981, #059669)";
      btn.style.color = "#fff";
      
      setTimeout(() => {
        btn.textContent = originalText;
        btn.style.background = originalBg;
        btn.style.color = originalColor;
      }, 1200);
    }

    // Phase 19.13A: Wire sync customer → notepad button (unified overwrite behavior)
    const mlcxSyncCustomerBtn = document.getElementById("mlcxSyncCustomerBtn");
    if (mlcxSyncCustomerBtn) {
      mlcxSyncCustomerBtn.addEventListener("click", () => {
        const customerText = (typeof getCustomerTextForMlcx === "function")
          ? (getCustomerTextForMlcx() || "")
          : (typeof getCustomerText === "function" ? (getCustomerText() || "") : "");
        overwriteNotes(customerText);
        flashSyncButton(mlcxSyncCustomerBtn);
      });
    }

    // Phase 19.13A: Wire sync agent → notepad button (unified overwrite behavior)
    const mlcxSyncAgentBtn = document.getElementById("mlcxSyncAgentBtn");
    if (mlcxSyncAgentBtn) {
      mlcxSyncAgentBtn.addEventListener("click", () => {
        const agentInput = document.getElementById("agentInput");
        let agentHtml = (typeof getAgentTextForMlcx === "function")
          ? (getAgentTextForMlcx() || "")
          : (agentInput ? (agentInput.innerHTML || "") : "");
        const agentText = (typeof getPlainTextFromHtml === "function")
          ? getPlainTextFromHtml(agentHtml)
          : agentHtml;
        overwriteNotes(agentText);
        flashSyncButton(mlcxSyncAgentBtn);
      });
    }

    // Wire Call Notes toolbar buttons to pull from Messenger and refresh
    function overwriteNotesFromHtmlElement(el) {
      if (!el || !mlcxNotesInput) return;
      const html = el.innerHTML || "";
      const plain = (typeof getPlainTextFromHtml === "function")
        ? getPlainTextFromHtml(html)
        : html;
      mlcxNotesInput.value = plain.trim();
      mlcxNotesInput.focus();

      const analysis = analyseHybridText(mlcxNotesInput.value);
      window.mlcxHybridAnalysis = analysis;
      updateCallNotesIssueCounters(mlcxNotesInput.value);
      if (typeof updateCallNotesCxDrawer === "function") {
        updateCallNotesCxDrawer(analysis);
      }
    }

    const callnotesFromCustomerBtn = document.getElementById("callnotesFromCustomerBtn");
    if (callnotesFromCustomerBtn) {
      callnotesFromCustomerBtn.addEventListener("click", () => {
        const customerInput = document.getElementById("customerInput");
        overwriteNotesFromHtmlElement(customerInput);
      });
    }

    const callnotesFromAgentBtn = document.getElementById("callnotesFromAgentBtn");
    if (callnotesFromAgentBtn) {
      callnotesFromAgentBtn.addEventListener("click", () => {
        const agentInput = document.getElementById("agentInput");
        overwriteNotesFromHtmlElement(agentInput);
      });
    }
  }

  // Phase 19.13A: Overwrite notes helper (true "sync" behavior - replaces content)
  function overwriteNotes(text) {
    const notesEl = document.getElementById("mlcxNotesInput");
    if (!notesEl) return;

    notesEl.value = text || "";
    // Ensure caret at end and scroll to bottom
    notesEl.selectionStart = notesEl.selectionEnd = notesEl.value.length;
    notesEl.scrollTop = notesEl.scrollHeight;

    // Trigger the live pipeline so mlcxState updates
    notesEl.dispatchEvent(new Event("input", { bubbles: true }));
  }

  function buildCvContent(analysis) {
    if (!cvContent) return;
    const baseText = (mlcxState && mlcxState.rawText) || "";
    const data = analysis || window.mlcxHybridAnalysis || analyseHybridText(baseText);
    const mlcxHits = data.mlcxHits || [];
    const civcHits = data.civcHits || [];
    const supportFlags = data.supportFlags || [];
    const hitPhrases = data.hitPhrases || [];

    let html = "";

    const totalHits = mlcxHits.length + civcHits.length;
    let band = "low";
    let bandLabel = "Low activity";

    if (totalHits >= 4) {
      band = "high";
      bandLabel = "High concern";
    } else if (totalHits >= 2) {
      band = "medium";
      bandLabel = "Medium attention";
    }

    html += '<div class="cv-summary-head">';
    html += '<div class="cv-summary-title">Live snapshot</div>';
    html += '<div class="cv-summary-band cv-band-' + band + '">';
    html += '<span class="cv-summary-band-label">' + bandLabel + '</span>';
    html += '<span class="cv-summary-band-count">' + totalHits + ' cue' + (totalHits === 1 ? '' : 's') + '</span>';
    html += '</div></div>';

    // Tone summary
    html += '<section class="cv-block">';
    html += '<div class="cv-block-title">Emotion & tone</div>';
    if (mlcxHits.length) {
      html += '<div class="cv-chips-row">';
      mlcxHits.forEach((key) => {
        const meta = mlcxCategoryMeta[key];
        if (!meta) return;
        const cls = meta.tagClass ? meta.tagClass : "";
        const icon = meta.icon || "";
        const label = meta.label || key;
        html += '<span class="cv-chip ' + cls + '">';
        if (icon) {
          html += '<span class="cv-chip-icon">' + icon + '</span>';
        }
        html += '<span>' + label + '</span></span>';
      });
      html += "</div>";
    } else {
      html += '<p class="cv-ghost">No strong emotion cues flagged yet. Keep listening for frustration, anxiety or relief.</p>';
    }
    html += "</section>";

    // Vulnerability / CiVC summary
    html += '<section class="cv-block">';
    html += '<div class="cv-block-title">Vulnerability indicators (CiVC)</div>';
    if (civcHits.length) {
      html += '<div class="cv-chips-row">';
      civcHits.forEach((key) => {
        const entry = civcLibrary[key];
        const meta = entry && entry.meta ? entry.meta : civcCategoryMeta[key];
        if (!meta) return;
        const cls = meta.tagClass ? meta.tagClass : "";
        const icon = meta.icon || "";
        const label = meta.label || key;
        html += '<span class="cv-chip ' + cls + '">';
        if (icon) {
          html += '<span class="cv-chip-icon">' + icon + '</span>';
        }
        html += '<span>' + label + '</span></span>';
      });
      html += "</div>";

      if (supportFlags.length) {
        html += '<ul class="cv-list">';
        supportFlags.forEach((flag) => {
          html += '<li>Suggested support flag: <strong>' + flag + '</strong></li>';
        });
        html += "</ul>";
      }
    } else {
      html += '<p class="cv-ghost">No clear CiVC indicators detected yet. Stay alert for money worries, health, safety or language barriers.</p>';
    }
    html += "</section>";

    // Key phrases
    html += '<section class="cv-block">';
    html += '<div class="cv-block-title">Key phrases to pay attention to</div>';
    if (hitPhrases.length) {
      html += '<div class="cv-chips-row">';
      hitPhrases.slice(0, 12).forEach((item) => {
        const meta = mlcxCategoryMeta[item.category] || (civcLibrary[item.category] && civcLibrary[item.category].meta) || null;
        const cls = meta && meta.tagClass ? meta.tagClass : "";
        const icon = meta && meta.icon ? meta.icon : "";
        html += '<span class="cv-chip ' + cls + '">';
        if (icon) {
          html += '<span class="cv-chip-icon">' + icon + '</span>';
        }
        html += '<span>“' + item.phrase + '”</span></span>';
      });
      html += "</div>";
    } else {
      html += '<p class="cv-ghost">No specific trigger phrases have been matched yet.</p>';
    }
    html += "</section>";

    // Next step checklist
    html += '<section class="cv-block">';
    html += '<div class="cv-block-title">What to focus on next</div>';
    html += '<ul class="cv-list">';
    html += '<li>Slow the pace whenever emotion or confusion is high.</li>';
    html += '<li>Explain any costs, excesses or decisions in plain language.</li>';
    html += '<li>Check understanding before moving on to the next step.</li>';
    html += '<li>If CiVC is flagged, think about support flags and referral routes.</li>';
    html += "</ul>";
    html += "</section>";

    if (cvContent) cvContent.innerHTML = html;
  }

  // MLCX Alpha – vulnerability copy polish + severity badge (Prime build)
  function renderVulnerabilitySummary() {
    const el = document.querySelector('.mlcx-vulnerability-summary');
    if (!el) return;

    const v = mlcxState.vulnerability || {};
    if (!v.hasFlag) {
      el.innerHTML = '<p class="cx-drawer-section-empty">No clear vulnerability indicators detected yet. Use this space if you notice anything that might make the call harder for the customer.</p>';
      return;
    }

    // Build severity badge
    const level = v.severity || 'none';
    const levelLabelMap = {
      none: 'None',
      low: 'Low',
      medium: 'Medium',
      high: 'High'
    };
    const pillClass = `mlcx-vuln-pill mlcx-vuln-pill--${level}`;
    const levelHtml = `
      <span class="${pillClass}">
        ${levelLabelMap[level] || 'Unknown'}
      </span>
    `;

    // Build readable summary with plain-language labels
    const htmlParts = [];
    htmlParts.push(`
      <div class="mlcx-vuln-line">
        <strong>Vulnerability level:</strong> ${levelHtml}
      </div>
    `);

    const cats = (v.categories || []).join(', ');
    if (cats) {
      htmlParts.push(`
        <div class="mlcx-vuln-line">
          <strong>Areas:</strong> ${cats}
        </div>
      `);
    }

    if (v.notes) {
      htmlParts.push(`
        <div class="mlcx-vuln-line" style="margin-bottom:8px;font-size:0.75rem;line-height:1.5;color:rgba(191,219,254,0.92);">
          <strong>Summary:</strong> ${v.notes}
        </div>
      `);
    }

    const phrases = (v.phrases || []).slice(0, 3);
    if (phrases.length > 0) {
      htmlParts.push(`
        <div class="mlcx-vuln-line" style="font-size:0.72rem;color:rgba(148,163,184,0.94);">
          <strong>Noticed phrases:</strong> ${phrases.join(' • ')}
        </div>
      `);
    }

    el.innerHTML = htmlParts.join('');
  }

  // MLCX Alpha – vulnerability summary wiring (non-destructive patch)
  function renderVulnerabilityDebug() {
    const el = document.querySelector('.mlcx-vulnerability-debug');
    if (!el) return;
    el.textContent = JSON.stringify(mlcxState.vulnerability || {}, null, 2);
  }

  function openCvOverlay() {
    if (!cvOverlay || !cvModeBtn) return;
    buildCvContent(window.mlcxHybridAnalysis);
    renderVulnerabilitySummary(); // MLCX Alpha patch
    renderVulnerabilityDebug(); // MLCX Alpha patch
    cvOverlay.classList.add("is-visible");
    cvOverlay.setAttribute("aria-hidden", "false");
    cvModeBtn.setAttribute("aria-expanded", "true");
  }

  function closeCvOverlay() {
    if (!cvOverlay || !cvModeBtn) return;
    cvOverlay.classList.remove("is-visible");
    cvOverlay.setAttribute("aria-hidden", "true");
    cvModeBtn.setAttribute("aria-expanded", "false");
  }

  function syncCvButtonVisibility() {
    if (!cvModeBtn) return;
    const isMlcx = (document.body.dataset.layout === "mlcx");
    cvModeBtn.style.display = isMlcx ? "inline-flex" : "none";
    if (!isMlcx) {
      closeCvOverlay();
    }
  }

  if (cvModeBtn) {
    cvModeBtn.addEventListener("click", () => {
      if (cvOverlay && cvOverlay.classList.contains("is-visible")) {
        closeCvOverlay();
      } else {
        openCvOverlay();
      }
    });
  }

  if (cvOverlayClose) {
    cvOverlayClose.addEventListener("click", closeCvOverlay);
  }

  if (cvOverlay) {
    cvOverlay.addEventListener("click", (evt) => {
      if (evt.target === cvOverlay) {
        closeCvOverlay();
      }
    });
  }

  document.addEventListener("keydown", (evt) => {
    if (evt.key === "Escape") {
      closeCvOverlay();
    }
  });

function getCustomerText() {
    if (!customerInput) return DEFAULT_CUSTOMER_TEXT;
    const raw = (customerInput.value || "").trim();
    return raw || DEFAULT_CUSTOMER_TEXT;
  }

  
  function refreshMLCXState() {
    const mode = document.body.dataset.layout || "split";

    let raw = "";
    if (mode === "mlcx" && mlcxNotesInput) {
      // In MLCX layout, drive state from call notes
      raw = (mlcxNotesInput.value || "").trim();
      mlcxState.source = "notes";
    } else if (customerInput) {
      // In split / notepad layouts, drive from customer message
      raw = (customerInput.value || "").trim();
      mlcxState.source = "customer";
    }

    mlcxState.rawText = raw;
    mlcxState.totalChars = raw.length;

    const sentences = splitIntoSentences(raw);
    mlcxState.sentences = sentences.map((text, index) => ({
      id: "s" + index,
      text,
      length: text.length
    }));


  (function setupDevShortcutToggle(){
    const toggleLayout = (target) => {
      if (!target) return;
      if (document.body.dataset.layout === target) return;
      document.body.dataset.layout = target;
      document.dispatchEvent(new CustomEvent("layoutchange", { detail: { mode: target } }));
    };

    const toggleDevMode = () => {
      const current = document.body.dataset.layout || "split";
      const next = current === "dev" ? "split" : "dev";
      toggleLayout(next);
      if (typeof showToast === "function") {
        showToast(next === "dev" ? "Dev Lab enabled" : "Returned to Messenger", "info");
      }
    };

    document.addEventListener("keydown", (evt) => {
      const key = evt.key?.toLowerCase();
      const isShortcut = (evt.ctrlKey || evt.metaKey) && evt.shiftKey && (key === "d" || key === "m");
      if (!isShortcut) return;
      if (evt.__devHandled) return;
      evt.__devHandled = true;
      evt.preventDefault();
      evt.stopPropagation();
      toggleDevMode();
    });
  })();
    // Existing rails (used by the snapshot / drawer)
    renderMLCXRails();

    // New: keep the MLCX Notepad pills in sync
    renderMLCXPillsFromState();
    
    // Phase 20.B: Also refresh all MLCX surfaces including Call Notes CX drawer
    if (typeof refreshAllMlcxSurfaces === "function") {
      refreshAllMlcxSurfaces();
    }
  }
  function renderMLCXRails() {
    if (!mlcxRails || !mlcxRailLeft || !mlcxRailRight) return;

    const sentences = (mlcxState && Array.isArray(mlcxState.sentences))
      ? mlcxState.sentences
      : [];

    mlcxRailLeft.innerHTML = "";
    mlcxRailRight.innerHTML = "";

    if (!mlcxCoaching || !sentences.length) {
      mlcxRails.classList.add("mlcx-hidden");
      return;
    }
    mlcxRails.classList.remove("mlcx-hidden");

    const midpoint = Math.ceil(sentences.length / 2);
    const left = sentences.slice(0, midpoint);
    const right = sentences.slice(midpoint);

    function makePill(item) {
      const pill = document.createElement("div");
      const coachingOn = (typeof mlcxCoaching === "boolean") ? mlcxCoaching : true;
      const isQuestion = coachingOn && /\?/u.test(item.text || "");
      pill.className = "mlcx-sentence" + (isQuestion ? " mlcx-sentence-question" : "");
      pill.textContent = item.text;

      let baseTitle = item.text;
      let coachMsg = "";
      if (isQuestion) {
        coachMsg = "This sentence contains a direct question – make sure you answer it clearly in your reply.";
        baseTitle += "  (" + coachMsg + ")";
      }
      pill.title = baseTitle;
      if (coachMsg) {
        pill.dataset.coachMessage = coachMsg;
      }
      return pill;
    }

    left.forEach((item) => {
      mlcxRailLeft.appendChild(makePill(item));
    });

    right.forEach((item) => {
      mlcxRailRight.appendChild(makePill(item));
    });
  }


  

  function resetMLCXState() {
    if (!window.mlcxState) return;
    mlcxState.rawText = "";
    mlcxState.totalChars = 0;
    mlcxState.sentences = [];
    mlcxState.source = "customer";
    // MLCX Alpha – vulnerability summary wiring (non-destructive patch)
    mlcxState.vulnerability = {
      hasFlag: false,
      categories: [],
      severity: 'none',
      phrases: [],
      notes: ''
    };
    renderMLCXRails();
    if (typeof renderMLCXPillsFromState === "function") {
      renderMLCXPillsFromState();
    }
    if (typeof renderVulnerabilitySummary === "function") {
      renderVulnerabilitySummary();
    }
  }

function syncBubbleAddButtonColours() {
    if (!addCustomerBubbleBtn || !addAgentBubbleBtn) return;
    const customerDot = addCustomerBubbleBtn.querySelector(".bubble-add-dot");
    const agentDot = addAgentBubbleBtn.querySelector(".bubble-add-dot");
    const customerPreview = document.querySelector(".chat-bubble.customer");
    const agentPreview = document.querySelector(".chat-bubble.agent");

    function applyColour(dot, source) {
      if (!dot || !source) return;
      const cs = getComputedStyle(source);
      const bg = cs.backgroundColor || cs.borderColor || "rgba(255,255,255,0.3)";
      dot.style.backgroundColor = bg;
    }

    applyColour(customerDot, customerPreview);
    applyColour(agentDot, agentPreview);
  }

  const chatBody = document.getElementById("chatBody");
  let themeMode = "lunar";
  const colourwayLabelEl = document.getElementById("colourwayLabel");
  const toolbarLeft = document.querySelector(".toolbar-left");
  const ukIssueCounter = document.getElementById("ukIssueCounter");
  const spellIssueCounter = document.getElementById("spellIssueCounter");
  const spellToggleBtn = document.getElementById("spellToggleBtn");
  let spellHintsMuted = false;
  window.spellHintsMuted = spellHintsMuted;

  const shuffleBtn = document.getElementById("shuffleBtn");
  const lowpolySvg = document.getElementById("lowpolyBg");
  const colourSelect = document.getElementById("colourSelect");
  const compactShuffleBtn = document.getElementById("compactShuffleBtn");
  const mlcxShuffleBtn = document.getElementById("mlcxShuffleBtn");
  const callnotesShuffleBtn = document.getElementById("callnotesShuffleBtn");

  // Session-scoped ignore cache for words the user has chosen to ignore
  // via the issue tooltip. Cleared when "Clear chat" is clicked.
  const ignoredWords = new Set();

  // Local safety allow‑list for words that our backend occasionally
  // mis-flags. These are never highlighted even if the server suggests them.
  let SAFE_WORDS = new Set([
    "today"
  ]);


  // Configurable spellcheck endpoint. When the page is opened via `file://`
  // it's convenient to target a local Flask server on 127.0.0.1:5000. When
  // served over HTTP the relative `/spellcheck` path is used so same-origin
  // fetches work as expected.
  const SPELLCHECK_URL = (window && window.location && window.location.protocol === "file:")
    ? "http://127.0.0.1:5000/spellcheck"
    : "/spellcheck";

  // Helpers to disable/enable any Clean action controls while pipeline runs
  function disableCleanControls() {
    try {
      const btns = Array.from(document.querySelectorAll('button[data-action="clean"]'));
      btns.forEach(b => {
        b.dataset._wasDisabled = b.disabled ? "1" : "0";
        b.disabled = true;
        b.setAttribute("aria-disabled", "true");
      });
    } catch (e) {}
  }

  function enableCleanControls() {
    try {
      const btns = Array.from(document.querySelectorAll('button[data-action="clean"]'));
      btns.forEach(b => {
        const was = b.dataset._wasDisabled === "1";
        b.disabled = was ? true : false;
        b.removeAttribute("aria-disabled");
        delete b.dataset._wasDisabled;
      });
    } catch (e) {}
  }

  // --- Responsive scaling so the full app fits without scrolling ---
  const appViewport = document.querySelector(".app-viewport");
  const appMain = document.querySelector(".app");
  const DESIGN_WIDTH = 1200;
  const DESIGN_HEIGHT = 800;

  function rescaleApp() {
    if (!appMain || !appViewport) return;

    // Reset any previous scaling so we can measure true size
    appMain.style.transform = "none";

    const rect = appMain.getBoundingClientRect();
    const vw = window.innerWidth;
    const vh = window.innerHeight;

    // Slightly relax the margins on smaller viewports so the card and phone
    // sit tighter to the edges without ever exceeding their true size.
    const BASE_MARGIN = 0.97; // slightly tighter margins so card hugs viewport more on smaller windows

    let scaleX = (vw * BASE_MARGIN) / rect.width;
    let scaleY = (vh * BASE_MARGIN) / rect.height;

    // If the viewport is shorter than our design height, allow a little extra
    // vertical scale so the phone and left panel feel "longer" and more connected.
    if (vh < DESIGN_HEIGHT) {
      const shortness = (DESIGN_HEIGHT - vh) / DESIGN_HEIGHT; // 0 -> ~0.5
      const relax = 1 + Math.min(0.16, shortness * 0.30);
      scaleY *= relax;
    }

    const scale = Math.min(scaleX, scaleY, 1); // never upscale above 1

    // Keep the whole app (left + phone) visible as a single unit
    appViewport.style.alignItems = "center";
    appMain.style.transformOrigin = "center center";
    appMain.style.transform = "scale(" + scale + ")";
  }


  window.addEventListener("resize", rescaleApp);
  window.addEventListener("load", rescaleApp);
let baseLowpolyMarkup = lowpolySvg ? lowpolySvg.innerHTML : "";

  // --- Simple custom undo/redo history for the agent box ---
  let agentHistory = [];
  let agentHistoryIndex = -1;
  let isRestoringHistory = false;

  function pushAgentHistory() {
    if (!agentInput || isRestoringHistory) return;
    const html = agentInput.innerHTML || "";
    if (agentHistoryIndex >= 0 && agentHistory[agentHistoryIndex] === html) return;
    if (agentHistoryIndex < agentHistory.length - 1) {
      agentHistory = agentHistory.slice(0, agentHistoryIndex + 1);
    }
    agentHistory.push(html);
    if (agentHistory.length > 100) {
      agentHistory.shift();
      agentHistoryIndex -= 1;
    }
    agentHistoryIndex = agentHistory.length - 1;
  }

  function restoreAgentHistory(index) {
    if (!agentInput) return;
    if (index < 0 || index >= agentHistory.length) return;
    isRestoringHistory = true;
    agentHistoryIndex = index;
    agentInput.innerHTML = agentHistory[agentHistoryIndex];
    isRestoringHistory = false;
    renderAgent();
  }

  function undoAgentHistory() {
    if (agentHistoryIndex > 0) {
      restoreAgentHistory(agentHistoryIndex - 1);
    }
  }

  function redoAgentHistory() {
    if (agentHistoryIndex < agentHistory.length - 1) {
      restoreAgentHistory(agentHistoryIndex + 1);
    }
  }

  // --- Helpers for sanitising and plain text length ---

  function getPlainTextFromHtml(html) {
    const temp = document.createElement("div");
    temp.innerHTML = html;

    let out = "";

    function walk(node) {
      if (node.nodeType === Node.TEXT_NODE) {
        out += node.nodeValue;
        return;
      }
      if (node.nodeType !== Node.ELEMENT_NODE) return;

      const tag = node.tagName;

      if (tag === "BR") {
        out += "\n";
        return;
      }

      if (tag === "LI") {
        out += "\u2022 ";
        node.childNodes.forEach(walk);
        out += "\n";
        return;
      }

      node.childNodes.forEach(walk);

      if (tag === "P" || tag === "DIV") {
        out += "\n\n";
      } else if (tag === "UL" || tag === "OL") {
        out += "\n";
      }
    }

    temp.childNodes.forEach(walk);

    return out
      .replace(/\r\n/g, "\n")
      .replace(/\n{3,}/g, "\n\n")
      .trim();
  }

  // Convert plain text → safe HTML, preserving line breaks exactly
  
  if (mlcxToggleBtn && mlcxRails) {
    // Unified Sync CX handler used by messenger + call notes
    function handleSyncCxClick(){
      // Run analysis immediately via unified pipeline
      if (typeof window.runMlcxAnalysis === 'function') {
        window.runMlcxAnalysis();
      } else if (typeof runRecomputeNow === 'function') {
        runRecomputeNow('sync-cx');
      }
      // Open drawer for immediate feedback
      const overlay = document.getElementById('cxDrawerOverlay');
      const notch = document.getElementById('cxNotchToggle');
      if (overlay && !overlay.classList.contains('is-open')){
        overlay.classList.add('is-open');
        overlay.setAttribute('aria-hidden','false');
        if (notch) notch.classList.add('is-hot');
      }
      console.log('[Sync CX] Recomputed and drawer refreshed');
    }
    window.handleSyncCxClick = handleSyncCxClick;
    mlcxToggleBtn.addEventListener('click', handleSyncCxClick);
    const notesSync = document.getElementById('mlcxNotesSyncBtn');
    if (notesSync){ notesSync.addEventListener('click', handleSyncCxClick); }
  }

function textToHtml(text) {
    if (!text) return "";
    // Escape HTML special chars
    let escaped = text
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;");

    // Normalise Windows newlines then convert all to <br>
    escaped = escaped.replace(/\r\n/g, "\n");
    return escaped.replace(/\n/g, "<br>");
  }

function cleanHtml(html) {
    const allowed = new Set(["B","STRONG","I","EM","U","BR","UL","OL","LI","P","SPAN","S","STRIKE","BLOCKQUOTE"]);
    const temp = document.createElement("div");
    temp.innerHTML = html;

    function cleanNode(node) {
      // Strip out any comments entirely
      if (node.nodeType === Node.COMMENT_NODE) {
        return document.createTextNode("");
      }

      if (node.nodeType === Node.TEXT_NODE) {
        // normalise non‑breaking spaces that often come from Word / web editors
        let text = node.textContent || "";
        text = text.replace(/\u00a0/g, " ");
        // collapse repeated inline whitespace (spaces/tabs) but keep single newlines
        text = text.replace(/[ \t\f\v]+/g, " ");
        // remove trailing spaces before newlines
        text = text.replace(/ +\n/g, "\n");
        return document.createTextNode(text);
      }

      if (node.nodeType === Node.ELEMENT_NODE) {
        const tag = node.tagName.toUpperCase();

        // Explicitly drop Word / HTML head style content so we don't see
        // "/* Font Definitions */ @font‑face { ... }" in the editor or bubble.
        if (["STYLE","SCRIPT","HEAD","META","LINK","TITLE"].includes(tag)) {
          return document.createTextNode("");
        }

        let fragment;
        if (!allowed.has(tag)) {
          fragment = document.createDocumentFragment();
          node.childNodes.forEach(child => fragment.appendChild(cleanNode(child)));
          return fragment;
        } else {
          const el = document.createElement(tag.toLowerCase());

          // For spans, only keep explicit colour styling (used for red text).
          if (tag === "SPAN" && node.style && node.style.color) {
            el.style.color = node.style.color;
          }

          node.childNodes.forEach(child => el.appendChild(cleanNode(child)));
          return el;
        }
      }

      return document.createTextNode("");
    }

    const out = document.createDocumentFragment();
    temp.childNodes.forEach(child => out.appendChild(cleanNode(child)));
    const wrapper = document.createElement("div");
    wrapper.appendChild(out);
    // Return HTML exactly as built by the cleaner – no extra collapsing of <br> tags,
    // so line breaks map 1:1 from the source.
    return wrapper.innerHTML;
  }

function renderCustomer() {
    if (!customerBubble || !customerInput) return;
    const text = getCustomerText();
    customerBubble.innerHTML = "<p>" + textToHtml(text) + "</p>";
    refreshMLCXState();
  
    // ChatFlow
    if (window.chatFlow && window.chatFlow.enabled) { cfRender(); }
  }



  function renderMLCXPillsFromState() {
    if (!mlcxPillsRow) return;

    const sentences = (mlcxState && Array.isArray(mlcxState.sentences))
      ? mlcxState.sentences
      : [];

    mlcxPillsRow.innerHTML = "";

    if (!sentences.length) {
      const ghost = document.createElement("div");
      ghost.className = "mlcx-pill mlcx-pill-empty";
      ghost.textContent = "No key phrases flagged yet – type notes to see excerpts.";
      mlcxPillsRow.appendChild(ghost);
      return;
    }

    sentences.forEach((item) => {
      const pill = document.createElement("div");
      pill.className = "mlcx-pill";

      const text = item.text || "";
      const trimmed = text.length > 50 ? text.slice(0, 47) + "…" : text;

      pill.textContent = "“" + trimmed + "”";

      mlcxPillsRow.appendChild(pill);
    });
  }
  // --- Issue counters / cycling state ---
  let ukIssueIndex = -1;
  let spellIssueIndex = -1;


// --- Live status dot (instrument indicator) ---
const liveDotEl = document.getElementById("mfLiveDot");
let _liveDotTimer = null;

function _setLiveDot(state) {
  if (!liveDotEl) return;
  liveDotEl.classList.remove("is-idle", "is-running", "is-hot", "is-error");
  liveDotEl.classList.add(state);
}

function pulseLiveDot(summary) {
  // summary: { total: number }
  if (!liveDotEl) return;
  _setLiveDot("is-running");
  if (_liveDotTimer) clearTimeout(_liveDotTimer);
  _liveDotTimer = setTimeout(() => {
    const total = summary && typeof summary.total === "number" ? summary.total : 0;
    if (total >= 8) _setLiveDot("is-hot");
    else _setLiveDot("is-idle");
  }, 420);
}
  function updateIssueCounters() {
    const ukCounterEl = document.getElementById("ukIssueCounter");
    const spellCounterEl = document.getElementById("spellIssueCounter");
    const agentEditor = document.getElementById("agentInput");
    if (!ukCounterEl || !spellCounterEl || !agentEditor) { _setLiveDot("is-error"); return; }

    const norm = (txt) => (txt || "").toLowerCase().replace(/[^a-z0-9']/gi, " ").trim();
    const countUnique = (nodeList) => {
      const set = new Set();
      nodeList.forEach(node => {
        const t = norm(node.textContent);
        if (t) set.add(t);
      });
      return set.size;
    };

    const ukSpans = agentEditor.querySelectorAll("span.uk-issue");
    const jargonSpans = agentEditor.querySelectorAll("span.spell-issue");

    const ukCount = countUnique(ukSpans);
    const spellCount = countUnique(jargonSpans);

    const total = ukCount + spellCount;

    ukCounterEl.textContent = "UK " + ukCount;
    ukCounterEl.classList.toggle("is-active", ukCount > 0);

    spellCounterEl.textContent = "Jargon " + spellCount;
    spellCounterEl.classList.toggle("is-active", spellCount > 0);

    pulseLiveDot({ total });
// Reset indexes if counts changed
    if (ukCount === 0) ukIssueIndex = -1;
    if (spellCount === 0) spellIssueIndex = -1;
  }

  function restoreLowpolyPattern() {
    if (lowpolySvg) {
      randomizeLowpolyPattern();
    }
  }

  
function randomizeLowpolyPattern() {
    if (!lowpolySvg) return;

    // Clean, fully connected low‑poly mesh based on a jittered grid
    const cols = 26;  // more columns = finer pattern
    const rows = 14;  // more rows = finer pattern
    const width = 100;
    const height = 60;
    const dx = width / cols;
    const dy = height / rows;
    const jitterX = dx * 0.22;
    const jitterY = dy * 0.22;

    // Build a global grid of jittered points so neighbouring triangles share vertices
    const points = [];
    for (let j = 0; j <= rows; j++) {
      const row = [];
      for (let i = 0; i <= cols; i++) {
        const baseX = i * dx;
        const baseY = j * dy;
        const offsetX = (Math.random() * 2 - 1) * jitterX;
        const offsetY = (Math.random() * 2 - 1) * jitterY;
        const x = Math.min(width, Math.max(0, baseX + offsetX));
        const y = Math.min(height, Math.max(0, baseY + offsetY));
        row.push([x, y]);
      }
      points.push(row);
    }

    function fmt(pt) {
      return pt[0].toFixed(2) + "," + pt[1].toFixed(2);
    }

    const paletteClasses = ["c1", "c2", "c3", "c4"];
    let markup = "";

    // Triangulate each grid cell using shared vertices
    for (let j = 0; j < rows; j++) {
      for (let i = 0; i < cols; i++) {
        const p00 = points[j][i];
        const p10 = points[j][i + 1];
        const p01 = points[j + 1][i];
        const p11 = points[j + 1][i + 1];

        const cls1 = paletteClasses[Math.floor(Math.random() * paletteClasses.length)];
        const cls2 = paletteClasses[Math.floor(Math.random() * paletteClasses.length)];

        const useMainDiagonal = ((i + j) % 2 === 0);

        if (useMainDiagonal) {
          // Diagonal from top‑left to bottom‑right
          markup += '<polygon class="' + cls1 + '" points="' + [fmt(p00), fmt(p10), fmt(p11)].join(" ") + '" />\n';
          markup += '<polygon class="' + cls2 + '" points="' + [fmt(p00), fmt(p11), fmt(p01)].join(" ") + '" />\n';
        } else {
          // Diagonal from bottom‑left to top‑right
          markup += '<polygon class="' + cls1 + '" points="' + [fmt(p00), fmt(p10), fmt(p01)].join(" ") + '" />\n';
          markup += '<polygon class="' + cls2 + '" points="' + [fmt(p10), fmt(p11), fmt(p01)].join(" ") + '" />\n';
        }
      }
    }

    lowpolySvg.setAttribute("viewBox", "0 0 " + width + " " + height);
    lowpolySvg.setAttribute("preserveAspectRatio", "xMidYMid slice");
    lowpolySvg.innerHTML = markup;
}

// Slightly adjust a hex or rgb colour by a small random amount (±10%).
function _parseColorToRGB(str) {
  str = str.trim();
  if (str.startsWith("rgb")) {
    const nums = str.match(/\d+/g);
    if (nums && nums.length >= 3) {
      return { r: parseInt(nums[0], 10), g: parseInt(nums[1], 10), b: parseInt(nums[2], 10) };
    }
  }
  if (str.startsWith("#")) {
    let hex = str.slice(1);
    if (hex.length === 3) {
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }
    const r = parseInt(hex.slice(0, 2), 16);
    const g = parseInt(hex.slice(2, 4), 16);
    const b = parseInt(hex.slice(4, 6), 16);
    return { r, g, b };
  }
  return null;
}

function _rgbToHex(r, g, b) {
  const toHex = (c) => {
    const h = c.toString(16);
    return h.length === 1 ? "0" + h : h;
  };
  return "#" + toHex(r) + toHex(g) + toHex(b);
}

function _adjustRGB(rgb) {
  const factor = (Math.random() - 0.5) * 0.2;
  const adjust = (c) => {
    const val = c + factor * 255;
    return Math.max(0, Math.min(255, Math.round(val)));
  };
  return { r: adjust(rgb.r), g: adjust(rgb.g), b: adjust(rgb.b) };
}

// Randomly tweak the low‑poly colour palette.  Called when the shuffle (dice)
// button is clicked to add subtle colour variation without changing the
// underlying theme.
function shuffleLowpolyColours() {
  const style = getComputedStyle(document.body);
  const vars = ["--bg-c1", "--bg-c2", "--bg-c3", "--bg-c4"];
  vars.forEach((vn) => {
    const current = style.getPropertyValue(vn).trim();
    if (!current) return;
    const rgb = _parseColorToRGB(current);
    if (!rgb) return;
    const adjusted = _adjustRGB(rgb);
    const newHex = _rgbToHex(adjusted.r, adjusted.g, adjusted.b);
    document.documentElement.style.setProperty(vn, newHex);
  });
}
function renderAgent() {
    let html = agentInput.innerHTML || "";
    html = cleanHtml(html);
    if (!html.replace(/<br\s*\/?>/gi, "").trim()) {
      agentBubble.innerHTML = "<p>Hi,<br>Thanks for reaching out, how can I help?</p>";
    } else {
      agentBubble.innerHTML = html;
    }
    const plain = getPlainTextFromHtml(html);
    if (charCount) {
      charCount.textContent = plain.length.toString();
    }
    updateIssueCounters();
    // ChatFlow
    if (window.chatFlow && window.chatFlow.enabled) { cfRender(); }
  }

    // --- UK language + spelling helpers for Clean ---
// House style: UK English
let UKUS_RULES = {
  // Things we’re happy to auto-suggest / auto-replace
  autoReplace: [
    // ---core -our/-or---
    {
      id: "color→colour",
      pattern: /\bcolor\b/gi,
      replacement: "colour",
      tooltip: "Use UK spelling ‘colour’.",
    },
    {
      id: "favorite→favourite",
      pattern: /\bfavorite\b/gi,
      replacement: "favourite",
      tooltip: "Use UK spelling ‘favourite’.",
    },
    {
      id: "behavior→behaviour",
      pattern: /\bbehavior\b/gi,
      replacement: "behaviour",
      tooltip: "Use UK spelling ‘behaviour’.",
    },
    {
      id: "neighbor→neighbour",
      pattern: /\bneighbor\b/gi,
      replacement: "neighbour",
      tooltip: "Use UK spelling ‘neighbour’.",
    },

    // ---centre/centre family---
    {
      id: "center→centre",
      pattern: /\bcenter\b/gi,
      replacement: "centre",
      tooltip: "Use UK spelling ‘centre’.",
    },
    {
      id: "fiber→fibre",
      pattern: /\bfiber\b/gi,
      replacement: "fibre",
      tooltip: "Use UK spelling ‘fibre’.",
    },
    {
      id: "liter→litre",
      pattern: /\bliter\b/gi,
      replacement: "litre",
      tooltip: "Use UK spelling ‘litre’.",
    },
    {
      id: "meter→metre(distance)",
      // NOTE: this is blunt; you may fine-tune later
      pattern: /\bmeter(s)?\b/gi,
      replacement: "metre$1",
      tooltip: "For distance, use ‘metre’. Use ‘meter’ only for devices.",
    },

    // ---common vowel swaps---
    {
      id: "gray→grey",
      pattern: /\bgray\b/gi,
      replacement: "grey",
      tooltip: "Use UK spelling ‘grey’.",
    },
    {
      id: "humor→humour",
      pattern: /\bhumor\b/gi,
      replacement: "humour",
      tooltip: "Use UK spelling ‘humour’.",
    },
    {
      id: "rumor→rumour",
      pattern: /\brumor\b/gi,
      replacement: "rumour",
      tooltip: "Use UK spelling ‘rumour’.",
    },
    {
      id: "vapor→vapour",
      pattern: /\bvapor\b/gi,
      replacement: "vapour",
      tooltip: "Use UK spelling ‘vapour’.",
    },
    {
      id: "odor→odour",
      pattern: /\bodor\b/gi,
      replacement: "odour",
      tooltip: "Use UK spelling ‘odour’.",
    },
    {
      id: "savior→saviour",
      pattern: /\bsavior\b/gi,
      replacement: "saviour",
      tooltip: "Use UK spelling ‘saviour’.",
    },
    {
      id: "labor→labour",
      pattern: /\blabor\b/gi,
      replacement: "labour",
      tooltip: "Use UK spelling ‘labour’.",
    },
    {
      id: "favor→favour",
      pattern: /\bfavor\b/gi,
      replacement: "favour",
      tooltip: "Use UK spelling ‘favour’.",
    },

    // ---catalogue / dialogue---
    {
      id: "catalog→catalogue",
      pattern: /\bcatalog\b/gi,
      replacement: "catalogue",
      tooltip: "Use UK spelling ‘catalogue’.",
    },
    {
      id: "dialog→dialogue",
      pattern: /\bdialog\b/gi,
      replacement: "dialogue",
      tooltip: "Use UK spelling ‘dialogue’.",
    },
    {
      id: "monolog→monologue",
      pattern: /\bmonolog\b/gi,
      replacement: "monologue",
      tooltip: "Use UK spelling ‘monologue’.",
    },

    // ---defence / licence family---
    {
      id: "defense→defence",
      pattern: /\bdefense\b/gi,
      replacement: "defence",
      tooltip: "Use UK spelling ‘defence’.",
    },
    {
      id: "offense→offence",
      pattern: /\boffense\b/gi,
      replacement: "offence",
      tooltip: "Use UK spelling ‘offence’.",
    },

    // ---materials / science---
    {
      id: "aluminum→aluminium",
      pattern: /\baluminum\b/gi,
      replacement: "aluminium",
      tooltip: "Use UK spelling ‘aluminium’.",
    },
    {
      id: "sulfur→sulphur",
      pattern: /\bsulfur\b/gi,
      replacement: "sulphur",
      tooltip: "Use UK spelling ‘sulphur’.",
    },
    {
      id: "estrogen→oestrogen",
      pattern: /\bestrogen\b/gi,
      replacement: "oestrogen",
      tooltip: "Use UK spelling ‘oestrogen’.",
    },
    {
      id: "pediatric→paediatric",
      pattern: /\bpediatric\b/gi,
      replacement: "paediatric",
      tooltip: "Use UK spelling ‘paediatric’.",
    },
    {
      id: "fetal→foetal",
      pattern: /\bfetal\b/gi,
      replacement: "foetal",
      tooltip: "Use UK spelling ‘foetal’.",
    },

    // ---mould / plough---
    {
      id: "mold→mould",
      pattern: /\bmold\b/gi,
      replacement: "mould",
      tooltip: "Use UK spelling ‘mould’.",
    },
    {
      id: "plow→plough",
      pattern: /\bplow\b/gi,
      replacement: "plough",
      tooltip: "Use UK spelling ‘plough’.",
    },

    // ---double consonant variants---
    {
      id: "modeling→modelling",
      pattern: /\bmodeling\b/gi,
      replacement: "modelling",
      tooltip: "Use ‘modelling’ (double ‘l’) in UK English.",
    },
    {
      id: "modeled→modelled",
      pattern: /\bmodeled\b/gi,
      replacement: "modelled",
      tooltip: "Use ‘modelled’ (double ‘l’) in UK English.",
    },
    {
      id: "fueling→fuelling",
      pattern: /\bfueling\b/gi,
      replacement: "fuelling",
      tooltip: "Use ‘fuelling’ (double ‘l’) in UK English.",
    },

    // ---household / everyday---
    {
      id: "jewelry→jewellery",
      pattern: /\bjewelry\b/gi,
      replacement: "jewellery",
      tooltip: "Use UK spelling ‘jewellery’.",
    },
    {
      id: "mustache→moustache",
      pattern: /\bmustache\b/gi,
      replacement: "moustache",
      tooltip: "Use UK spelling ‘moustache’.",
    },
    {
      id: "pajamas→pyjamas",
      pattern: /\bpajamas\b/gi,
      replacement: "pyjamas",
      tooltip: "Use UK spelling ‘pyjamas’.",
    },

    // ---ise/yse vs ize/yze---
    {
      id: "organize→organise",
      pattern: /\borganize(d|s|r|ing)?\b/gi,
      replacement: (match, suffix) => {
        const base = "organise";
        return suffix ? base + suffix : base;
      },
      tooltip: "Use UK spelling ‘organise/organised/organising’.",
    },
    {
      id: "recognize→recognise",
      pattern: /\brecognize(d|s|r|ing)?\b/gi,
      replacement: (match, suffix) => {
        const base = "recognise";
        return suffix ? base + suffix : base;
      },
      tooltip: "Use UK spelling ‘recognise/recognised/recognising’.",
    },
    {
      id: "apologize→apologise",
      pattern: /\bapologize(d|s|r|ing)?\b/gi,
      replacement: (match, suffix) => {
        const base = "apologise";
        return suffix ? base + suffix : base;
      },
      tooltip: "Use UK spelling ‘apologise’ (-ise).",
    },
    {
      id: "analyze→analyse",
      pattern: /\banalyz(e|ed|es|ing)\b/gi,
      replacement: (match, suffix) => {
        // e / ed / es / ing -> analyse / analysed / analyses / analysing
        const map = {
          "e": "analyse",
          "ed": "analysed",
          "es": "analyses",
          "ing": "analysing",
        };
        return map[suffix] || "analyse";
      },
      tooltip: "Use UK spelling ‘analyse/analysed/analysing’.",
    },

    // ---double consonants---
    {
      id: "traveling→travelling",
      pattern: /\btraveling\b/gi,
      replacement: "travelling",
      tooltip: "Use ‘travelling’ (double ‘l’) in UK English.",
    },
    {
      id: "traveled→travelled",
      pattern: /\btraveled\b/gi,
      replacement: "travelled",
      tooltip: "Use ‘travelled’ (double ‘l’) in UK English.",
    },
    {
      id: "canceled→cancelled",
      pattern: /\bcanceled\b/gi,
      replacement: "cancelled",
      tooltip: "Use ‘cancelled’ (double ‘l’) in UK English.",
    },
    {
      id: "canceling→cancelling",
      pattern: /\bcanceling\b/gi,
      replacement: "cancelling",
      tooltip: "Use ‘cancelling’ (double ‘l’) in UK English.",
    },
    {
      id: "labeled→labelled",
      pattern: /\blabeled\b/gi,
      replacement: "labelled",
      tooltip: "Use ‘labelled’ (double ‘l’) in UK English.",
    },
    {
      id: "labeling→labelling",
      pattern: /\blabeling\b/gi,
      replacement: "labelling",
      tooltip: "Use ‘labelling’ (double ‘l’) in UK English.",
    },

    // ---insurance / driving specific---
    {
      id: "tire→tyre",
      pattern: /\btire(s)?\b/gi,
      replacement: "tyre$1",
      tooltip: "For car wheels, use ‘tyre/tyres’ (UK).",
    },
    {
      id: "gas→petrol",
      pattern: /\bgas station\b/gi,
      replacement: "petrol station",
      tooltip: "Use ‘petrol station’ instead of US ‘gas station’.",
    },
    {
      id: "milage→mileage",
      pattern: /\bmilage\b/gi,
      replacement: "mileage",
      tooltip: "Correct spelling is ‘mileage’.",
    },
    {
      id: "curb→kerb",
      pattern: /\bcurb\b/gi,
      replacement: "kerb",
      tooltip: "For the edge of the pavement, use ‘kerb’.",
    },

    // ---style extras---
    {
      id: "e-mail→email",
      pattern: /\be-mail\b/gi,
      replacement: "email",
      tooltip: "House style is ‘email’ (no hyphen).",
    }
  ],

  // Things that need HUMAN judgement (we only nudge, not auto-fix)
  manualCheck: [
    {
      id: "check/cheque",
      pattern: /\bcheck(s|ed|ing)?\b/gi,
      tooltip: "If you mean a bank payment, use ‘cheque’. If you mean ‘review’ or ‘verify’, ‘check’ is fine.",
    },
    {
      id: "practice/practise",
      pattern: /\bpracti(c|s)e(d|s|ing)?\b/gi,
      tooltip: "Use ‘practice’ for the noun (a thing) and ‘practise’ for the verb (an action).",
    },
    {
      id: "inquiry/enquiry",
      pattern: /\binquiry\b/gi,
      tooltip: "Use ‘enquiry’ for general customer questions. ‘Inquiry’ is usually for formal investigations.",
    },
    {
      id: "license/licence",
      pattern: /\blicen[cs]e\b/gi,
      tooltip: "In UK English, ‘licence’ is the noun (driving licence) and ‘license’ is the verb.",
    },
    {
      id: "advisor/adviser",
      pattern: /\badvisor(s)?\b/gi,
      tooltip: "House style is often ‘adviser’ rather than ‘advisor’ – check your template.",
    },
    {
      id: "program/programme",
      pattern: /\bprogram(me)?\b/gi,
      tooltip: "Use ‘programme’ for schemes/initiatives; keep ‘program’ for computer software.",
    },
    {
      id: "story/storey",
      pattern: /\bstory\b/gi,
      tooltip: "For building levels, use ‘storey’ (e.g. ‘two-storey car park’).",
    },
    {
      id: "email/Email caps",
      pattern: /\b[Ee]-?mail\b/gi,
      tooltip: "House style is usually ‘email’ in lowercase, unless starting a sentence.",
    },
    {
      id: "OK/okay",
      pattern: /\bOK\b/gi,
      tooltip: "House style may prefer ‘okay’ in full sentences. Check your template.",
    },
    {
      id: "draft/draught",
      pattern: /\bdraft(s|ed|ing)?\b/gi,
      tooltip: "If you mean airflow or beer, use ‘draught’. If you mean a rough copy, ‘draft’ is fine.",
    },
    {
      id: "sidewalk/pavement",
      pattern: /\bsidewalk\b/gi,
      tooltip: "Use UK term ‘pavement’ for pedestrian paths.",
    },
    {
      id: "apartment/flat",
      pattern: /\bapartment\b/gi,
      tooltip: "Use UK term ‘flat’ unless the US term is required.",
    },
    {
      id: "elevator/lift",
      pattern: /\belevator\b/gi,
      tooltip: "Use UK term ‘lift’.",
    },
    {
      id: "truck/lorry",
      pattern: /\btruck\b/gi,
      tooltip: "Use UK term ‘lorry’ for large goods vehicles.",
    },
    {
      id: "parking lot/car park",
      pattern: /\bparking lot\b/gi,
      tooltip: "Use UK term ‘car park’.",
    },
    {
      id: "trunk/boot",
      pattern: /\btrunk\b/gi,
      tooltip: "For car storage, use UK term ‘boot’.",
    },
    {
      id: "hood/bonnet",
      pattern: /\bhood\b/gi,
      tooltip: "For car front cover, use UK term ‘bonnet’.",
    },
    {
      id: "faucet/tap",
      pattern: /\bfaucet\b/gi,
      tooltip: "Use UK term ‘tap’.",
    },
    {
      id: "diaper/nappy",
      pattern: /\bdiaper\b/gi,
      tooltip: "Use UK term ‘nappy’.",
    },
    {
      id: "cellphone/mobile",
      pattern: /\bcell ?phone\b/gi,
      tooltip: "Use UK term ‘mobile’.",
    },
    {
      id: "flashlight/torch",
      pattern: /\bflashlight\b/gi,
      tooltip: "Use UK term ‘torch’.",
    }
  ]
};


function stripColoursAndIssueMarks(root) {
    if (!root) return;
    // Remove inline colour styling
    root.querySelectorAll("span, b, strong, em, u, p, li").forEach((el) => {
      if (el.style && el.style.color) {
        el.style.color = "";
      }
    });
    // Remove previous issue highlight wrappers
    root.querySelectorAll("span.uk-issue, span.spell-issue").forEach((span) => {
      const text = span.textContent || "";
      const parent = span.parentNode;
      if (!parent) return;
      const textNode = document.createTextNode(text);
      parent.replaceChild(textNode, span);
      parent.normalize();
    });
  }

  // Lightweight cleaning indicator (lazy-create)
  function showCleaningIndicator() {
    let el = document.getElementById("cleaningIndicator");
    if (!el) {
      el = document.createElement("span");
      el.id = "cleaningIndicator";
      el.textContent = "Cleaning…";
      el.style.cssText = "margin-left:8px;padding:2px 8px;background:#fff7db;border:1px solid #eedc9b;border-radius:4px;font-size:12px;color:#6b4f00";
      const toolbar = document.querySelector(".toolbar") || document.querySelector("#toolbar") || document.querySelector(".editor-toolbar");
      (toolbar || document.body).appendChild(el);
    }
    el.style.display = "inline-block";
  }

  function hideCleaningIndicator() {
    const el = document.getElementById("cleaningIndicator");
    if (el) el.style.display = "none";
  }

  // --- Master clean pipeline for the agent editor ---
  async function runCleanPipeline() {
    if (!agentInput) return;

    console.log("[runCleanPipeline] start");

    // Disable the clean button(s) to avoid re-entrancy while running
    disableCleanControls();

    try {
      // 1) Reset any UI state
      try {
        if (typeof hideIssueTooltip === "function") hideIssueTooltip();
      } catch (e) {
        console.warn("hideIssueTooltip error", e);
      }

      // 2) Strip old colours + issue marks first
      try {
        stripColoursAndIssueMarks(agentInput);
      } catch (e) {
        console.error("stripColoursAndIssueMarks failed:", e);
      }

      // 3) Clean up the HTML structure (Word cruft, meta tags, NBSP, etc.)
      try {
        const rawHtml = agentInput.innerHTML || "";
        const cleanedHtml = cleanHtml(rawHtml);
        agentInput.innerHTML = cleanedHtml;
      } catch (e) {
        console.error("cleanHtml failed:", e);
      }

      // 4) Re-mark issues using lightweight UK + jargon helpers (no server calls)
      if (!spellHintsMuted) {
        try {
          if (typeof markUkIssues === "function") {
            markUkIssues(agentInput);
          }
          if (typeof markJargonIssues === "function") {
            markJargonIssues(agentInput);
          }
        } catch (e) {
          console.error("Local highlighting failed:", e);
        }
        try {
          updateIssueCounters();
        } catch (e) {
          console.warn("updateIssueCounters failed", e);
        }
      } else {
        // Hints are muted: keep the text cleaned but leave all highlighting off.
        try {
          updateIssueCounters();
        } catch (e) {
          console.warn("updateIssueCounters failed (muted)", e);
        }
      }

// 5) Nudge the browser spellchecker so native underlines refresh
      try {
        const evt = new InputEvent("input", { bubbles: true });
        agentInput.dispatchEvent(evt);
      } catch (e) {
        try {
          const evt = document.createEvent("Event");
          evt.initEvent("input", true, true);
          agentInput.dispatchEvent(evt);
        } catch (err) {
          console.warn("Dispatch input event failed:", err);
        }
      }

      // 6) Sync preview + char count
      try { renderAgent(); } catch (e) { console.warn("renderAgent failed:", e); }

      // 7) Store state for undo/redo
      try { pushAgentHistory(); } catch (e) { console.warn("pushAgentHistory failed:", e); }

      console.log("[runCleanPipeline] done");
    } finally {
      // Always re-enable the clean controls regardless of success/failure
      enableCleanControls();
    }
  }

  
  function markUkIssues(root) {
    if (!root) return;

    function walk(node) {
      if (node.nodeType === Node.TEXT_NODE) {
        const text = node.textContent || "";
        if (!/[A-Za-z]/.test(text)) {
          return;
        }

        let frag = document.createDocumentFragment();
        const FIN_GATE = /\b(bank|payment|pay|paid|amount|invoice|refund|card|debit|credit|direct\s+debit|account|sort\s+code|iban|swift|cheque|check|£|\$|€)\b/i;
        const passesFinancialGate = (rawText, idx) => {
          const start = Math.max(0, idx - 60);
          const end = Math.min(rawText.length, idx + 60);
          const ctx = rawText.slice(start, end);
          return FIN_GATE.test(ctx);
        };

        const findNextMatch = (rule, rawText, cursorPos) => {
          if (!rule?.pattern) return null;
          rule.pattern.lastIndex = cursorPos;
          let m;
          while ((m = rule.pattern.exec(rawText)) !== null) {
            if (rule.gate === 'financial' && !passesFinancialGate(rawText, m.index)) {
              // keep scanning for a later match that *does* have financial context
              continue;
            }
            return m;
          }
          return null;
        };

        let cursor = 0;
        let changed = false;

        while (cursor < text.length) {
          let earliestMatch = null;
          let earliestRule = null;
          let earliestType = null; // "auto" or "manual"

          // Scan autoReplace rules
          if (UKUS_RULES && Array.isArray(UKUS_RULES.autoReplace)) {
            for (const rule of UKUS_RULES.autoReplace) {
              if (!rule.pattern) continue;
              const m = findNextMatch(rule, text, cursor);
              if (m && (earliestMatch === null || m.index < earliestMatch.index)) {
                earliestMatch = m;
                earliestRule = rule;
                earliestType = "auto";
              }
            }
          }

          // Scan manualCheck rules
          if (UKUS_RULES && Array.isArray(UKUS_RULES.manualCheck)) {
            for (const rule of UKUS_RULES.manualCheck) {
              if (!rule.pattern) continue;
              const m = findNextMatch(rule, text, cursor);
              if (m && (earliestMatch === null || m.index < earliestMatch.index)) {
                earliestMatch = m;
                earliestRule = rule;
                earliestType = "manual";
              }
            }
          }

          if (!earliestMatch) break;

          const matchIndex = earliestMatch.index;
          const matchText = earliestMatch[0];

          if (matchIndex > cursor) {
            frag.appendChild(document.createTextNode(text.slice(cursor, matchIndex)));
          }

          const span = document.createElement("span");
          span.className = "uk-issue";
          span.textContent = matchText;

          // Tooltip + suggestion
          let tooltip = earliestRule && earliestRule.tooltip
            ? earliestRule.tooltip
            : "Check UK/US usage and house style for this word.";

          if (earliestType === "auto" && earliestRule) {
            let suggestion = null;
            if (typeof earliestRule.replacement === "function") {
              // Pass the match text and capture groups into the function
              const groups = earliestMatch.length > 1 ? earliestMatch.slice(1) : [];
              const named = (earliestMatch && earliestMatch.groups) ? earliestMatch.groups : null;
 try {
   // Preferred signature: (matchText, groupsArray, namedGroups, fullMatch)
   suggestion = (earliestRule.replacement.length >= 3)
     ? earliestRule.replacement(matchText, groups, named, earliestMatch)
     : earliestRule.replacement(matchText, groups);
 } catch (e) {
   // Back-compat: some legacy fns expected positional captures
   try { suggestion = earliestRule.replacement(matchText, ...groups); } catch (_) { suggestion = null; }
 }
} else if (typeof earliestRule.replacement === "string") {
              if (earliestRule.replacement.indexOf("$") !== -1) {
                try {
                  suggestion = matchText.replace(earliestRule.pattern, earliestRule.replacement);
                } catch (e) {
                  suggestion = earliestRule.replacement.replace("$1", earliestMatch[1] || "");
                }
              } else {
                suggestion = earliestRule.replacement;
              }
            }
            if (suggestion) {
              span.dataset.suggestion = suggestion;
              if (!earliestRule.tooltip) {
                tooltip = "UK spelling suggestion: " + suggestion;
              }
            }
          }

          span.title = tooltip;
          frag.appendChild(span);

          cursor = matchIndex + matchText.length;
          changed = true;
        }

        if (!changed) {
          return;
        }

        if (cursor < text.length) {
          frag.appendChild(document.createTextNode(text.slice(cursor)));
        }

        const parent = node.parentNode;
        if (parent) {
          parent.replaceChild(frag, node);
          parent.normalize();
        }
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        // Avoid recursing into already marked spans
        if (node.classList && node.classList.contains("uk-issue")) return;
        Array.from(node.childNodes).forEach(walk);
      }
    }

    walk(root);
  }


// Domain-specific jargon / clarity helper
  // Flags a small set of industry terms so agents can double-check
  // that wording is clear for customers.
  // Domain-specific jargon / clarity helper
  // Flags insurance/claims jargon so agents can decide whether to explain,
  // rewrite in plain English, or keep it very brief.
  let jargonPatterns = [
    // --- Abbreviations & acronyms ---
    {
      pattern: /\bNCD\b/gi,
      suggestion: "no claims discount (NCD)",
      note: "NCD = No Claims Discount – the discount you earn for claim-free years. Spell it out the first time you use it."
    },
    {
      pattern: /\bNCB\b/gi,
      suggestion: "no claims discount (also called no claims bonus)",
      note: "NCB = No Claims Bonus – another way of saying no claims discount. Explain briefly the first time."
    },
    {
      pattern: /\bFNOL\b/gi,
      suggestion: "when you first told us about the incident",
      note: "FNOL = First Notification of Loss – internal shorthand. Avoid using the acronym with customers; describe the event instead."
    },
    {
      pattern: /\bQNOL\b/gi,
      suggestion: "when you first told us about the incident",
      note: "QNOL = Quick Notification of Loss – internal shorthand. Avoid this term with customers; describe the process in normal language."
    },
    {
      pattern: /\bTPO\b/gi,
      suggestion: "third party only cover",
      note: "TPO = Third Party Only – cover for damage you cause to other people and their property. Briefly explain what is and isn’t covered."
    },
    {
      pattern: /\bTPFT\b/gi,
      suggestion: "third party, fire and theft cover",
      note: "TPFT = Third Party, Fire and Theft – cover for others, plus fire and theft on your car. Spell it out at least once."
    },
    {
      pattern: /\bTPPD\b/gi,
      suggestion: "damage to someone else’s property",
      note: "TPPD = Third Party Property Damage – damage to someone else’s property. Prefer the plain explanation."
    },
    {
      pattern: /\bT\/?L\b/gi,
      suggestion: "total loss (written off)",
      note: "T/L = Total Loss – when the car is written off or uneconomical to repair. Add ‘written off’ or similar plain language."
    },
    {
      pattern: /\bLEI\b/gi,
      suggestion: "legal expenses cover",
      note: "LEI = Legal Expenses Insurance – cover for certain legal costs after an incident. Say ‘legal expenses cover’ and briefly explain what it helps with."
    },
    {
      pattern: /\bMLEI\b/gi,
      suggestion: "motor legal expenses cover",
      note: "MLEI = Motor Legal Expenses Insurance – legal cover linked to a motor policy. Spell it out the first time."
    },
    {
      pattern: /\bPH\b/gi,
      suggestion: "the policyholder",
      note: "PH = Policyholder – the person who owns the policy. With customers, say ‘you’ or ‘the policyholder’ rather than ‘PH’."
    },
    {
      pattern: /\bND\b/gi,
      suggestion: "named driver",
      note: "ND = Named Driver – a driver listed on the policy who isn’t the main policyholder. Use ‘named driver’ in full."
    },
    {
      pattern: /\bTP\b/gi,
      suggestion: "the other driver / the other person",
      note: "TP = Third Party – the other person involved in the incident. Say ‘the other driver’ or ‘the other person’ instead of ‘the TP’."
    },
    {
      pattern: /\bTPI\b/gi,
      suggestion: "the other driver’s insurer (TPI)",
      note: "TPI = Third Party Insurer – the other driver’s insurance company. Spell it out once, then you can shorten it."
    },
    {
      pattern: /\bV5C\b/gi,
      suggestion: "your V5C logbook (vehicle registration document)",
      note: "V5C is the vehicle registration document (logbook). Saying ‘V5C logbook’ once usually avoids confusion."
    },
    {
      pattern: /\bCat(?:egory)?\s*S\b/gi,
      suggestion: "Category S (structural damage)",
      note: "Category S means structural damage. The vehicle can be repaired and returned to the road, but will be recorded as previously written off."
    },
    {
      pattern: /\bCat(?:egory)?\s*N\b/gi,
      suggestion: "Category N (non‑structural damage)",
      note: "Category N means non‑structural damage. The vehicle can be repaired and returned to the road, but will be recorded as previously written off."
    },

    {
      pattern: /\bMTA\b/gi,
      suggestion: "a change to your policy (mid-term adjustment)",
      note: "MTA = Mid-Term Adjustment – a change made to the policy during the year. Spell it out at least once."
    },
    {
      pattern: /\bSOP\b/gi,
      suggestion: "our internal guidelines",
      note: "SOP = Standard Operating Procedure – our internal process guide. Avoid mentioning SOPs; explain the outcome, not the internal process."
    },
    {
      pattern: /\bMID\b/gi,
      suggestion: "the Motor Insurance Database (MID)",
      note: "MID = Motor Insurance Database – the national database of insured vehicles. Say ‘the national Motor Insurance Database (MID)’ the first time."
    },
    {
      pattern: /\bVRN\b/gi,
      suggestion: "your car’s registration number (VRN)",
      note: "VRN = Vehicle Registration Number – the car’s number plate. Spell it out the first time."
    },
    {
      pattern: /\bDVLA\b/gi,
      suggestion: "the DVLA (the UK body that looks after vehicle and driver records)",
      note: "DVLA = Driver and Vehicle Licensing Agency – the UK body that looks after vehicle and driver records. Add a short explanation once."
    },
    {
      pattern: /\bDPA\b/gi,
      suggestion: "data protection law (Data Protection Act)",
      note: "DPA = Data Protection Act – law that protects how we use personal data. Link it to ‘data protection law’ when mentioned."
    },
    {
      pattern: /\bCiVC\b/gi,
      suggestion: "customers in vulnerable circumstances",
      note: "CiVC = Customers in Vulnerable Circumstances – internal label. Describe the support you can offer, not the internal flag name."
    },
    {
      pattern: /\bAMC\b/gi,
      suggestion: "our accident management company (who arrange repairs and hire cars)",
      note: "AMC = Accident Management Company – helps manage repairs, recovery and hire cars. Briefly explain who they are and what they do."
    },

    // --- Technical insurance terms ---
    {
      pattern: /\bpolicyholder\b/gi,
      suggestion: "policyholder (the person who owns the policy)",
      note: "Policyholder – the person who owns the insurance policy. Use ‘you’ where possible and ‘policyholder’ only when needed for clarity."
    },
    {
      pattern: /\bnamed driver\b/gi,
      suggestion: "named driver (someone listed on the policy who can drive the car)",
      note: "Named driver – someone listed on the policy who is allowed to drive the car but does not own the policy. Explain the difference from the main policyholder if it matters."
    },
    {
      pattern: /\bmulti[- ]car account\b/gi,
      suggestion: "an account with more than one car or policy",
      note: "Multi car account – one account that holds more than one car or policy. Say ‘your account with more than one car/policy’."
    },
    {
      pattern: /\bcomprehensive cover\b/gi,
      suggestion: "comprehensive cover (the widest level of cover, including your own car)",
      note: "Comprehensive cover – the widest level of cover, usually including damage to your own car and others. Briefly list what is covered."
    },
    {
      pattern: /\bexcess\b/gi,
      suggestion: "the first part of a claim you pay yourself (your excess)",
      note: "Excess – the first part of a claim you pay yourself. Say ‘the first £X of any claim, called your excess’."
    },
    {
      pattern: /\bpremium\b/gi,
      suggestion: "your insurance price (premium)",
      note: "Premium – the price you pay for your insurance. You can say ‘your insurance price (premium)’ once, then ‘premium’ alone is fine."
    },
    {
      pattern: /\bendorsement\b/gi,
      suggestion: "a special rule on your policy (called an endorsement)",
      note: "Endorsement – a special rule or change added to the policy. Prefer plain language and explain briefly."
    },
    {
      pattern: /\bexclusion\b/gi,
      suggestion: "something your policy does not cover (an exclusion)",
      note: "Exclusion – something the policy does not cover. Add a short explanation of what is excluded."
    },
    {
      pattern: /\bfault claim\b/gi,
      suggestion: "a claim where we can’t recover all costs from someone else’s insurer (fault claim)",
      note: "Fault claim – a claim where the insurer cannot recover all costs from someone else’s insurer. Explain that ‘fault’ is about who pays, not about blame."
    },
    {
      pattern: /\bnon[- ]fault claim\b/gi,
      suggestion: "a claim where we can recover costs from another insurer (non-fault claim)",
      note: "Non-fault claim – a claim where costs can be recovered from another insurer. Clarify that it can still affect price."
    },
    {
      pattern: /\btotal loss\b/gi,
      suggestion: "total loss (written off)",
      note: "Total loss / write-off – when the car is so badly damaged we pay its value instead of repairing it. Add ‘written off’ or similar."
    },
    {
      pattern: /\bwrite[- ]off\b/gi,
      suggestion: "written off (total loss)",
      note: "Write-off – common shorthand for a total loss. Make clear that we pay the car’s value instead of repairing it."
    },
    {
      pattern: /\bpre-accident value\b/gi,
      suggestion: "the value of your car just before the accident (pre-accident value)",
      note: "Pre-accident value – what the car was worth just before the incident. Spell this out in simple language."
    },
    {
      pattern: /\bsettlement\b/gi,
      suggestion: "the payment we make to you (settlement)",
      note: "Settlement – the amount paid to settle a claim. Say ‘the payment we make to you (settlement)’."
    },
    {
      pattern: /\bliability\b/gi,
      suggestion: "who is legally responsible for the costs (liability)",
      note: "Liability – who is legally responsible for the costs of the incident. Explain it in that way."
    },
    {
      pattern: /\bindemnify\b/gi,
      suggestion: "put you back, as closely as possible, in the position you were in before the loss",
      note: "Indemnify / indemnity – legal term for putting you back, as closely as possible, in the position you were in before the loss. Prefer the plain explanation."
    },
    {
      pattern: /\bindemnity\b/gi,
      suggestion: "put you back, as closely as possible, in the position you were in before the loss",
      note: "Indemnity – legal term for putting you back in the position you were in before the loss. Prefer the plain explanation instead of the word."
    },
    {
      pattern: /\bunderwriting\b/gi,
      suggestion: "our pricing and risk team (underwriting)",
      note: "Underwriting – how the insurer assesses risk and decides prices and terms for cover. Say ‘our pricing and risk team (underwriting)’ if you mention it."
    },
    {
      pattern: /\bwear and tear\b/gi,
      suggestion: "natural wear and tear over time",
      note: "Wear and tear – natural ageing or deterioration of the vehicle over time. You can add a small example, e.g. tyres wearing down."
    },

    // --- Internal / “agent speak” terms ---
    {
      pattern: /\blog a claim\b/gi,
      suggestion: "start a claim for you",
      note: "‘Log a claim’ is internal shorthand. Say ‘start a claim for you’ instead."
    },
    {
      pattern: /\braise a claim\b/gi,
      suggestion: "open a claim for you",
      note: "‘Raise a claim’ is internal shorthand. Say ‘open a claim’ or ‘start a claim’ instead."
    },
    {
      pattern: /\bclose the claim\b/gi,
      suggestion: "finish working on your claim and close it on our system",
      note: "Internal process phrase. Explain that you’ll finish working on the claim and close it on the system."
    },
    {
      pattern: /\breopen the claim\b/gi,
      suggestion: "reopen your claim on our system",
      note: "Internal process phrase. Say ‘we can reopen your claim on our system if needed’."
    },
    {
      pattern: /\bclaim costs\b/gi,
      suggestion: "the total amount we pay because of this claim",
      note: "Claim costs – internal phrase for the total amount paid because of the claim. Prefer a plainer explanation."
    },
    {
      pattern: /\bincident date\b/gi,
      suggestion: "the date it happened (incident date)",
      note: "Incident date – internal term for the date the event happened. You can say ‘the date it happened (incident date)’."
    },
    {
      pattern: /\bthird[- ]party vehicle\b/gi,
      suggestion: "the other driver’s car",
      note: "Third-party vehicle – the other person’s car involved in the incident. Prefer ‘the other driver’s car’."
    },
    {
      pattern: /\bthird[- ]party insurer\b/gi,
      suggestion: "the other driver’s insurer",
      note: "Third-party insurer – the insurance company of the other person involved in the incident. Say ‘the other driver’s insurer’."
    },
    {
      pattern: /\bengineer report\b/gi,
      suggestion: "a vehicle engineer’s report about the damage",
      note: "Engineer report – report from a vehicle engineer assessing the damage and repair options. Explain it in simple terms."
    },
    {
      pattern: /\brecovery department\b/gi,
      suggestion: "our team that recovers costs from the other insurer",
      note: "Recovery department – the team that tries to claim money back from other insurers. Use plain language to describe them."
    },
    {
      pattern: /\bapproved repairer\b/gi,
      suggestion: "a garage we’ve approved to do the repairs",
      note: "Approved repairer – a garage we’ve checked and agreed to work with. Make that clear to the customer."
    },
    {
      pattern: /\bown repairer\b/gi,
      suggestion: "a repairer you choose yourself",
      note: "Own repairer – a repairer the customer chooses themselves. Say ‘a repairer you choose yourself’."
    },
    {
      pattern: /\bescalat(e|ion)\b/gi,
      suggestion: "ask a specialist or manager to review this",
      note: "Escalate / escalation – internal wording for sending the case to a more senior or specialist team. Say ‘we’ll ask a specialist/manager to review this’."
    },
    {
      pattern: /\bclaim registration\b/gi,
      suggestion: "setting up your claim on our system",
      note: "Claim registration – process of setting up the claim on the system. Explain this in plain English."
    },
    {
      pattern: /\bdraft claim\b/gi,
      suggestion: "a claim that’s been started but not fully completed or submitted",
      note: "Draft claim – a claim started but not fully completed or submitted. Avoid the phrase; instead explain what’s missing or what happens next."
    },

    // --- Additional insurance / claims clarity ---
    {
      pattern: /\bsubrogation\b/gi,
      suggestion: "recovering costs from another insurer (subrogation)",
      note: "Subrogation – recovering costs from another insurer or party. Explain that we try to claim money back on your behalf.",
    },
    {
      pattern: /\buninsured loss recovery\b/gi,
      suggestion: "help recovering out-of-pocket costs (uninsured loss recovery)",
      note: "Uninsured loss recovery – cover that helps reclaim costs not covered by the main policy (excess, travel, etc.). Say this plainly.",
    },
    {
      pattern: /\bcredit hire\b/gi,
      suggestion: "a hire car provided on credit (credit hire)",
      note: "Credit hire – a replacement car provided on credit while costs are claimed back. Explain that it depends on recovery from another insurer.",
    },
    {
      pattern: /\bcredit repair\b/gi,
      suggestion: "repairs arranged on credit while we recover costs",
      note: "Credit repair – repairs arranged on credit while the insurer seeks recovery. Spell out that charges may depend on liability.",
    },
    {
      pattern: /\bcourtesy car\b/gi,
      suggestion: "a temporary car we provide while yours is repaired (courtesy car)",
      note: "Courtesy car – a temporary car while repairs happen. Clarify if it’s guaranteed, like-for-like, or subject to availability.",
    },
    {
      pattern: /\breplacement vehicle\b/gi,
      suggestion: "a temporary hire car (replacement vehicle)",
      note: "Replacement vehicle – usually a hired car while yours is off the road. Say ‘temporary hire car’ and set expectations.",
    },
    {
      pattern: /\bbetterment\b/gi,
      suggestion: "an improvement beyond pre-incident condition (betterment)",
      note: "Betterment – when a repair would leave the vehicle better than before. Explain any customer contribution clearly.",
    },
    {
      pattern: /\bdiminution of value\b/gi,
      suggestion: "any loss in value after repairs (diminution of value)",
      note: "Diminution of value – potential drop in value after repairs. Explain simply and state if the policy covers it.",
    },
    {
      pattern: /\bsalvage\b/gi,
      suggestion: "what happens to the vehicle after a write-off (salvage)",
      note: "Salvage – what happens to the vehicle after a write-off. Explain options (we keep it, or you keep it with a reduced payout).",
    },
    {
      pattern: /\bschedule of insurance\b/gi,
      suggestion: "your policy schedule (summary of cover)",
      note: "Schedule of insurance – the document that summarises cover, limits and endorsements. Say ‘your policy schedule’ and what it shows.",
    },
    {
      pattern: /\bcertificate of (motor )?insurance\b/gi,
      suggestion: "your certificate of insurance (proof you’re insured)",
      note: "Certificate of insurance – proof that you’re insured. Mention it’s your evidence of cover, often needed for authorities.",
    },
    {
      pattern: /\bpolicy schedule\b/gi,
      suggestion: "your policy schedule (summary of what’s covered)",
      note: "Policy schedule – summary of what’s covered, limits and endorsements. Use plain wording about what it lists.",
    },
    {
      pattern: /\brenewal (notice|invite)?\b/gi,
      suggestion: "your renewal notice (offer for the next year)",
      note: "Renewal notice/invite – the offer for next year’s cover. Say it’s the renewal offer and call out key changes.",
    },
    {
      pattern: /\blapse(d)? policy\b/gi,
      suggestion: "a policy that has ended because it wasn’t renewed",
      note: "Lapsed policy – a policy that ended because it wasn’t renewed. State that cover stops after the lapse date.",
    },
    {
      pattern: /\bno claims (bonus|discount) protection\b/gi,
      suggestion: "protection for your no claims discount",
      note: "No claims bonus/discount protection – cover that shields your discount after certain claims. Explain limits and when it applies.",
    },
    {
      pattern: /\bexcess protection\b/gi,
      suggestion: "cover that refunds your excess after a claim",
      note: "Excess protection – cover that can refund the excess after a claim (subject to terms). Spell that out in plain language.",
    },
    {
      pattern: /\bpersonal accident cover\b/gi,
      suggestion: "personal accident cover (a payout for certain injuries)",
      note: "Personal accident cover – pays a set amount for certain injuries. Briefly note what types of injuries/events are covered.",
    },
    {
      pattern: /\bpublic liability\b/gi,
      suggestion: "public liability cover (injury or damage to others)",
      note: "Public liability – cover for injury or damage to other people or property. Phrase it that way for clarity.",
    },
    {
      pattern: /\bproduct liability\b/gi,
      suggestion: "product liability cover (if a product causes harm)",
      note: "Product liability – cover if a product you supply causes injury or damage. Explain it plainly.",
    },
    {
      pattern: /\bprofessional indemnity\b/gi,
      suggestion: "professional indemnity cover (for mistakes in your work)",
      note: "Professional indemnity – cover for mistakes in professional work that cause loss. Explain in simple terms.",
    },
    {
      pattern: /\bbusiness interruption\b/gi,
      suggestion: "business interruption cover (lost income if you can’t trade)",
      note: "Business interruption – cover for lost income if you cannot trade after an insured event. Say it in plain language.",
    },
    {
      pattern: /\bcooling[- ]off period\b/gi,
      suggestion: "the time you can cancel shortly after buying",
      note: "Cooling-off period – the short window when you can cancel after buying. State the number of days and any fees.",
    }
  ];


  function markJargonIssues(root) {
    if (!root) return;

    function walk(node) {
      if (node.nodeType === Node.TEXT_NODE) {
        const text = node.textContent || "";
        if (!/[A-Za-z]/.test(text)) return;

        let frag = document.createDocumentFragment();
        let indexOffset = 0;
        let changed = false;

        while (true) {
          let earliest = null;
          let earliestSpec = null;

          for (const spec of jargonPatterns) {
            spec.pattern.lastIndex = indexOffset;
            const m = spec.pattern.exec(text);
            if (m && (!earliest || m.index < earliest.index)) {
              earliest = m;
              earliestSpec = spec;
            }
          }

          if (!earliest) break;

          if (earliest.index > indexOffset) {
            frag.appendChild(document.createTextNode(text.slice(indexOffset, earliest.index)));
          }

          const matched = earliest[0];
          const span = document.createElement("span");
          span.className = "spell-issue";
          span.textContent = matched;
          span.title = "Industry term – consider plain language, e.g. \"" +
            earliestSpec.suggestion +
            "\".";
          frag.appendChild(span);

          indexOffset = earliest.index + matched.length;
          changed = true;
        }

        if (changed) {
          if (indexOffset < text.length) {
            frag.appendChild(document.createTextNode(text.slice(indexOffset)));
          }
          const parent = node.parentNode;
          if (parent) {
            parent.replaceChild(frag, node);
            parent.normalize();
          }
        }
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        if (
          node.classList &&
          (node.classList.contains("spell-issue") || node.classList.contains("uk-issue"))
        ) {
          return;
        }
        Array.from(node.childNodes).forEach(walk);
      }
    }

    walk(root);
  }

  // Very lightweight spelling anomaly highlighter.
  // This is NOT a full dictionary check – it just flags a few common
  // mistakes and suspicious patterns so the writer can double-check.
  const commonMisspellings = {
    "peopple": "people",
    "peeple": "people",
    "peepple": "people",
    "grayss": "grey",
    "recieve": "receive",
    "definately": "definitely",
    "seperate": "separate",
    "occured": "occurred",
    "enviroment": "environment",
    "wich": "which",
    "adress": "address",
    "loght": "light",
    "ubbles": "bubbles",
    "greay": "grey",
    "fefbruary": "February",
    "ffebruary": "February",
    "feburary": "February",
    "febuary": "February",
    "janury": "January",
    "januray": "January",
    "chagelog": "changelog",
    "cend": "send",
    "wth": "with",
    "teh": "the",
    "adn": "and",
    "coudl": "could",
    "shoudl": "should",
    "thier": "their",
    "beleive": "believe"

  };

  

  function markSpellingIssues(root) {
    if (!root) return;

    // Contractions missing apostrophes (very explicit list)
    const contractions = {
      "cant": "can't",
      "dont": "don't",
      "isnt": "isn't",
      "wont": "won't",
      "youre": "you're",
      "theyre": "they're",
      "im": "I'm",
      "ive": "I've",
      "id": "I'd",
      "ill": "I'll",
      "weve": "we've",
      "shouldnt": "shouldn't",
      "couldnt": "couldn't",
      "wouldnt": "wouldn't",
      "havent": "haven't",
      "hasnt": "hasn't",
      "hadnt": "hadn't"
    };

    // Proper nouns that should normally be capitalised.
    // Key: lowercase, Value: preferred casing.
    const properNouns = {
      // Months
      "january": "January",
      "february": "February",
      "march": "March",
      "april": "April",
      "may": "May",
      "june": "June",
      "july": "July",
      "august": "August",
      "september": "September",
      "october": "October",
      "november": "November",
      "december": "December",

      // Days of week
      "monday": "Monday",
      "tuesday": "Tuesday",
      "wednesday": "Wednesday",
      "thursday": "Thursday",
      "friday": "Friday",
      "saturday": "Saturday",
      "sunday": "Sunday",

      // Continents
      "africa": "Africa",
      "europe": "Europe",
      "asia": "Asia",
      "antarctica": "Antarctica",
      "australia": "Australia",
      "oceania": "Oceania",

      // Selected major countries (single-word for safety)
      "australia": "Australia",
      "brazil": "Brazil",
      "china": "China",
      "india": "India",
      "canada": "Canada",
      "germany": "Germany",
      "france": "France",
      "italy": "Italy",
      "spain": "Spain",
      "japan": "Japan",
      "nigeria": "Nigeria",
      "kenya": "Kenya",
      "egypt": "Egypt",
      "mexico": "Mexico",
      "argentina": "Argentina",
      "chile": "Chile",
      "ghana": "Ghana",
      "uganda": "Uganda",
      "rwanda": "Rwanda",
      "tanzania": "Tanzania",

      // Major global + key UK cities (lite set)
      "johannesburg": "Johannesburg",
      "durban": "Durban",
      "pretoria": "Pretoria",
      "bloemfontein": "Bloemfontein",
      "gqeberha": "Gqeberha",
      "port elizabeth": "Port Elizabeth",
      "cape town": "Cape Town",
      "east london": "East London",

      "london": "London",
      "manchester": "Manchester",
      "birmingham": "Birmingham",
      "leeds": "Leeds",
      "liverpool": "Liverpool",
      "sheffield": "Sheffield",

      "paris": "Paris",
      "madrid": "Madrid",
      "rome": "Rome",
      "berlin": "Berlin",
      "amsterdam": "Amsterdam",
      "lisbon": "Lisbon",

      "new york": "New York",
      "los angeles": "Los Angeles",
      "toronto": "Toronto",
      "vancouver": "Vancouver",

      "tokyo": "Tokyo",
      "seoul": "Seoul",
      "shanghai": "Shanghai",
      "singapore": "Singapore",
      "hong kong": "Hong Kong",
      "bangkok": "Bangkok",

      "dubai": "Dubai",
      "abu dhabi": "Abu Dhabi",

      "sao paulo": "São Paulo",
      "rio de janeiro": "Rio de Janeiro",
      "buenos aires": "Buenos Aires",
      "santiago": "Santiago",

      "sydney": "Sydney",
      "melbourne": "Melbourne",
      "brisbane": "Brisbane",
      "perth": "Perth",
      "auckland": "Auckland",
      "wellington": "Wellington",
      "cairo": "Cairo",
      "lagos": "Lagos",
      "nairobi": "Nairobi"
    };
    const commonWordList = [
        "the","be","to","of","and","a","in","that","have","i","it","for","not","on","with","he",
        "as","you","do","at","this","but","his","by","from","they","we","say","her","she","or",
        "an","will","my","one","all","would","there","their","what","so","up","out","if","about",
        "who","get","which","go","me","when","make","can","like","time","no","just","him","know",
        "take","people","into","year","your","good","some","could","them","see","other","than",
        "then","now","look","only","come","its","over","think","also","back","after","use","two",
        "how","our","work","first","well","way","even","new","want","because","any","these","give",
        "day","most","us","claim","support","help","thanks","thank","getting","touch","hello",
        "ultimate","analysis","requirements","spelling","errors","identified","provided","text",
        "contains","numerous","spelling","mistakes","typos","gibberish","sequences","below","list",
        "identified","errors","along","their","likely","intended","corrections","meanings"
      ];
      const commonWords = new Set(commonWordList);

      // Helper: simple adjacent-character swap (transposition) fixer
      function findTranspositionSuggestion(word) {
        for (let i = 0; i < word.length - 1; i++) {
          const arr = word.split("");
          const tmp = arr[i];
          arr[i] = arr[i+1];
          arr[i+1] = tmp;
          const cand = arr.join("");
          if (commonWords.has(cand.toLowerCase()) || commonMisspellings[cand.toLowerCase()]) {
            return cand;
          }
        }
        return null;
      }

      function isRepeatedPattern(word) {
        // detect short substring repeated many times: e.g. "sdasdasdasd"
        const lower = word.toLowerCase();
        for (let size = 2; size <= Math.floor(lower.length/2); size++) {
          const chunk = lower.slice(0,size);
          if (chunk.length<2) continue;
          let built = "";
          while (built.length < lower.length) built += chunk;
          if (built.slice(0, lower.length) === lower) return true;
        }
        return false;
      }

      function vowelRatio(word) {
        const vowels = (word.match(/[aeiouy]/gi) || []).length;
        return vowels / Math.max(1, word.length);
      }

      function isProbablyGibberish(original) {
        const word = original.replace(/[^a-zA-Z]/g,""); // letters only
        if (!word) return false;
        // too short to make a reliable judgement
        if (word.length <= 2) return false;

        const lower = word.toLowerCase();

        // All-identical-letter or long single-character repeats (aaaaaa)
        if (/^([a-zA-Z])\1{3,}$/.test(word)) return true;

        // very long words with trigram repetition
        if (word.length >= 12) {
          // if trigram repeated many times -> gibberish
          const trigrams = {};
          for (let i = 0; i <= lower.length - 3; i++) {
            const tri = lower.slice(i, i+3);
            trigrams[tri] = (trigrams[tri]||0)+1;
            if (trigrams[tri] >= 4) return true;
          }
        }

        // very low vowel ratio (likely random keyboard mash)
        if (word.length >= 4 && vowelRatio(word) < 0.25) return true;

        // repeated pattern detection (sdasdasd)
        if (word.length >= 6 && isRepeatedPattern(word)) return true;

        // many consonants that are uncommon together
        if (/[jqxzv].*[jqxzv]/i.test(word) && word.length >= 4) return true;

        return false;
      }

  



    function walk(node) {
      if (node.nodeType === Node.TEXT_NODE) {
        const text = node.textContent || "";
        if (!/[A-Za-z]/.test(text)) return;

        const wordRegex = /[A-Za-z']+/g;
        let match;
        const frag = document.createDocumentFragment();
        let lastIndex = 0;
        let hasIssue = false;

        // Collect simple word list with positions to help phrase checks
        const tokens = [];
        while ((match = wordRegex.exec(text)) !== null) {
          tokens.push({
            word: match[0],
            index: match.index
          });
        }

        if (!tokens.length) return;

        // Helper to check if position is start of a phrase proper noun
        function getPhraseSuggestion(startIdx) {
          // Try 2-word and 3-word phrases (e.g. "south africa", "new york")
          for (let len = 3; len >= 2; len--) {
            if (startIdx + len > tokens.length) continue;
            const slice = tokens.slice(startIdx, startIdx + len);
            const phraseRaw = slice.map(t => t.word).join(" ");
            const phraseLower = phraseRaw.toLowerCase();
            const suggestion = properNouns[phraseLower];
            if (suggestion) {
              const allCorrect = phraseRaw === suggestion;
              return { phrase: phraseRaw, suggestion, allCorrect };
            }
          }
          return null;
        }

        let i = 0;
        while (i < tokens.length) {
          const token = tokens[i];
          const original = token.word;
          const lower = original.toLowerCase();
          const index = token.index;

          if (index > lastIndex) {
            frag.appendChild(document.createTextNode(text.slice(lastIndex, index)));
          }

          let isIssue = false;
          let suggestion = "";

          // Pre-calc some stats used by multiple heuristics
          const len = original.length;
          const vowelMatches = original.match(/[aeiouy]/gi) || [];
          const vowelCount = vowelMatches.length;

          // 1) Standalone lowercase "i" (pronoun)
          if (original === "i") {
            isIssue = true;
            suggestion = "I";
          }
          // 2) Contractions missing apostrophes
          else if (contractions[lower] && !original.includes("'")) {
            isIssue = true;
            suggestion = contractions[lower];
          }
          // 3) Phrase-level proper nouns (e.g. "new york", "cape town")
          else {
            const phraseInfo = getPhraseSuggestion(i);
            if (phraseInfo && !phraseInfo.allCorrect) {
              isIssue = true;
              suggestion = phraseInfo.suggestion;
              const span = document.createElement("span");
              span.className = "spell-issue";
              span.textContent = phraseInfo.phrase;

              if (suggestion) {
                span.title = "Capitalisation: " + suggestion;
                span.dataset.suggestion = suggestion;
              } else {
                span.title = "Check capitalisation.";
              }

              frag.appendChild(span);
              lastIndex = index + phraseInfo.phrase.length;
              hasIssue = true;
              i += phraseInfo.phrase.split(" ").length;
              continue;
            }
            // 4) Single-word proper nouns (months, days, continents, countries, cities)
            else if (properNouns[lower]) {
              const expected = properNouns[lower];
              if (original !== expected) {
                isIssue = true;
                suggestion = expected;
              }
            }
          }


          // 5) Month-name near-miss: double first letter, e.g. "ffebruary"
          if (!isIssue) {
            const monthBases = ["january","february","march","april","may","june","july","august","september","october","november","december"];
            for (let m = 0; m < monthBases.length && !isIssue; m++) {
              const base = monthBases[m];
              if (lower.length === base.length + 1 && lower.slice(1) === base) {
                const expected = base.charAt(0).toUpperCase() + base.slice(1);
                if (original !== expected) {
                  isIssue = true;
                  suggestion = expected;
                }
              }
            }
          }

          // 6) Common misspellings
          if (!isIssue && commonMisspellings[lower]) {
            isIssue = true;
            suggestion = commonMisspellings[lower];
          }

          // 6) Triple-letter sequences like "soooo"
          if (!isIssue && /([a-z])\1{2,}/i.test(original)) {
            isIssue = true;
          }

          // 7) Gibberish / keyboard-mash detection (careful not to hit normal words)
          if (!isIssue) {
            // 7a) No vowels at all and length >= 4 (e.g. "ssdf", "brrrk")
            if (len >= 4 && vowelCount === 0) {
              isIssue = true;
            }
            // 7c) Very long words made of repeating 3-letter chunks (e.g. "ssdasdasdasdashdasd")
            else if (len >= 12) {
              const trigrams = [];
              for (let t = 0; t <= original.length - 3; t++) {
                trigrams.push(original.slice(t, t + 3).toLowerCase());
              }
              const counts = {};
              for (const tri of trigrams) {
                counts[tri] = (counts[tri] || 0) + 1;
              }
              for (const tri in counts) {
                if (counts[tri] >= 3) {
                  isIssue = true;
                  break;
                }
              }
            }
            // 7d) Short words with almost no vowels but double "weird" consonants (e.g. "asdjv")
            else if (
              len >= 4 &&
              len <= 7 &&
              vowelCount <= 1 &&
              /[jqxzv].*[jqxzv]/i.test(original)
            ) {
              isIssue = true;
            }
          }


          // 8) Dictionary-style / gibberish heuristic for longer words
          if (!isIssue) {
            const cleaned = original.replace(/[^a-zA-Z]/g, "");
            if (cleaned.length >= 5) {
              const cleanedLower = cleaned.toLowerCase();
              // Skip if it's in our common safe-word whitelist
              if (!commonWords.has(cleanedLower)) {
                // Try a simple adjacent-letter swap suggestion first
                const transposed = findTranspositionSuggestion(cleanedLower);
                if (transposed && transposed.toLowerCase() !== cleanedLower) {
                  isIssue = true;
                  suggestion = transposed;
                } else if (isProbablyGibberish(cleaned)) {
                  // If it looks like a keyboard mash, flag without a specific suggestion
                  isIssue = true;
                }
              }
            }
          }

          if (isIssue) {
            hasIssue = true;
            const span = document.createElement("span");
            span.className = "spell-issue";
            span.textContent = original;

            if (suggestion) {
              span.title = "Possible spelling: " + suggestion;
              span.dataset.suggestion = suggestion;
            } else {
              span.title = "Possible spelling issue – please double-check.";
            }

            frag.appendChild(span);
          } else {
            frag.appendChild(document.createTextNode(original));
          }

          lastIndex = index + original.length;
          i += 1;
        }

        if (!hasIssue) return;

        if (lastIndex < text.length) {
          frag.appendChild(document.createTextNode(text.slice(lastIndex)));
        }

        const parent = node.parentNode;
        if (parent) {
          parent.replaceChild(frag, node);
          parent.normalize();
        }
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        if (
          node.classList &&
          (node.classList.contains("spell-issue") ||
            node.classList.contains("uk-issue"))
        ) {
          return;
        }
        Array.from(node.childNodes).forEach(walk);
      }
    }

    walk(root);
  }
// --- Formatting toolbar (777-style behaviour) ---

  
  // --- Highlight palette & selection helpers ---
  let highlightPalette = null;
  let highlightPaletteOpenFor = null;
  let lastEditorSelection = null;

  function getActiveEditor() {
    if (isNotepadLayout() && npEditor) {
      return npEditor;
    }
    return agentInput;
  }

  function syncEditorState(targetEditor) {
    if (!targetEditor) return;
    if (targetEditor === agentInput) {
      if (typeof renderAgent === "function") {
        renderAgent();
      }
      if (typeof pushAgentHistory === "function") {
        pushAgentHistory();
      }
    } else if (targetEditor === npEditor) {
      updateNotepadStats();
    }
  }

  function saveEditorSelection() {
    const sel = window.getSelection();
    const editor = getActiveEditor();
    if (!sel || !editor || sel.rangeCount === 0) return;
    const range = sel.getRangeAt(0);
    if (!editor.contains(range.commonAncestorContainer)) return;
    lastEditorSelection = range;
  }

  function restoreEditorSelection() {
    if (!lastEditorSelection) return;
    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(lastEditorSelection);
  }

  function ensureHighlightPalette(toolbarLeft) {
    if (highlightPalette) return highlightPalette;
    highlightPalette = document.createElement("div");
    highlightPalette.className = "highlight-palette";
    highlightPalette.innerHTML = `
      <button type="button" class="highlight-swatch" data-hl="#facc15" title="Warm yellow" style="background:#facc15;"></button>
      <button type="button" class="highlight-swatch" data-hl="#fed7aa" title="Soft peach" style="background:#fed7aa;"></button>
      <button type="button" class="highlight-swatch" data-hl="#bbf7d0" title="Mint" style="background:#bbf7d0;"></button>
      <button type="button" class="highlight-swatch" data-hl="#bfdbfe" title="Sky" style="background:#bfdbfe;"></button>
      <button type="button" class="highlight-swatch" data-hl="#e9d5ff" title="Lilac" style="background:#e9d5ff;"></button>
      <button type="button" class="highlight-swatch clear-swatch" data-hl="clear" title="Clear highlight">Clear</button>
    `;
    document.body.appendChild(highlightPalette);

    // Clicking a swatch applies that colour to the saved selection
    highlightPalette.addEventListener("click", (evt) => {
      const btn = evt.target.closest(".highlight-swatch");
      if (!btn) return;
      const value = btn.getAttribute("data-hl");
      const editor = getActiveEditor();
      if (!editor) return;
      editor.focus();
      restoreEditorSelection();
      const useHilite = document.queryCommandSupported && document.queryCommandSupported("hiliteColor");
      const command = useHilite ? "hiliteColor" : "backColor";
      if (value === "clear") {
        try {
          if (useHilite) {
            document.execCommand("hiliteColor", false, "transparent");
          } else {
            document.execCommand("backColor", false, "transparent");
          }
        } catch (e) {}
      } else {
        try {
          document.execCommand(command, false, value);
        } catch (e) {}
      }
      hideHighlightPalette();
      syncEditorState(editor);
    });

    // Clicking anywhere else closes the palette
    document.addEventListener("click", (evt) => {
      if (!highlightPalette) return;
      if (evt.target.closest(".highlight-palette")) return;
      if (evt.target.closest('button[data-action="highlight"]')) return;
      hideHighlightPalette();
    });

    return highlightPalette;
  }

  function showHighlightPalette(anchorBtn, toolbarLeft) {
    if (!anchorBtn) return;
    const palette = ensureHighlightPalette(toolbarLeft);
    saveEditorSelection();
    const rect = anchorBtn.getBoundingClientRect();
    palette.style.top = `${rect.bottom + window.scrollY + 6}px`;
    palette.style.left = `${rect.left + window.scrollX + (rect.width / 2) - 85}px`;
    palette.classList.add("visible");
    highlightPaletteOpenFor = anchorBtn;
  }

  function hideHighlightPalette() {
    if (highlightPalette) {
      highlightPalette.classList.remove("visible");
    }
    highlightPaletteOpenFor = null;
  }
function applyFormat(action) {
    const targetEditor = getActiveEditor();
    if (!targetEditor) return;
    const usingMessenger = targetEditor === agentInput;
    targetEditor.focus();

    const exec = (command, value = null) => {
      try {
        document.execCommand(command, false, value);
      } catch (e) {}
    };

    if (action === "bold") {
      exec("bold");
    } else if (action === "italic") {
      exec("italic");
    } else if (action === "bullets") {
      exec("insertUnorderedList");
    } else if (action === "numbered") {
      exec("insertOrderedList");
    } else if (action === "undo") {
      if (usingMessenger) {
        undoAgentHistory();
        renderAgent();
      } else {
        exec("undo");
        updateNotepadStats();
      }
      return;
    } else if (action === "redo") {
      if (usingMessenger) {
        redoAgentHistory();
        renderAgent();
      } else {
        exec("redo");
        updateNotepadStats();
      }
      return;
    } else if (action === "clean") {
      if (usingMessenger) {
        runCleanPipeline();
      } else {
        cleanNotepadContent();
      }
      return;
    } else if (action === "h1") {
      exec("formatBlock", "h1");
    } else if (action === "h2") {
      exec("formatBlock", "h2");
    } else if (action === "highlight") {
      if (!toolbarLeft) {
        const useHilite = document.queryCommandSupported && document.queryCommandSupported("hiliteColor");
        const command = useHilite ? "hiliteColor" : "backColor";
        let highlightColour = "#facc15";
        try {
          const styles = window.getComputedStyle(document.body);
          const cssColour = styles.getPropertyValue("--highlight-colour");
          if (cssColour) {
            highlightColour = cssColour.trim();
          }
        } catch (e) {}
        exec(command, highlightColour);
        syncEditorState(targetEditor);
      } else {
        const hlBtn = toolbarLeft.querySelector('button[data-action="highlight"]');
        showHighlightPalette(hlBtn, toolbarLeft);
      }
      return;
    } else if (action === "clearhighlight") {
      const command = (document.queryCommandSupported && document.queryCommandSupported("hiliteColor")) ? "hiliteColor" : "backColor";
      exec(command, "transparent");
    } else if (action === "align-left") {
      exec("justifyLeft");
    } else if (action === "align-center") {
      exec("justifyCenter");
    } else if (action === "align-right") {
      exec("justifyRight");
    } else if (action === "indent") {
      exec("indent");
    } else if (action === "outdent") {
      exec("outdent");
    } else if (action === "sup") {
      exec("superscript");
    } else if (action === "sub") {
      exec("subscript");
    } else if (action === "strike") {
      exec("strikeThrough");
    } else if (action === "quote") {
      try {
        exec("formatBlock", "blockquote");
      } catch (e) {
        exec("insertText", "\n> ");
      }
    } else if (action === "clearformat") {
      exec("removeFormat");
      exec("unlink");
      try {
        exec("formatBlock", "p");
      } catch (e) {}
    } else if (action === "hr") {
      exec("insertHorizontalRule");
    } else if (action === "np-paste") {
      pasteIntoNotepadFromClipboard();
      return;
    } else if (action === "np-copy") {
      copyNotepadToClipboard();
      return;
    } else if (action === "np-clear") {
      clearNotepadEditor();
      return;
    } else {
      return;
    }

    if (action !== "highlight") {
      syncEditorState(targetEditor);
    }
  }

  if (toolbarLeft) {
    toolbarLeft.addEventListener("click", (event) => {
      const btn = event.target.closest("button[data-action]");
      if (!btn) return;
      const action = btn.getAttribute("data-action");
      if (!action) return;
      applyFormat(action);

      // Update active state for toggle-style formatting buttons
      const toggleActions = ["bold","italic","bullets","numbered","highlight","align-left","align-center","align-right","strike","sup","sub"];
      if (toggleActions.includes(action)) {
        if (action.startsWith("align-")) {
          const alignButtons = toolbarLeft.querySelectorAll('button[data-action^="align-"]');
          alignButtons.forEach(b => b.classList.remove("active"));
          btn.classList.add("active");
        } else {
          btn.classList.toggle("active");
        }
      }
    });
  }

  
  
  // --- Spell/UK issue tooltip helpers ---
  let activeIssueTooltip = null;

  function hideIssueTooltip() {
    if (!activeIssueTooltip) return;
    const { element } = activeIssueTooltip;
    if (element && element.parentNode) {
      element.parentNode.removeChild(element);
    }
    activeIssueTooltip = null;
  }

  function applySuggestionToIssue(span) {
    if (!span) return;
    const suggestion = (span.dataset && span.dataset.suggestion) ? span.dataset.suggestion.trim() : "";

    if (!suggestion) return;

    span.textContent = suggestion;
    span.removeAttribute("data-suggestion");
    span.removeAttribute("title");
    span.classList.remove("spell-issue", "uk-issue");

    renderAgent();
    updateIssueCounters();
    pushAgentHistory();
  }

  function ignoreIssueSpan(span) {
    if (!span) return;

    // Work out the underlying word/phrase we are ignoring
    const raw =
      (span.dataset && (span.dataset.word || span.dataset.wordLower))
        ? (span.dataset.word || span.dataset.wordLower)
        : (span.textContent || "");
    const lower = (raw || "").trim().toLowerCase();
    if (!lower) return;

    // Remember this word for the rest of the session so future passes
    // don't re‑flag it.
    ignoredWords.add(lower);

    // Sweep *all* existing highlights for this word in the agent editor
    // (both UK and jargon/spell issues), not just the one we clicked.
    const root = agentInput || document.getElementById("agentInput") || document;
    const spans = Array.from(
      root.querySelectorAll("span.uk-issue, span.spell-issue")
    ).filter((el) => {
      const rawEl =
        (el.dataset && (el.dataset.word || el.dataset.wordLower))
          ? (el.dataset.word || el.dataset.wordLower)
          : (el.textContent || "");
      return (rawEl || "").trim().toLowerCase() === lower;
    });

    if (spans.length === 0) {
      return;
    }

    spans.forEach((el) => {
      const text = el.textContent || "";
      const parent = el.parentNode;
      if (!parent) return;
      const textNode = document.createTextNode(text);
      parent.replaceChild(textNode, el);
      parent.normalize();
    });

    renderAgent();
    updateIssueCounters();
    pushAgentHistory();
  }

  function showIssueTooltip(span) {
    if (!span) return;

    hideIssueTooltip(); // close any previous one

    const suggestion =
      (span.dataset && span.dataset.suggestion)
        ? span.dataset.suggestion.trim()
        : "";

    const note =
      (span.dataset && span.dataset.note)
        ? span.dataset.note.trim()
        : "";

    const tooltip = document.createElement("div");
    tooltip.className = "issue-tooltip";

    tooltip.innerHTML = `
    <div class="issue-tooltip-main">
      ${
        suggestion
          ? `Suggestion: <strong>${suggestion}</strong>`
          : `Check this word manually`
      }
      ${
        note
          ? `<div class="issue-tooltip-note">${note}</div>`
          : ""
      }
    </div>
    <div class="issue-tooltip-actions">
      ${
        suggestion
          ? `<button type="button" data-action="apply">Apply</button>`
          : ""
      }
      <button type="button" data-action="ignore">Ignore all</button>
    </div>
  `;

    // Position near the word
    const rect = span.getBoundingClientRect();
    tooltip.style.position = "fixed";
    tooltip.style.top = (rect.bottom + 4) + "px";
    tooltip.style.left = rect.left + "px";

    // Handle button clicks
    tooltip.addEventListener("click", (event) => {
      event.stopPropagation();
      const btn = event.target.closest("button[data-action]");
      if (!btn) return;
      const action = btn.dataset.action;

      if (action === "apply") {
        applySuggestionToIssue(span);
      } else if (action === "ignore") {
        ignoreIssueSpan(span);
      }
      hideIssueTooltip();
    });

    document.body.appendChild(tooltip);
    activeIssueTooltip = { element: tooltip, target: span };
  }
  // Close tooltip when clicking anywhere else
  document.addEventListener("click", (event) => {
    if (!activeIssueTooltip) return;
    const { element, target } = activeIssueTooltip;

    if (!element) {
      activeIssueTooltip = null;
      return;
    }

    const clickedInsideTooltip = element.contains(event.target);
    const clickedTargetWord = (event.target === target);

    if (!clickedInsideTooltip && !clickedTargetWord) {
      hideIssueTooltip();
    }
  });

// Keyboard shortcuts + smart paste on the agent box

  if (agentInput) {
    // Let the browser handle paste normally, then clean up any meta / Word stuff
    // once the content has actually been inserted, and store in history.
    agentInput.addEventListener("paste", () => {
      setTimeout(async () => {
        agentInput.innerHTML = cleanHtml(agentInput.innerHTML || "");
        agentInput.scrollTop = 0;
        await runCleanPipeline();
      }, 0);
    });

    // Formatting + undo/redo shortcuts
    agentInput.addEventListener("keydown", (event) => {
      if (!event.ctrlKey && !event.metaKey) return;
      const key = event.key.toLowerCase();

      if (key === "b") {
        event.preventDefault();
        applyFormat("bold");
      } else if (key === "i") {
        event.preventDefault();
        applyFormat("italic");
      } else if (key === "l") {
        event.preventDefault();
        applyFormat("bullets");
      } else if (key === "z") {
        event.preventDefault();
        if (event.shiftKey) {
          redoAgentHistory();
        } else {
          undoAgentHistory();
        }
      } else if (key === "y") {
        event.preventDefault();
        redoAgentHistory();
      }
    });

    // [MF:PHASE-F][OWNER:INPUT_AGENT] PRIMARY WIRING LOCATION
    // INPUT: LIGHT updates + 160ms trailing heavy recompute (no duplicate listeners)
    agentInput.addEventListener("input", () => {
      // LIGHT: typing indicator UI + preview rendering
      cfUpdateTyping("agent");
      if (typeof cfRefreshPeek === "function" && cfPeek && cfPeek.active && cfPeek.role === "agent") cfRefreshPeek();
      renderAgent(); // LIGHT render (no heavy analysis)
      pushAgentHistory(); // History stack (no heavy analysis)
      // Guard: skip heavy scheduling during IME composition
      if (window.__mf_isComposing === true) return;
      // [MF:PHASE-F][OWNER:INPUT_AGENT] Schedule heavy recompute (160ms trailing debounce)
      if (typeof scheduleRecompute === "function") {
        scheduleRecompute("agent:input");
      }
    });

    // [MF:PHASE-F][OWNER:INPUT_AGENT] Composition guards
    agentInput.addEventListener("compositionstart", () => { window.__mf_isComposing = true; });
    agentInput.addEventListener("compositionend", () => {
      window.__mf_isComposing = false;
      if (typeof scheduleRecompute === "function") scheduleRecompute("agent:compositionend");
    });

    // Click on a highlighted word:
    //  - show tooltip with Apply / Ignore (if applicable)
    agentInput.addEventListener("click", (event) => {
      const target = event.target;
      if (!target || !target.classList) return;

      if (target.classList.contains("spell-issue") || target.classList.contains("uk-issue")) {
        event.stopPropagation();
        showIssueTooltip(target);
      }
    });
  }

  // [MF:PHASE-F] Customer input: consolidated at line ~14064 (ChatFlow UI + Phase F scheduler)
  // Composition guards wired separately below
  if (customerInput) {
    // [MF:PHASE-F] IME composition guard
    customerInput.addEventListener("compositionstart", () => { window.__mf_isComposing = true; });
    customerInput.addEventListener("compositionend", () => {
      window.__mf_isComposing = false;
      if (typeof scheduleRecompute === "function") scheduleRecompute("customer:compositionend");
    });
    // renderCustomer() already called in line ~14064 input listener (consolidated)
  }

  // Phase 19.14A: Messenger helper functions for cross-surface sync
  function getMessengerCustomerText() {
    return customerInput ? (customerInput.value || "") : "";
  }

  function setMessengerCustomerText(text) {
    if (!customerInput) return;
    customerInput.value = text || "";
    renderCustomer();
    if (typeof scheduleRecompute === "function") scheduleRecompute("set:customer");
  }

  function getMessengerAgentTextPlain() {
    if (!agentInput) return "";
    const html = agentInput.innerHTML || "";
    return (typeof getPlainTextFromHtml === "function") ? getPlainTextFromHtml(html) : html;
  }

  function setMessengerAgentText(text) {
    if (!agentInput) return;
    // Convert plain text to HTML paragraphs
    const html = (typeof textToHtml === "function") ? textToHtml(text || "") : `<p>${(text || "").replace(/\\n/g, "<br>")}</p>`;
    agentInput.innerHTML = html;
    renderAgent();
    pushAgentHistory();
    if (typeof scheduleRecompute === "function") scheduleRecompute("set:agent");
  }

  // Phase 19.20 polish: Clear button - fully reset conversation context and MFCX state
  if (clearBtn) {
    clearBtn.addEventListener("click", () => {
      // Clear all inputs universally
      if (agentInput) agentInput.innerHTML = "";
      if (customerInput) customerInput.value = "";
      if (mlcxNotesInput) mlcxNotesInput.value = "";
      
      // Clear internal history and counters
      agentHistory = [];
      agentHistoryIndex = -1;

      // Also clear the per-session ignore cache for spell/UK issues
      ignoredWords.clear();

      // Phase 19.20: Reset MLCX/MFCX state to empty baseline
      if (typeof window.mlcxState !== "undefined") {
        window.mlcxState = {
          categories: { 
            emotion: { count: 0, chips: [], snippets: [] }, 
            clarity: { count: 0, chips: [], snippets: [] }, 
            cxRisk: { count: 0, chips: [], snippets: [] }, 
            safety: { count: 0, chips: [], snippets: [] } 
          },
          severityBand: "low",
          sourceText: { customer: "", agent: "", agentNotes: "" },
          vulnerability: { hasFlag: false, severity: "none", categories: [], phrases: [], notes: "" },
          allChips: [],
          highRiskSnippets: []
        };
      }

      // Refresh all UI surfaces
      hideIssueTooltip();
      hideContextMenu();
      renderAgent();
      renderCustomer();

      if (isMessengerLayout()) {
        // [MF:P-F] Route clear button Insights through scheduler
        if (typeof scheduleRecompute === "function") scheduleRecompute("clear:messenger");
      }
      
      // Phase 19.20: Trigger full MFCX state recompute via Phase F scheduler
      if (typeof runRecomputeNow === "function") {
        runRecomputeNow("clear:button");

      }
      
      // Phase 19.20: Explicitly refresh all MFCX surfaces
      if (typeof refreshAllMlcxSurfaces === "function") {
        setTimeout(refreshAllMlcxSurfaces, 50);
      }
      
      showToast("Cleared all content", "info");
    });
  }


  // Helper to insert HTML at the current caret position inside the agent editor
  function insertHtmlAtCursor(htmlToInsert) {
    if (!agentInput) return;
    agentInput.focus();

    const sel = window.getSelection();
    if (!sel) return;
    let range = sel.rangeCount ? sel.getRangeAt(0) : null;

    // If the current selection is outside the agent editor, move caret to end
    if (!range || !agentInput.contains(range.commonAncestorContainer)) {
      range = document.createRange();
      range.selectNodeContents(agentInput);
      range.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range);
    }

    // Clean the incoming HTML so we keep only safe tags + basic colours
    const cleanedHtml = cleanHtml(htmlToInsert || "");
    const temp = document.createElement("div");
    temp.innerHTML = cleanedHtml;

    const frag = document.createDocumentFragment();
    let lastNode = null;
    while (temp.firstChild) {
      lastNode = temp.firstChild;
      frag.appendChild(lastNode);
    }

    range.deleteContents();
    range.insertNode(frag);

    // Move caret to just after the inserted content
    if (lastNode) {
      range.setStartAfter(lastNode);
      range.setEndAfter(lastNode);
      sel.removeAllRanges();
      sel.addRange(range);
    }

    renderAgent();
    pushAgentHistory();
  }

  // Paste button – focuses the reply box and makes a best-effort paste attempt

  
  
  
  // Paste button – focuses the reply box and gives a gentle Ctrl+V hint
  if (pasteBtn) {
    let pasteHintTimeout;
    pasteBtn.addEventListener("click", async () => {
      if (!agentInput) return;

      // Put the caret in the reply editor so Ctrl+V works immediately
      agentInput.focus();

      let didPaste = false;

      // 1) Try full rich HTML via the async Clipboard API (preserves bold/italics/bullets)
      if (navigator.clipboard && navigator.clipboard.read) {
        try {
          const items = await navigator.clipboard.read();

          // Prefer text/html if available
          for (const item of items) {
            if (item.types && item.types.includes("text/html")) {
              const blob = await item.getType("text/html");
              const htmlClip = await blob.text();
              insertHtmlAtCursor(htmlClip);
              didPaste = true;
              break;
            }
          }

          // If no HTML flavour, fall back to text/plain
          if (!didPaste) {
            for (const item of items) {
              if (item.types && item.types.includes("text/plain")) {
                const blob = await item.getType("text/plain");
                const textClip = await blob.text();
                insertHtmlAtCursor(textToHtml(textClip));
                didPaste = true;
                break;
              }
            }
          }

          if (didPaste) {
            agentInput.innerHTML = cleanHtml(agentInput.innerHTML || "");
            await runCleanPipeline();
          }
        } catch (err) {
          // Fall through to the simpler text-only path / legacy path below
        }
      }

      // 2) Fallback: text-only clipboard
      if (!didPaste && navigator.clipboard && navigator.clipboard.readText) {
        try {
          const textClip = await navigator.clipboard.readText();
          if (textClip && textClip.length) {
            insertHtmlAtCursor(textToHtml(textClip));
            agentInput.innerHTML = cleanHtml(agentInput.innerHTML || "");
            await runCleanPipeline();
            didPaste = true;
          }
        } catch (err) {
          // ignore and fall through
        }
      }

      // 3) Legacy fallback: try execCommand, then re-clean the editor
      if (!didPaste) {
        try {
          const ok = document.execCommand("paste");
          if (ok) {
            didPaste = true;
            setTimeout(async () => {
              agentInput.innerHTML = cleanHtml(agentInput.innerHTML || "");
              await runCleanPipeline();
            }, 0);
          }
        } catch (err) {
          // Ignore – focus is enough for manual Ctrl+V
        }
      }

      // Always show a small tip so agents know they can also paste manually
      pasteBtn.classList.add("hint-active");
      if (pasteHintTimeout) {
        clearTimeout(pasteHintTimeout);
      }
      pasteHintTimeout = setTimeout(() => {
        pasteBtn.classList.remove("hint-active");
      }, 2200);
    });
  }

// Copy button - copies rich HTML where supported, with a plain-text fallback
  if (copyBtn) {
    copyBtn.addEventListener("click", async () => {
      if (!agentInput) return;

      // Clone and strip helper highlight spans so customers never see them.
      const clone = agentInput.cloneNode(true);
      clone.querySelectorAll("span.uk-issue, span.spell-issue").forEach((span) => {
        const text = span.textContent || "";
        const parent = span.parentNode;
        if (!parent) return;
        const textNode = document.createTextNode(text);
        parent.replaceChild(textNode, span);
        parent.normalize();
      });

      const html = clone.innerHTML || "";
      const plain = getPlainTextFromHtml(html);

      // 1) Preferred path: use the modern Clipboard API with HTML + plain text
      try {
        if (navigator.clipboard && window.ClipboardItem) {
          const data = new ClipboardItem({
            "text/html": new Blob([html], { type: "text/html" }),
            "text/plain": new Blob([plain], { type: "text/plain" }),
          });
          await navigator.clipboard.write([data]);
          showToast("Copied to clipboard!", "success");
          return;
        }
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(plain);
          showToast("Copied to clipboard!", "success");
          return;
        }
      } catch (err) {
        console.warn("Rich clipboard copy failed, falling back to textarea:", err);
      }

      // 2) Fallback: plain text via a temporary textarea
      try {
        const temp = document.createElement("textarea");
        temp.value = plain;
        document.body.appendChild(temp);
        temp.select();
        document.execCommand("copy");
        document.body.removeChild(temp);
        showToast("Copied to clipboard!", "success");
      } catch (err) {
        console.warn("execCommand copy failed:", err);
      }
    });

    // Ensure manual Ctrl+C from the editor uses the same formatting rules
    if (agentInput) {
      agentInput.addEventListener("copy", (e) => {
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0) return;

        const range = selection.getRangeAt(0);
        if (!agentInput.contains(range.commonAncestorContainer)) {
          return;
        }

        const frag = range.cloneContents();
        const wrapper = document.createElement("div");
        wrapper.appendChild(frag);

        wrapper.querySelectorAll("span.uk-issue, span.spell-issue").forEach((span) => {
          const text = span.textContent || "";
          const parent = span.parentNode;
          if (!parent) return;
          const textNode = document.createTextNode(text);
          parent.replaceChild(textNode, span);
          parent.normalize();
        });

        const html = wrapper.innerHTML || "";
        const plain = getPlainTextFromHtml(html);

        if (e.clipboardData) {
          e.clipboardData.setData("text/html", html);
          e.clipboardData.setData("text/plain", plain);
          e.preventDefault();
        }
      });
    }
  }


// Colourway pills
  function applyColour(colour) {
    if (!colour) return;
    colourButtons.forEach((b) => {
      b.classList.remove("active");
      b.setAttribute("aria-checked", "false");
    });
    // Activate all matching colour pills across toolbars
    let firstMatch = null;
    colourButtons.forEach((b) => {
      if (b.getAttribute("data-colour") === colour) {
        if (!firstMatch) firstMatch = b;
        b.classList.add("active");
        b.setAttribute("aria-checked", "true");
      }
    });

    if (colourwayLabelEl) {
      const labelSource = firstMatch ? (firstMatch.getAttribute("data-label") || "") : "";
      if (labelSource) {
        colourwayLabelEl.textContent = labelSource.toUpperCase();
      }
    }
    document.body.setAttribute("data-colour", colour);
    syncBubbleAddButtonColours();
    // Regenerate the low‑poly mesh so that each colourway has a unique
    // pattern.  Without this call the pattern remains static across
    // colour changes.
    if (typeof randomizeLowpolyPattern === "function") {
      randomizeLowpolyPattern();
    }
    // sync compact select if present
    if (colourSelect) colourSelect.value = colour;
  }

  colourButtons.forEach((btn) => {
    btn.addEventListener("click", () => {
      const colour = btn.getAttribute("data-colour");
      applyColour(colour);
    });
  });


  // Initialise colourway label on load
  if (colourwayLabelEl) {
    const activePill = document.querySelector('.pill-button.active') ||
      document.querySelector('.pill-button[data-colour="' + (document.body.getAttribute("data-colour") || "") + '"]');
    if (activePill) {
      const labelSource = activePill.getAttribute("data-label") || "";
      if (labelSource) {
        colourwayLabelEl.textContent = labelSource.toUpperCase();
      }
    }
  }

  // Compact select for small screens
  if (colourSelect) {
    colourSelect.addEventListener("change", (e) => {
      applyColour(e.target.value);
    });
  }
  function spinDiceOnce(btn) {
    if (!btn) return;
    btn.classList.remove("is-spinning");
    // force reflow so the animation can restart cleanly
    void btn.offsetWidth;
    btn.classList.add("is-spinning");
    setTimeout(() => {
      btn.classList.remove("is-spinning");
    }, 220);
  }
  // Visual cue: pulse-glow the active colourway pill + active theme button
  // so the user’s eye gets pulled to the combo controls (runs after shuffle + on initial auto-shuffle).
  function pulseActiveControls() {
    const activeThemeBtns = document.querySelectorAll('.theme-toggle button.active');
    const activeColourBtns = document.querySelectorAll('.pill-button[data-colour].active');

    const targets = [...activeThemeBtns, ...activeColourBtns];
    targets.forEach((el) => {
      if (!el) return;
      el.classList.remove('mf-pulse-glow');
      // force reflow so the animation restarts cleanly
      void el.offsetWidth;
      el.classList.add('mf-pulse-glow');
    });

    // cleanup after animation completes
    setTimeout(() => {
      targets.forEach((el) => el && el.classList.remove('mf-pulse-glow'));
    }, 900);
  }


  if (compactShuffleBtn) {
    compactShuffleBtn.addEventListener("click", () => {
      spinDiceOnce(compactShuffleBtn);
      rollThemeAndColour();
    });
  }

  if (mlcxShuffleBtn) {
    mlcxShuffleBtn.addEventListener("click", () => {
      spinDiceOnce(mlcxShuffleBtn);
      rollThemeAndColour();
    });
  }

  if (callnotesShuffleBtn) {
    callnotesShuffleBtn.addEventListener("click", () => {
      spinDiceOnce(callnotesShuffleBtn);
      rollThemeAndColour();
    });
  }

  // Theme (dark / light) toggle
  function applyTheme(theme) {
    if (!theme) return;

    themeButtons.forEach((b) => {
      b.classList.remove("active");
      b.setAttribute("aria-pressed", "false");
    });
    // Activate all buttons with this theme across toolbars
    themeButtons.forEach((b) => {
      if (b.getAttribute("data-theme") === theme) {
        b.classList.add("active");
        b.setAttribute("aria-pressed", "true");
      }
    });

    // Track theme mode + classes for light / lunar / dark
    themeMode = theme;
    document.body.setAttribute("data-theme", theme);
    document.body.classList.remove("light-mode", "dark-mode", "lunar-mode");
    if (theme === "light") {
      document.body.classList.add("light-mode");
    } else if (theme === "dark") {
      document.body.classList.add("dark-mode");
    } else if (theme === "lunar") {
      document.body.classList.add("lunar-mode");
    }

    restoreLowpolyPattern();
  }

  themeButtons.forEach((btn) => {  btn.addEventListener("click", () => {
      const theme = btn.getAttribute("data-theme");
      applyTheme(theme);
    });
  });

    
  // Unified dice behaviour – shuffle colourway, theme and background
  function rollThemeAndColour() {
    const themeOptions = Array.from(themeButtons || [])
      .map((b) => b.getAttribute("data-theme"))
      .filter((v) => !!v);
    const colourOptions = Array.from(colourButtons || [])
      .map((b) => b.getAttribute("data-colour"))
      .filter((v) => !!v);

    const currentTheme = document.body.getAttribute("data-theme");
    const currentColour = document.body.getAttribute("data-colour");

    function pickRandom(list, current) {
      if (!list.length) return current;
      const pool = current ? list.filter((v) => v !== current) : list.slice();
      const base = pool.length ? pool : list;
      return base[Math.floor(Math.random() * base.length)];
    }

    const newTheme = pickRandom(themeOptions, currentTheme);
    const newColour = pickRandom(colourOptions, currentColour);

    if (newTheme) applyTheme(newTheme);
    if (newColour) applyColour(newColour);

    if (typeof shuffleLowpolyColours === "function") {
      shuffleLowpolyColours();
    }
    if (typeof randomizeLowpolyPattern === "function") {
      randomizeLowpolyPattern();
    }
  
    if (typeof pulseActiveControls === "function") {
      pulseActiveControls();
    }
}

  if (shuffleBtn) {
    shuffleBtn.addEventListener("click", () => {
      spinDiceOnce(shuffleBtn);
      rollThemeAndColour();
    });
  }
  // Auto-shuffle on load/refresh: pick a fresh theme + colourway each time the file opens.
// We hide the UI briefly (mf-preload) so there’s no jarring “default → shuffled” flash.
document.addEventListener("DOMContentLoaded", () => {
  try {
    if (typeof rollThemeAndColour === "function") {
      rollThemeAndColour();
    } else if (typeof pulseActiveControls === "function") {
      pulseActiveControls();
    }
  } finally {
    // Show UI on next frame after attributes/classes are applied.
    requestAnimationFrame(() => {
      document.body.classList.remove("mf-preload");
    });
  }
});



// Text-size toggle for phone bubbles
  const textSizeButtons = document.querySelectorAll(".text-size-btn");
  textSizeButtons.forEach((btn) => {
    btn.addEventListener("click", () => {
      const size = btn.getAttribute("data-size") || "md";
      document.body.setAttribute("data-textsize", size);

      textSizeButtons.forEach((b) => {
        b.classList.remove("is-active");
        b.setAttribute("aria-pressed", "false");
      });

      btn.classList.add("is-active");
      btn.setAttribute("aria-pressed", "true");
    });
  });

  
  // [MF:PHASE-F] Notes input: consolidated at line ~15662 (Phase F scheduler + composition guards)
  // Keep MLCX state in sync when notes change or layout switches
  if (mlcxNotesInput) {
    // [MF:PHASE-F] BLUR: runRecomputeNow (immediate)
    // [MF:PHASE-F][OWNER:INPUT_NOTES] BLUR: immediate recompute
    mlcxNotesInput.addEventListener("blur", () => { if (typeof runRecomputeNow === 'function') runRecomputeNow('notes:blur'); });
  }

  document.addEventListener("layoutchange", function (evt) {
    refreshMLCXState();
    syncCvButtonVisibility();
  });

// Toast notification system
  const toastContainer = document.createElement("div");
  toastContainer.className = "toast-container";
  document.body.appendChild(toastContainer);

  function showToast(message, type = "info") {
    const toast = document.createElement("div");
    toast.className = `toast ${type}`;
    toast.textContent = message;
    toastContainer.appendChild(toast);
    
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        toast.classList.add("visible");
      });
    });
    
    setTimeout(() => {
      toast.classList.remove("visible");
      setTimeout(() => {
        if (toast.parentNode) toast.parentNode.removeChild(toast);
      }, 250);
    }, 2000);
  }

  // Keyboard shortcuts
  document.addEventListener("keydown", (e) => {
    if (e.__devHandled) return;
    // Ctrl+S: Copy agent text
    if ((e.ctrlKey || e.metaKey) && e.key === "s") {
      e.preventDefault();
      if (copyBtn) copyBtn.click();
      return;
    }
    
    // Ctrl+K: Clear
    if ((e.ctrlKey || e.metaKey) && e.key === "k") {
      e.preventDefault();
      if (clearBtn) clearBtn.click();
      return;
    }
    
    // Ctrl+1: Split layout
    if ((e.ctrlKey || e.metaKey) && e.key === "1") {
      e.preventDefault();
      document.body.setAttribute("data-layout", "split");
      document.dispatchEvent(new Event("layoutchange"));
      showToast("Switched to Split view", "info");
      return;
    }

  });

// Initial state
  renderCustomer();
  renderAgent();
  pushAgentHistory();
  if (lowpolySvg) { randomizeLowpolyPattern(); }
  syncBubbleAddButtonColours();
  refreshMLCXState();
  syncCvButtonVisibility();
  
// ---- Context Menu Logic ----
const contextMenu = document.getElementById("editorContextMenu");
let contextIssueSpan = null;

function showContextMenu(x,y,target){
  if(!contextMenu)return;
  contextIssueSpan = null;
  const divider = contextMenu.querySelector('[data-role="issue-divider"]');
  const issueBtns = contextMenu.querySelectorAll('[data-role="issue-action"]');
  const isIssue = target && (target.classList.contains("spell-issue")||target.classList.contains("uk-issue"));
  divider.hidden = !isIssue;
  issueBtns.forEach(btn=>btn.hidden = !isIssue);
  contextIssueSpan = isIssue? target: null;
  contextMenu.style.left = x+"px";
  contextMenu.style.top = y+"px";
  contextMenu.hidden = false;
}
function hideContextMenu(){if(contextMenu){contextMenu.hidden=true;} contextIssueSpan=null;}

// Only intercept right-clicks when they happen on a highlighted issue span.
// Right-click elsewhere should show the native browser context menu.
if (agentInput) {
  agentInput.addEventListener("contextmenu", (e) => {
    const issueSpan = e.target.closest && e.target.closest("span.spell-issue, span.uk-issue");

    // If the right-click is NOT on a highlighted issue, let the browser menu appear
    if (!issueSpan) {
      hideContextMenu();
      return;
    }

    // If it IS on a highlighted issue, show the custom context menu
    e.preventDefault();
    showContextMenu(e.clientX, e.clientY, issueSpan);
  });
}

document.addEventListener("click",(e)=>{if(contextMenu && !contextMenu.contains(e.target))hideContextMenu();});
if (contextMenu) {
  contextMenu.addEventListener("click",(e)=>{
    const btn=e.target.closest("button[data-cmd]"); if(!btn)return;
    const cmd=btn.dataset.cmd; hideContextMenu();
    if(cmd==="copy") document.execCommand("copy");
    else if(cmd==="cut"){document.execCommand("cut"); renderAgent(); updateIssueCounters();
 pushAgentHistory();}
    else if(cmd==="paste"){pasteBtn.click();}
    else if(cmd==="applySuggestion" && contextIssueSpan){applySuggestionToIssue(contextIssueSpan);}
    else if(cmd==="ignoreIssue" && contextIssueSpan){ignoreIssueSpan(contextIssueSpan);}
  });
}

// --- Issue cycling helpers ---
// Click on a counter to cycle through that class of spans in the editor, scrolling into view and flashing.
function clearIssueTargets() {
  // remove from editor
  agentInput.querySelectorAll(".issue-target").forEach(el => el.classList.remove("issue-target"));
  // remove from preview
  agentBubble.querySelectorAll(".issue-target").forEach(el => el.classList.remove("issue-target"));
}

function cycleIssue(kind) {
  // kind: "uk" or "spell"
  if (!agentInput) return;
  const cls = kind === "uk" ? "uk-issue" : "spell-issue";
  const list = Array.from(agentInput.querySelectorAll("span." + cls));
  const bubbleList = Array.from(agentBubble.querySelectorAll("span." + cls));
  if (!list.length) {
    // nothing to cycle
    return;
  }

  // choose and increment the relevant index
  if (kind === "uk") {
    ukIssueIndex = (ukIssueIndex + 1) % list.length;
    // reset spell index to avoid confusion
    spellIssueIndex = -1;
  } else {
    spellIssueIndex = (spellIssueIndex + 1) % list.length;
    ukIssueIndex = -1;
  }

  const idx = kind === "uk" ? ukIssueIndex : spellIssueIndex;
  if (typeof idx !== "number" || idx < 0) return;

  // Clear previous highlights
  clearIssueTargets();

  // Editor target
  const target = list[idx];
  if (target) {
    target.classList.add("issue-target");
    // Scroll into view inside the editor
    try {
      target.scrollIntoView({ behavior: "smooth", block: "nearest", inline: "nearest" });
    } catch (e) {}
    // also ensure the editor's internal scroll shows the word (agentInput is scrollable)
    // give a slight flash (CSS handles the animation)
  }

  // Preview target (mirror by position - same index)
  const previewTarget = bubbleList[idx];
  if (previewTarget) {
    previewTarget.classList.add("issue-target");
    try {
      previewTarget.scrollIntoView({ behavior: "smooth", block: "nearest", inline: "nearest" });
    } catch (e) {}
  }
}

// Make counters interactive (click + keyboard)
if (ukIssueCounter) {
  ukIssueCounter.addEventListener("click", (e) => {
    e.stopPropagation();
    cycleIssue("uk");
  });
  ukIssueCounter.addEventListener("keydown", (e) => {
    if (e.key === "Enter" || e.key === " " ) {
      e.preventDefault();
      cycleIssue("uk");
    }
  });
}

if (spellIssueCounter) {
  spellIssueCounter.addEventListener("click", (e) => {
    e.stopPropagation();
    cycleIssue("spell");
  });
  spellIssueCounter.addEventListener("keydown", (e) => {
    if (e.key === "Enter" || e.key === " " ) {
      e.preventDefault();
      cycleIssue("spell");
    }
  });
}



if (spellToggleBtn) {
  // Default state: hints on (issue highlighting is enabled by default)
  spellHintsMuted = false;
  window.spellHintsMuted = spellHintsMuted;

  const isMutedInitial = spellHintsMuted;
  spellToggleBtn.classList.toggle("is-on", isMutedInitial);
  spellToggleBtn.setAttribute("aria-pressed", isMutedInitial ? "true" : "false");
  spellToggleBtn.textContent = isMutedInitial ? "Checker: OFF" : "Checker: ON";

  spellToggleBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    spellHintsMuted = !spellHintsMuted;
    window.spellHintsMuted = spellHintsMuted;

    const isMuted = spellHintsMuted;
    spellToggleBtn.classList.toggle("is-on", isMuted);
    spellToggleBtn.setAttribute("aria-pressed", isMuted ? "true" : "false");
    spellToggleBtn.textContent = isMuted ? "Checker: OFF" : "Checker: ON";

    // When muting, immediately strip any visible highlights and zero counters
    if (isMuted && agentInput) {
      try { stripColoursAndIssueMarks(agentInput); } catch (err) {
        console.error("stripColoursAndIssueMarks (mute) failed:", err);
      }
      try { updateIssueCounters();
 } catch (err) {
        console.warn("updateIssueCounters (mute) failed", err);
      }
    } else if (!isMuted && typeof runCleanPipeline === "function") {
      // When turning hints back on, immediately run a clean to highlight current issues
      try { runCleanPipeline(); } catch (err) {
        console.error("runCleanPipeline (unmute) failed:", err);
      }
    }
  });
}
// Hook for server-side PySpellChecker boost
async function boostSuggestionsWithPyspellchecker() {
  const agentInput = document.getElementById("agentInput");
  if (!agentInput) return;

  const spans = Array.from(agentInput.querySelectorAll(".spell-issue"));
  if (!spans.length) return;

  const words = [...new Set(
    spans
      .map(s => (s.textContent || "").trim())
      .filter(Boolean)
      .map(w => w.toLowerCase())
  )];

  if (!words.length) return;

  let json;
  try {
    const response = await fetch(SPELLCHECK_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ words })
    });
    json = await response.json();
  } catch (err) {
    console.error("PySpell error:", err);
    return;
  }

  if (!json || !Array.isArray(json.results)) return;

  const statusMap = {};
  const suggestionMap = {};
  json.results.forEach(item => {
    const w = (item.word || "").toLowerCase();
    statusMap[w] = item.status || "unknown";
    if (item.suggestion) {
      suggestionMap[w] = item.suggestion;
    }
  });

  spans.forEach(span => {
    const raw = (span.textContent || "").trim();
    if (!raw) return;
    const key = raw.toLowerCase();
    const status = statusMap[key];

    // UK-correct ⇒ remove red underline
    if (status === "ok_uk") {
      span.classList.remove("spell-issue", "issue-word");
      span.removeAttribute("data-suggestion");
      span.removeAttribute("title");
      return;
    }

    // US variant ⇒ treat as UK issue (if you want to change colour)
    if (status === "uk_issue") {
      span.classList.remove("spell-issue");
      span.classList.add("uk-issue");
    }

    const suggestion = suggestionMap[key];
    if (suggestion && suggestion.toLowerCase() !== key) {
      span.dataset.suggestion = suggestion;
      span.title = "Suggestion: " + suggestion;
    }
  });

  // After boosting, refresh counters so everything stays in sync
  updateIssueCounters();
    const selectionKeys = ["ArrowLeft","ArrowRight","ArrowUp","ArrowDown","Home","End","PageUp","PageDown","Shift"," "];

    function trackEditorSelection(editor) {
      if (!editor) return;
      editor.addEventListener("mouseup", saveEditorSelection);
      editor.addEventListener("keyup", (event) => {
        if (selectionKeys.includes(event.key)) {
          saveEditorSelection();
        }
      });
    }

    trackEditorSelection(agentInput);
    trackEditorSelection(npEditor);
}

// [MF:P-F] MutationObserver: LIGHT ONLY (minimal cleanup, no heavy analysis)
// Keep visual highlights in sync when editor changes
const observer = new MutationObserver(() => {
  // LIGHT: keep only minimal cleanup; avoid heavy scans/counters here
  clearIssueTargets();
});

  // Phase 19.10: Dev Lab dice button - load random demo scenario
  const devLabDiceBtn = document.getElementById("devLabDiceBtn");
  if (devLabDiceBtn) {
    devLabDiceBtn.addEventListener("click", () => {
      // Phase 19.12: Dice now only shuffles theme/colourway (no scenario injection)
      spinDiceOnce(devLabDiceBtn);
      if (typeof rollThemeAndColour === "function") {
        rollThemeAndColour();
      }
    });
  }
if (agentInput) {
  observer.observe(agentInput, { childList: true, subtree: true, characterData: true });
}


  // --- Scroll sync: agent editor ↔ phone preview ---
  if (agentInput && chatBody && agentBubble) {
    const syncAgentPreviewScroll = () => {
      const maxInputScroll = agentInput.scrollHeight - agentInput.clientHeight;
      const maxChatScroll = chatBody.scrollHeight - chatBody.clientHeight;
      if (maxInputScroll <= 0 || maxChatScroll <= 0) return;
      const ratio = maxInputScroll > 0 ? (agentInput.scrollTop / maxInputScroll) : 0;
      chatBody.scrollTop = ratio * maxChatScroll;
    };

    // Whenever the agent box scrolls, move the phone preview to match
    agentInput.addEventListener("scroll", syncAgentPreviewScroll);

    const focusAgentBubble = () => {
      agentBubble.classList.add("is-focus-synced");
      // Also nudge the scroll so the bubble stays in view
      syncAgentPreviewScroll();
    };
    const blurAgentBubble = () => {
      agentBubble.classList.remove("is-focus-synced");
    };

    agentInput.addEventListener("focus", focusAgentBubble);
    // [MF:PHASE-F] Note: blur handler for Phase F recompute is primary at line ~14082 (consolidated)
    // This additional blur handler managed by preview sync system
    agentInput.addEventListener("blur", blurAgentBubble);
    // Keep alignment as the user types or clicks around
    agentInput.addEventListener("click", syncAgentPreviewScroll);
    // [MF:PHASE-F][OWNER:INPUT_AGENT] KEYUP: LIGHT preview scroll only (no heavy recompute)
    agentInput.addEventListener("keyup", syncAgentPreviewScroll);
  }


// Accessibility: allow space/enter on pill buttons (some browsers don't)
colourButtons.forEach(btn => {
  btn.addEventListener('keydown', (e) => {
    if (e.key === "Enter" || e.key === " ") {
      e.preventDefault();
      btn.click();
    }
  });
});

// [MF:PHASE-F] Hide tooltip when editor loses focus (keeps things tidy)
if (agentInput) {
  agentInput.addEventListener("blur", () => {
    // small delay to allow click handlers to run (e.g. context menu)
    // [MF:PHASE-F] Note: This is LIGHT UI cleanup, not related to heavy recompute
    setTimeout(hideIssueTooltip, 200);
  }, true);
}

  // [MF:PHASE-F] End: Consolidated input wiring (agent, customer, notes)
  // All heavy recompute scheduled via Phase F scheduler, guarded by IME composition

// BEGIN Spellchecker Module Integration (Modules 1–3)
/* ---------------------------------------------------------------
 * MODULE 1 - Dictionaries & Helper Utilities
 * ---------------------------------------------------------------
 * This module defines the core UK dictionary, the US→UK variant map,
 * industry-specific whitelists, contraction handling, proper noun
 * capitalisation, QWERTY adjacency maps, a Levenshtein helper and
 * gibberish detection.  It provides the backbone for the unified
 * spellchecker engine below.
 */

/* Expanded UK dictionary.
   This set has been populated using the Cambridge Preliminary/PET vocabulary list
   (approx. 950 high‑frequency words) merged with the original core words.  By
   covering common nouns, verbs, adjectives and adverbs, it drastically
   reduces false positives while still allowing the spellchecker to focus on
   genuine misspellings and US→UK variants. */
const UK_WORDS = new Set([
  "a",
"ability",
"able",
"about",
"above",
"abroad",
"absent",
"absolutely",
"accent",
"accept",
"access",
"accident",
"accommodation",
"accompany",
"account",
"accountant",
"accurate",
"ache",
"achieve",
"across",
"another",
"answer",
"answerphone",
"ant",
"antique",
"anxious",
"any",
"anybody",
"anymore",
"anyone",
"anything",
"anyway",
"anywhere",
"apart",
"apartment",
"apologise",
"apology",
"appear",
"appearance",
"apple",
"application",
"baby",
"babysit",
"babysitter",
"back",
"background",
"backpack",
"backpacker",
"backpacking",
"backwards",
"bad",
"badly",
"badminton",
"bag",
"baggage",
"bake",
"baker",
"balcony",
"bald",
"ball",
"ballet",
"balloon",
"banana",
"band",
"bandage",
"bank",
"banking",
"bar",
"barbecue",
"baseball",
"basic",
"basin",
"basket",
"basketball",
"bat",
"bath",
"bathroom",
"bitter",
"bleed",
"blood",
"body",
"boil",
"boiled",
"bold",
"bomb",
"bone",
"book",
"bookcase",
"booking",
"bookshelf",
"bookshop",
"bookstore",
"boot",
"border",
"bored",
"boring",
"born",
"borrow",
"boss",
"both",
"bother",
"bottle",
"bottom",
"bowl",
"box",
"break",
"bunch",
"cab",
"cabbage",
"cabin",
"cabinet",
"cable",
"cafeteria",
"cage",
"cake",
"calculator",
"calendar",
"calf",
"call",
"calm",
"camel",
"camera",
"camp",
"camping",
"campsite",
"can",
"canal",
"cancel",
"candidate",
"candle",
"candy",
"canteen",
"cap",
"capital",
"captain",
"car",
"catch",
"cathedral",
"cd",
"cheap",
"cheat",
"check",
"check-in",
"checkout",
"cheek",
"cheerful",
"cheese",
"chef",
"chemist",
"chemistry",
"cheque",
"chess",
"chicken",
"child",
"childhood",
"chilli",
"chin",
"chip",
"chocolate",
"choice",
"choose",
"cinema",
"circle",
"circus",
"city",
"clap",
"class",
"click",
"climb",
"coach",
"cold",
"collect",
"consist",
"consonant",
"contact",
"contain",
"contents",
"contest",
"continent",
"continue",
"contract",
"control",
"convenient",
"conversation",
"convince",
"cook",
"cooker",
"cookie",
"cooking",
"cool",
"copy",
"corn",
"corner",
"correct",
"correction",
"cost",
"costume",
"cosy",
"cottage",
"cotton",
"cough",
"crossing",
"cycle",
"dad",
"daily",
"damage",
"damaged",
"dance",
"dancer",
"dancing",
"danger",
"dangerous",
"dark",
"date",
"daughter",
"day",
"dead",
"deaf",
"deal",
"dear",
"death",
"decide",
"decision",
"declare",
"decorate",
"decrease",
"deep",
"defeat",
"defence",
"defend",
"definitely",
"degree",
"delay",
"dishwasher",
"disk",
"dislike",
"display",
"distance",
"district",
"disturb",
"dive",
"diver",
"divide",
"diving",
"do",
"document",
"documentary",
"dog",
"doll",
"dollar",
"dolphin",
"donkey",
"door",
"dot",
"dvd",
"each",
"ear",
"earache",
"early",
"earn",
"earring",
"earth",
"easily",
"east",
"eastern",
"easy",
"easygoing",
"eat",
"economics",
"edge",
"education",
"effect",
"efficient",
"effort",
"egg",
"either",
"elbow",
"elder",
"elderly",
"election",
"electric",
"electrical",
"electricity",
"electronic",
"elementary",
"elephant",
"elevator",
"else",
"email",
"embarrassed",
"embarrassing",
"embassy",
"emergency",
"experience",
"experienced",
"experiment",
"expert",
"explain",
"explanation",
"face",
"face-to-face",
"facilities",
"fact",
"factory",
"fail",
"fair",
"fairly",
"fall",
"false",
"familiar",
"family",
"famous",
"fan",
"fancy",
"fantastic",
"far",
"fare",
"firm",
"first",
"fish",
"fishing",
"fit",
"fitness",
"fix",
"flag",
"flat",
"flavour",
"flight",
"float",
"flood",
"floor",
"flour",
"flow",
"flower",
"flu",
"flute",
"fly",
"fog",
"foggy",
"fold",
"folk",
"follow",
"following",
"gain",
"gallery",
"game",
"gap",
"garage",
"garden",
"garlic",
"gas",
"gate",
"general",
"generally",
"generation",
"generous",
"gentle",
"geography",
"get",
"go",
"gorgeous",
"government",
"grab",
"grade",
"graduation",
"gram",
"grammar",
"grand",
"grandchild",
"habit",
"hair",
"haircut",
"hairdresser",
"hairdryer",
"half",
"half-price",
"hall",
"hand",
"hand-held",
"handbag",
"handbook",
"handkerchief",
"handle",
"handsome",
"handwriting",
"hang",
"happen",
"happily",
"happiness",
"happy",
"harbour",
"hard",
"hardly",
"hardware",
"hat",
"hopeless",
"horrible",
"horror",
"horse",
"hospital",
"hostel",
"hot",
"huge",
"i",
"ice",
"icy",
"id",
"idea",
"identification",
"if",
"ill",
"illness",
"imagination",
"imagine",
"immediately",
"immigration",
"importance",
"important",
"impossible",
"improve",
"improvement",
"in",
"interest",
"interested",
"interesting",
"intermediate",
"international",
"internet",
"interrupt",
"interval",
"interview",
"jacket",
"jail",
"jam",
"jar",
"jazz",
"jealous",
"jeans",
"jet",
"kangaroo",
"keen",
"keep",
"keeper",
"kettle",
"key",
"label",
"laboratory",
"lack",
"ladder",
"lady",
"lake",
"lamb",
"lamp",
"land",
"landscape",
"language",
"laptop",
"large",
"last",
"late",
"lately",
"let",
"letter",
"lettuce",
"level",
"library",
"licence",
"lie",
"life",
"lift",
"light",
"lighter",
"lightning",
"like",
"likely",
"limit",
"limited",
"line",
"machine",
"mad",
"madam",
"magazine",
"magic",
"magnificent",
"mail",
"main",
"make",
"make-up",
"male",
"man",
"manage",
"manager",
"mango",
"many",
"map",
"mark",
"market",
"marriage",
"married",
"marry",
"marvellous",
"match",
"mistake",
"mix",
"mobile",
"model",
"modern",
"moment",
"money",
"monkey",
"month",
"monument",
"mood",
"moon",
"more",
"morning",
"mosquito",
"most",
"name",
"narrow",
"nasty",
"national",
"nationality",
"natural",
"nature",
"near",
"nearby",
"nearly",
"neat",
"necessary",
"neck",
"necklace",
"need",
"nose",
"not",
"note",
"notebook",
"notepaper",
"nothing",
"object",
"obvious",
"obviously",
"occasion",
"occupation",
"ocean",
"of",
"off",
"offer",
"office",
"officer",
"often",
"oh",
"oil",
"oj",
"old",
"old-fashioned",
"olive",
"outdoors",
"outside",
"oven",
"over",
"pack",
"packet",
"page",
"pain",
"painful",
"paint",
"painter",
"painting",
"pair",
"palace",
"pale",
"pan",
"pants",
"paper",
"paragraph",
"parcel",
"pardon",
"parent",
"peel",
"pen",
"pence",
"pencil",
"penfriend",
"penguin",
"penny",
"people",
"pepper",
"per",
"percent",
"perfect",
"perform",
"performance",
"performer",
"perfume",
"perhaps",
"period",
"permanent",
"permission",
"permit",
"permitted",
"person",
"personal",
"personally",
"persuade",
"pet",
"petrol",
"pharmacy",
"phone",
"photo",
"photocopy",
"police",
"policeman",
"polite",
"political",
"politician",
"politics",
"pollution",
"pool",
"pop",
"popular",
"population",
"port",
"position",
"positive",
"possibility",
"possible",
"possibly",
"post",
"postcard",
"poster",
"postman",
"postpone",
"pot",
"potato",
"pound",
"pour",
"powder",
"power",
"powerful",
"practice",
"practise",
"purple",
"purpose",
"purse",
"push",
"put",
"qualification",
"qualified",
"quality",
"quantity",
"quarter",
"queen",
"question",
"rabbit",
"race",
"racket",
"radio",
"rail",
"railway",
"rain",
"raincoat",
"rainforest",
"raise",
"range",
"rap",
"rare",
"rarely",
"rather",
"raw",
"reach",
"read",
"reader",
"reading",
"ready",
"real",
"resort",
"respect",
"responsible",
"rest",
"restaurant",
"result",
"retire",
"return",
"review",
"revise",
"revision",
"reward",
"rice",
"rich",
"ride",
"rider",
"right",
"rose",
"sad",
"safe",
"safely",
"sail",
"sailing",
"salad",
"salary",
"sale",
"salmon",
"salt",
"same",
"sand",
"sandal",
"sandwich",
"satisfactory",
"satisfied",
"sauce",
"saucepan",
"saucer",
"sausage",
"save",
"say",
"scared",
"several",
"sew",
"sex",
"shade",
"shadow",
"shake",
"shall",
"shame",
"shampoo",
"shape",
"share",
"shark",
"sharp",
"shave",
"she",
"sheep",
"sheet",
"shelf",
"shine",
"shiny",
"ship",
"shirt",
"shock",
"shocked",
"skiing",
"skill",
"skin",
"skirt",
"sky",
"sleep",
"sleeve",
"slim",
"slip",
"slowly",
"small",
"smart",
"smell",
"smile",
"smoke",
"smoking",
"smooth",
"snack",
"snake",
"snow",
"snowboard",
"snowboarding",
"so",
"soap",
"soccer",
"sociable",
"social",
"society",
"sock",
"sofa",
"soft",
"software",
"soldier",
"start",
"station",
"statue",
"stay",
"steak",
"steal",
"steep",
"step",
"stick",
"sticky",
"still",
"stir",
"stomach",
"stone",
"stop",
"sure",
"surf",
"surfboard",
"surfing",
"surname",
"surprise",
"surprised",
"surprising",
"surround",
"table",
"table-cloth",
"tablet",
"take",
"takeaway",
"tense",
"tent",
"term",
"terrible",
"terribly",
"terrific",
"terrified",
"test",
"text",
"textbook",
"than",
"thank",
"thanks",
"that",
"the",
"theatre",
"their",
"theirs",
"them",
"themselves",
"then",
"there",
"therefore",
"these",
"they",
"thick",
"thief",
"thin",
"thing",
"think",
"tour",
"tourism",
"tourist",
"tournament",
"toward",
"towel",
"tower",
"town",
"toy",
"track",
"tracksuit",
"trade",
"traditional",
"traffic",
"train",
"trainer",
"training",
"tram",
"transfer",
"translate",
"translation",
"transport",
"travel",
"ugly",
"umbrella",
"unable",
"unbelievable",
"uncle",
"uncomfortable",
"under",
"underground",
"underline",
"underneath",
"underpants",
"understand",
"underwear",
"undress",
"unemployed",
"unemployment",
"unexpected",
"unfair",
"unfit",
"unforgettable",
"unfortunately",
"unfriendly",
"unhappy",
"unhealthy",
"valley",
"valuable",
"value",
"van",
"vanilla",
"variety",
"various",
"vase",
"vegetable",
"wage",
"wait",
"waiter",
"waitress",
"wake",
"walk",
"walking",
"wall",
"wallet",
"want",
"war",
"wardrobe",
"warm",
"warn",
"warning",
"wash",
"weekly",
"weigh",
"weight",
"welcome",
"well",
"well-dressed",
"well-known",
"west",
"western",
"wet",
"whale",
"what",
"whatever",
"wheel",
"wheelchair",
"when",
"whenever",
"where",
"wherever",
"whether",
"which",
"white",
"wool",
"yard",
"yeah",
"year",
"yellow",
"yes",
"yesterday",
"zebra",
"zero"
  ,"cat","writing","tone","style","only","catch"
]);

/* US → UK spellings map. Use this to enforce UK spellings. */
const UK_VARIANTS = {
  color: "colour",
  favorite: "favourite",
  behavior: "behaviour",
  organize: "organise",
  realize: "realise",
  recognize: "recognise",
  traveling: "travelling",
  jewelry: "jewellery",
  center: "centre",
  theater: "theatre",
  license: "licence",   // noun form
  offense: "offence",
  defense: "defence",
  check: "cheque",      // financial context
  gray: "grey"
};

/* Core month and day names in lowercase form. */
const MONTHS = new Set([
  "january","february","march","april","may","june",
  "july","august","september","october","november","december"
]);
const DAYS = new Set([
  "monday","tuesday","wednesday","thursday","friday","saturday","sunday"
]);

/* Industry-specific words that must not be flagged. */
const INDUSTRY_WORDS = new Set([
  "fnol","mta","ipt","indemnity","total-loss","total loss",
  "write-off","write off","courtesy","courtesy-car",
  "assessor","excess","non-fault","fault","liability","underwriter",
  "ncd","renewal","renewals","claim","claims","policy","policyholder","ph",
  "tpf&t","comprehensive","windscreen","hire","authority","approved",
  "outsourced","oss","hastings","vizion","copart","enterprise","autoassign",
  "loss","ivr","ivc","fraud","swat"
]);

/* Disallowed chat slang. In a professional insurance environment these abbreviations
   and informal terms should be flagged as errors rather than accepted.  When
   classifyWord() sees a word in this set it will return a spelling issue with
   no suggestion so that the user can choose to correct or leave it. */
const SLANG = new Set([
  "pls","btw","idk","tbh","imo","imho","rn","asap","brb","lol","ok","kk",
  "tmrw","nth","smth","tho","u","ur","bc","gna","gonna","wanna","msg","dm","bcuz"
]);

/* Contractions. Unapostrophed form → correct form. */
const CONTRACTIONS = {
  cant: "can't",
  wont: "won't",
  shouldnt: "shouldn't",
  wouldnt: "wouldn't",
  couldnt: "couldn't",
  dont: "don't",
  doesnt: "doesn't",
  im: "I'm",
  youre: "you're",
  were: "we're",
  theyre: "they're",
  its: "it's",
  thats: "that's",
  lets: "let's"
};


// Very small, focused list of ultra-common misspellings → correct form.
// This is intentionally tiny so we avoid overflagging.
const COMMON_MISSPELLINGS = {
  recieve: "receive",
  recive: "receive",
  seperate: "separate",
  definately: "definitely",
  definetly: "definitely",
  accomodate: "accommodate",
  adress: "address",
  occured: "occurred",
  enviroment: "environment",
  goverment: "government",
  beleive: "believe",
  calender: "calendar",
  neccessary: "necessary",
  publically: "publicly",
  untill: "until",
  wierd: "weird",
  febuary: "february"
  // Add more here over time as you spot patterns in real chats.
};


/* Whitelist of words that look wrong but are actually correct. */
const WHITELIST = new Set([
  "queue","manoeuvre","gauge","mortgage","rhythm","receipt",
  "colonel","yacht","genre","debris","naïve","façade","résumé"
]);

/* Proper nouns mapping: months, days, continents, countries, cities. */
const properNouns = {
  ...(() => {
    const map = {};
    // Capitalise months and days
    MONTHS.forEach(m => map[m] = m.charAt(0).toUpperCase() + m.slice(1));
    DAYS.forEach(d => map[d] = d.charAt(0).toUpperCase() + d.slice(1));
    // Continents
    ["africa","europe","asia","america","australia"].forEach(c => {
      map[c] = c.charAt(0).toUpperCase() + c.slice(1);
    });
    // Countries & cities relevant to your user base
    [
      "south africa","united kingdom","united states","new york",
      "london","cape town","johannesburg","pretoria","durban"
    ].forEach(p => {
      map[p] = p.split(" ").map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(" ");
    });
    return map;
  })()
};

/* QWERTY adjacency map for adjacent-key typo corrections. */
const ADJACENT_KEYS = {
  q: ['w','a'],              w: ['q','e','s'],         e: ['w','r','s','d'],
  r: ['e','t','d','f'],      t: ['r','y','f','g'],     y: ['t','u','g','h'],
  u: ['y','i','h','j'],      i: ['u','o','j','k'],     o: ['i','p','k','l'],
  p: ['o','l'],              a: ['q','w','s','z'],      s: ['w','e','a','d','z','x'],
  d: ['e','r','s','f','x','c'], f: ['r','t','d','g','c','v'], g: ['t','y','f','h','v','b'],
  h: ['y','u','g','j','b','n'], j: ['u','i','h','k','n','m'], k: ['i','o','j','l','m'],
  l: ['o','p','k'],          z: ['a','s','x'],         x: ['s','d','z','c'],
  c: ['d','f','x','v'],      v: ['f','g','c','b'],     b: ['g','h','v','n'],
  n: ['h','j','b','m'],      m: ['j','k','n']
};

/* Levenshtein distance helper. */
function levenshtein(a, b) {
  const matrix = [];
  for (let i = 0; i <= b.length; i++) matrix[i] = [i];
  for (let j = 0; j <= a.length; j++) matrix[0][j] = j;
  for (let i = 1; i <= b.length; i++) {
    for (let j = 1; j <= a.length; j++) {
      const cost = b.charAt(i-1) === a.charAt(j-1) ? 0 : 1;
      matrix[i][j] = Math.min(
        matrix[i-1][j] + 1,        // deletion
        matrix[i][j-1] + 1,        // insertion
        matrix[i-1][j-1] + cost    // substitution
      );
    }
  }
  return matrix[b.length][a.length];
}

/* Basic gibberish detection:
   - No vowels
   - >3 consonants in a row
   - Repeating trigram patterns (e.g. "sdasdasd") */
function looksLikeGibberish(word) {
  const lower = word.toLowerCase();
  if (lower.length >= 4 && !/[aeiou]/.test(lower)) return true;
  if (/[bcdfghjklmnpqrstvwxyz]{4,}/.test(lower)) return true;
  if (lower.length >= 12) {
    for (let i = 0; i < lower.length - 5; i++) {
      const tri = lower.slice(i, i + 3);
      if (tri.repeat(3).length <= lower.length && lower.includes(tri.repeat(3))) {
        return true;
      }
    }
  }
  return false;
}

/* ---------------------------------------------------------------
 * MODULE 2 - Spellchecker Core Engine
 * ---------------------------------------------------------------
 * This module defines:
 *   - classifyWord(): determine if a word has a spelling or UK issue
 *   - findSimpleSuggestion(): simple typo corrections (adjacency, swap, deletion, vowel insertion)
 *   - markAllIssues(): walk the DOM and wrap mistakes in span elements
 * It unifies UK/US mismatches and general spelling anomalies and uses
 * the dictionaries and helpers defined above.
 */

// Determine if a given word should be marked and return the issue details.
// Returns an object {type:'uk'|'spell', suggestion:string|null} or null if no issue.
function classifyWord(word) {
  const original = word;
  const lower    = original.toLowerCase();

  // 1) Fast exits: things we never want to flag
  // ------------------------------------------------
  // Ignore digits, emails, URLs, IDs, file paths, hashtags, etc.
  if (/[0-9@#\/]/.test(original) || /\./.test(original) || /_/.test(original)) return null;

  // Skip long acronyms (ALL CAPS, 2+ letters): UK, ETA, PDF, etc.
  if (/^[A-Z]{2,}$/.test(original)) return null;

  // Domain terms should always be accepted.
  if (INDUSTRY_WORDS.has(lower)) return null;

  // Allow whitelisted odd-but-correct words (product names, etc.).
  if (WHITELIST.has(lower)) return null;

  // 2) Hard rules: “definitely wrong” patterns
  // ------------------------------------------------
  // Disallowed slang that we always want to nudge out of customer comms.
  if (SLANG.has(lower)) {
    return { type: "spell", suggestion: null };
  }

  // Proper nouns: fix capitalisation only.
  if (properNouns[lower]) {
    const expected = properNouns[lower];
    if (original !== expected) {
      return { type: "spell", suggestion: expected };
    }
    return null; // Already correctly capitalised.
  }

  // Contractions missing apostrophes: cant → can't, dont → don't, etc.
  if (CONTRACTIONS[lower] && !original.includes("'")) {
    return { type: "spell", suggestion: CONTRACTIONS[lower] };
  }

  // Known ultra-common misspellings (small curated list above).
  if (COMMON_MISSPELLINGS[lower]) {
    return { type: "spell", suggestion: COMMON_MISSPELLINGS[lower] };
  }

  // US→UK spellings (engine-driven) — keep UI + scanner in sync.
 try {
   const rules = getUkusPairsLegacy();
   const all = []
     .concat(Array.isArray(rules.autoReplace) ? rules.autoReplace : [])
     .concat(Array.isArray(rules.manualCheck) ? rules.manualCheck : []);
   for (const r of all) {
     if (!r?.pattern) continue;
     r.pattern.lastIndex = 0;
     const m = r.pattern.exec(original);
     if (!m) continue;
     const matchText = m[0];
     let suggestion = null;

     if (typeof r.replacement === 'function') {
       const groups = m.length > 1 ? m.slice(1) : [];
       const named = m.groups || null;
       try {
         suggestion = (r.replacement.length >= 3)
           ? r.replacement(matchText, groups, named, m)
           : r.replacement(matchText, groups);
       } catch (e) {
         try { suggestion = r.replacement(matchText, ...groups); } catch(_) { suggestion = null; }
       }
     } else if (typeof r.replacement === 'string') {
       try { suggestion = matchText.replace(r.pattern, r.replacement); } catch(_) { suggestion = r.replacement; }
     }

     if (suggestion && typeof suggestion === 'string') {
       // Preserve original casing (roughly)
       if (original === original.toUpperCase()) suggestion = suggestion.toUpperCase();
       else if (original[0] === original[0].toUpperCase()) suggestion = suggestion.charAt(0).toUpperCase() + suggestion.slice(1);

       return { type: "uk", suggestion };
     }
   }
 } catch (e) {}
// 3) Dictionary match: safe to accept
  // ------------------------------------------------
  if (UK_WORDS.has(lower)) {
    // Special case: lowercase "i" in the middle of a sentence.
    if (original === "i") {
      return { type: "spell", suggestion: "I" };
    }
    return null; // Correct UK word.
  }

  // 4) Structural “looks broken” checks
  // ------------------------------------------------
  // Triple or longer repeated letters: sooo, hellooo, yessss, etc.
  if (/([a-z])\1{2,}/i.test(original)) {
    return { type: "spell", suggestion: null };
  }

  // Gibberish (no vowels, long consonant runs, repeated nonsense patterns).
  if (looksLikeGibberish(original)) {
    return { type: "spell", suggestion: null };
  }

  // 5) Month / weekday near-misses (small Levenshtein window)
  // ------------------------------------------------
  for (const month of MONTHS) {
    if (levenshtein(lower, month) <= 2) {
      return {
        type: "spell",
        suggestion: month.charAt(0).toUpperCase() + month.slice(1)
      };
    }
  }

  for (const day of DAYS) {
    if (levenshtein(lower, day) <= 2) {
      return {
        type: "spell",
        suggestion: day.charAt(0).toUpperCase() + day.slice(1)
      };
    }
  }

  // 6) Everything else: assume valid
  // ------------------------------------------------
  // We *do not* run a generic typo suggester here. That’s what was making the
  // checker over-eager and flagging lots of rare but valid words.
  // Unknown-but-sane words are treated as fine.
  return null;
}

// Generate a basic suggestion using adjacency, transposition, deletion, or vowel insertion.
// Returns a candidate correction or null.
function findSimpleSuggestion(lower) {
  // 1) Adjacent-key substitution.
  for (let i = 0; i < lower.length; i++) {
    const ch = lower[i];
    const neighbours = ADJACENT_KEYS[ch] || [];
    for (const n of neighbours) {
      const candidate = lower.slice(0, i) + n + lower.slice(i + 1);
      if (UK_WORDS.has(candidate)) return candidate;
      if (properNouns[candidate]) return properNouns[candidate];
    }
  }
  // 2) Swap adjacent characters.
  for (let i = 0; i < lower.length - 1; i++) {
    const arr = lower.split("");
    const tmp = arr[i];
    arr[i] = arr[i + 1];
    arr[i + 1] = tmp;
    const candidate = arr.join("");
    if (UK_WORDS.has(candidate)) return candidate;
    if (properNouns[candidate]) return properNouns[candidate];
  }
  // 3) Remove one character (extra letter).
  for (let i = 0; i < lower.length; i++) {
    const candidate = lower.slice(0, i) + lower.slice(i + 1);
    if (UK_WORDS.has(candidate)) return candidate;
    if (properNouns[candidate]) return properNouns[candidate];
  }
  // 4) Insert a vowel (missing vowel).
  const vowels = ["a", "e", "i", "o", "u", "y"];
  for (let i = 0; i <= lower.length; i++) {
    for (const v of vowels) {
      const candidate = lower.slice(0, i) + v + lower.slice(i);
      if (UK_WORDS.has(candidate)) return candidate;
      if (properNouns[candidate]) return properNouns[candidate];
    }
  }
  return null;
}

// Walk the DOM under `root`, wrap errors in <span> elements, and apply data attributes for suggestions.
// Replaces both the previous spellchecker and UK checker.
function markAllIssues(root) {
  if (!root) return;

  function walk(node) {
    if (node.nodeType === Node.TEXT_NODE) {
      const text = node.textContent || "";
      if (!/[A-Za-z]/.test(text)) return;

      // Pass 1: pattern-based UK/US matches (handles phrases and multi-word forms)
      const applyUkusPatterns = (raw) => {
        if (!raw) return null;
        const rulesSource = (typeof globalThis !== 'undefined' && 'UKUS_RULES' in globalThis) ? globalThis.UKUS_RULES : null;
        const autoRules = Array.isArray(rulesSource?.autoReplace) ? rulesSource.autoReplace : [];
        const manualRules = Array.isArray(rulesSource?.manualCheck) ? rulesSource.manualCheck : [];
        if (!autoRules.length && !manualRules.length) return null;

        let cursor = 0;
        let changed = false;
        const frag = document.createDocumentFragment();

        while (cursor < raw.length) {
          let earliestMatch = null;
          let earliestRule = null;
          let earliestType = null; // 'auto' | 'manual'

          // Auto rules
          for (const rule of autoRules) {
            if (!rule?.pattern) continue;
            rule.pattern.lastIndex = cursor;
            const m = findNextMatch(rule, raw, cursor);
            if (m && (earliestMatch === null || m.index < earliestMatch.index)) {
              earliestMatch = m;
              earliestRule = rule;
              earliestType = 'auto';
            }
          }

          // Manual rules
          for (const rule of manualRules) {
            if (!rule?.pattern) continue;
            rule.pattern.lastIndex = cursor;
            const m = findNextMatch(rule, raw, cursor);
            if (m && (earliestMatch === null || m.index < earliestMatch.index)) {
              earliestMatch = m;
              earliestRule = rule;
              earliestType = 'manual';
            }
          }

          if (!earliestMatch) break;

          const matchIndex = earliestMatch.index;
          const matchText = earliestMatch[0];

          if (matchIndex > cursor) {
            frag.appendChild(document.createTextNode(raw.slice(cursor, matchIndex)));
          }

          const span = document.createElement('span');
          span.className = 'uk-issue';
          span.textContent = matchText;

          let suggestion = null;
          if (earliestRule) {
            if (earliestType === 'auto') {
              if (typeof earliestRule.replacement === 'function') {
                const groups = earliestMatch.length > 1 ? earliestMatch.slice(1) : [];
                suggestion = earliestRule.replacement(matchText, ...groups);
              } else if (earliestRule.replacement) {
                try {
                  suggestion = matchText.replace(earliestRule.pattern, earliestRule.replacement);
                } catch(_) {
                  suggestion = earliestRule.replacement;
                }
              }
              if (!suggestion && earliestRule.uk) suggestion = earliestRule.uk;
            } else {
              suggestion = earliestRule.uk || null;
            }
          }

          if (suggestion) span.dataset.suggestion = suggestion;
          const baseNote = earliestRule?.notes || (earliestType === 'manual' ? 'Manual check' : 'UK spelling suggestion');
          span.title = baseNote + (suggestion ? `: ${suggestion}` : '');

          frag.appendChild(span);
          cursor = matchIndex + matchText.length;
          changed = true;
        }

        if (cursor < raw.length) {
          frag.appendChild(document.createTextNode(raw.slice(cursor)));
        }

        return changed ? frag : null;
      };

      const patternFrag = applyUkusPatterns(text);
      if (patternFrag) {
        const parent = node.parentNode;
        if (parent) {
          parent.replaceChild(patternFrag, node);
          parent.normalize();
        }
        return; // already handled this text node
      }

      const wordRegex = /[A-Za-z']+/g;
      let match;
      let lastIndex = 0;
      let frag = document.createDocumentFragment();
      let hasIssue = false;

      while ((match = wordRegex.exec(text)) !== null) {
        const word  = match[0];
        const index = match.index;

        if (index > lastIndex) {
          frag.appendChild(document.createTextNode(text.slice(lastIndex, index)));
        }

        const info = classifyWord(word);

// Rely on the browser for generic spelling. Only inline-hint
// UK vs US variants (type === "uk") here.
if (info && info.type === "uk") {
          hasIssue = true;
          const span = document.createElement("span");
          span.className = "uk-issue";
          span.textContent = word;

          if (info.suggestion) {
            span.dataset.suggestion = info.suggestion;
            span.title = `UK spelling suggestion: ${info.suggestion}`;
          } else {
            span.title = "Check UK spelling";
          }

          frag.appendChild(span);
        } else {
          frag.appendChild(document.createTextNode(word));
        }

        lastIndex = index + word.length;
      }

      if (lastIndex < text.length) {
        frag.appendChild(document.createTextNode(text.slice(lastIndex)));
      }

      if (hasIssue) {
        const parent = node.parentNode;
        if (parent) {
          parent.replaceChild(frag, node);
          parent.normalize();
        }
      }
    } else if (node.nodeType === Node.ELEMENT_NODE) {
      // Avoid processing spans we created.
      if (
        node.classList &&
        (node.classList.contains("spell-issue") ||
         node.classList.contains("uk-issue"))
      ) {
        return;
      }
      Array.from(node.childNodes).forEach(walk);
    }
  }

  walk(root);
}

// Override the previous lightweight functions to use the new engine.
function markUkIssues(root) {
  markAllIssues(root);
}
function markSpellingIssues(root) {
  markAllIssues(root);
}

/* ---------------------------------------------------------------
 * MODULE 3 - Tooltip UI Overrides
 * ---------------------------------------------------------------
 * A modern dark bubble with rounded corners, larger padding,
 * subtle shadow, and improved buttons for Apply/Ignore.  CSS for
 * tooltips is appended here to override the default styles.
 */

// Inject tooltip styles only once to avoid duplicates.
(() => {
  if (!document.getElementById("issue-tooltip-styles")) {
    const styleEl = document.createElement("style");
    styleEl.id = "issue-tooltip-styles";
    styleEl.textContent = `
.issue-tooltip {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
  font-size: 12px;
  line-height: 1.5;
  background: rgba(30, 41, 59, 0.98);
  color: #e2e8f0;
  border-radius: 8px;
  padding: 8px 12px;
  box-shadow: 0 12px 24px rgba(0, 0, 0, 0.5);
  z-index: 10000;
  max-width: 280px;
  opacity: 0;
  transform: translateY(-4px);
  transition: opacity 0.15s ease, transform 0.15s ease;
}
.issue-tooltip-main {
  margin-bottom: 6px;
}
.issue-tooltip-actions {
  display: flex;
  gap: 6px;
  justify-content: flex-end;
}
.issue-tooltip-actions button {
  border: none;
  border-radius: 6px;
  padding: 4px 10px;
  font-size: 10px;
  cursor: pointer;
}
.issue-tooltip-actions button[data-action="apply"] {
  background: #f97316;
  color: #ffffff;
  font-weight: 600;
}
.issue-tooltip-actions button[data-action="ignore"] {
  background: #334155;
  color: #e2e8f0;
  border: 1px solid #475569;
}
    `;
    document.head.appendChild(styleEl);
  }
})();

// Updated showIssueTooltip(): modern positioning & animation
function showIssueTooltip(span) {
  if (!span) return;

  // Close any existing tooltip
  hideIssueTooltip();

  const suggestion = (span.dataset && span.dataset.suggestion)
    ? span.dataset.suggestion.trim()
    : "";

  // Create tooltip container
  const tooltip = document.createElement("div");
  tooltip.className = "issue-tooltip";
  tooltip.style.position = "fixed";

  // Tooltip content
  tooltip.innerHTML = `
    <div class="issue-tooltip-main">
      ${
        suggestion
          ? `<span>Correction: </span><strong>${suggestion}</strong>`
          : `Check this word manually`
      }
    </div>
    <div class="issue-tooltip-actions">
      ${
        suggestion
          ? `<button type="button" data-action="apply">Apply</button>`
          : ""
      }
      <button type="button" data-action="ignore">Ignore</button>
    </div>
  `;

  // Button behaviour: Apply or Ignore
  tooltip.addEventListener("click", (event) => {
    event.stopPropagation();
    const btn = event.target.closest("button[data-action]");
    if (!btn) return;
    const action = btn.dataset.action;
    if (action === "apply") {
      applySuggestionToIssue(span);
    } else if (action === "ignore") {
      ignoreIssueSpan(span);
    }
    hideIssueTooltip();
  });

  // Temporarily add to document to measure height
  document.body.appendChild(tooltip);

  // Position above the highlighted word (or below if there's no room)
  const rect      = span.getBoundingClientRect();
  const tooltipRect = tooltip.getBoundingClientRect();
  let top = rect.top - tooltipRect.height - 6;
  if (top < 0) {
    top = rect.bottom + 6;
  }
  tooltip.style.left = `${rect.left}px`;
  tooltip.style.top  = `${top}px`;

  // Animate in
  requestAnimationFrame(() => {
    tooltip.style.opacity = "1";
    tooltip.style.transform = "translateY(0)";
  });

  activeIssueTooltip = { element: tooltip, target: span };
}

// Server-driven spell + UK issue highlighter.  This function collects all
// unique words from the given root, calls the Flask backend to classify
// each word, then rebuilds the DOM to highlight only those words flagged
// as UK or spelling issues.  Words classified as "ok_general" or
// "ok_uk" remain untouched.  Suggestions (if provided by the server)
// are attached via data attributes and titles on the span.
async function markAllIssuesServer(root) {
  if (!root) return;
  // If this page is loaded via the file:// protocol (no server running),
  // gracefully skip the backend call.  We still strip any old highlight
  // spans and update the counters to avoid stale indicators.  Without a
  // running Flask server, calling fetch("/spellcheck") would fail.
  if (window.location.protocol === "file:") {
    stripColoursAndIssueMarks(root);
    updateIssueCounters();
    return;
  }
  // Collect all candidate words from text nodes.  We ignore existing
  // spans so that we don't accidentally include previously highlighted
  // words.
  const wordSet = new Set();
  const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null);
  let currentNode = walker.nextNode();
  while (currentNode) {
    const text = currentNode.textContent || "";
    const matches = text.match(/[A-Za-z']+/g);
    if (matches) {
      matches.forEach((m) => {
        const lower = m.trim().toLowerCase();
        if (lower && !ignoredWords.has(lower) && !SAFE_WORDS.has(lower)) {
          wordSet.add(lower);
        }
      });
    }
    currentNode = walker.nextNode();
  }
  if (wordSet.size === 0) {
    updateIssueCounters();
    return;
  }
  let statusMap = {};
  let suggestionMap = {};
  try {
    // Build an absolute URL to the spellcheck endpoint.  When running
    // behind Flask this resolves correctly; for file:// pages this code
    // path is never hit due to the early return above.
    const endpoint = SPELLCHECK_URL;
    const response = await fetch(endpoint, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ words: Array.from(wordSet) }),
    });
    const json = await response.json();
    if (json && Array.isArray(json.results)) {
      json.results.forEach((item) => {
        const w = (item.word || "").toLowerCase();
        statusMap[w] = item.status || "unknown";
        if (item.suggestion) {
          suggestionMap[w] = item.suggestion;
        }
      });
    }
  } catch (err) {
    console.error("Server spellcheck failed:", err);
    updateIssueCounters();
    return;
  }
  // Remove previous issue wrappers and colour styling
  stripColoursAndIssueMarks(root);
  // Walk the DOM and rebuild text nodes where necessary
  function processNode(node) {
    if (node.nodeType === Node.TEXT_NODE) {
      const text = node.textContent || "";
      if (!/[A-Za-z]/.test(text)) return;
      const wordRegex = /[A-Za-z']+/g;
      let match;
      let lastIndex = 0;
      let frag = document.createDocumentFragment();
      let hasIssue = false;
      while ((match = wordRegex.exec(text)) !== null) {
        const word = match[0];
        const index = match.index;
        if (index > lastIndex) {
          frag.appendChild(document.createTextNode(text.slice(lastIndex, index)));
        }
        const lower = word.toLowerCase();
        const status = statusMap[lower];
        if (!ignoredWords.has(lower) && !SAFE_WORDS.has(lower) &&
            (status === "uk_issue" || status === "spell_issue")) {
          hasIssue = true;
          const span = document.createElement("span");
          span.className = status === "uk_issue" ? "uk-issue" : "spell-issue";
          span.textContent = word;
          span.dataset.word = lower;
          const suggestion = suggestionMap[lower];
          if (suggestion && suggestion.toLowerCase() !== lower) {
            span.dataset.suggestion = suggestion;
            span.title = status === "uk_issue"
              ? "UK spelling suggestion: " + suggestion
              : "Suggestion: " + suggestion;
          } else {
            span.title = status === "uk_issue"
              ? "Check UK spelling"
              : "Check spelling";
          }
          frag.appendChild(span);
        } else {
          frag.appendChild(document.createTextNode(word));
        }
        lastIndex = index + word.length;
      }
      if (lastIndex < text.length) {
        frag.appendChild(document.createTextNode(text.slice(lastIndex)));
      }
      if (hasIssue) {
        const parent = node.parentNode;
        if (parent) {
          parent.replaceChild(frag, node);
          parent.normalize();
        }
      }
    } else if (node.nodeType === Node.ELEMENT_NODE) {
      // Skip any spans we've already created
      if (
        node.classList &&
        (node.classList.contains("spell-issue") || node.classList.contains("uk-issue"))
      ) {
        return;
      }
      Array.from(node.childNodes).forEach(processNode);
    }
  }
  processNode(root);
  updateIssueCounters();
}

// END Spellchecker Module Integration

// --- Phone digital clock: sync with system time ---
(function setupPhoneClock() {
  const timeEl = document.querySelector(".phone-time");
  if (!timeEl) return;

  function updatePhoneTime() {
    const now = new Date();
    // Format as HH:MM (24-hour to stay clean in a UI / training tool)
    const hours = now.getHours().toString().padStart(2, "0");
    const minutes = now.getMinutes().toString().padStart(2, "0");
    timeEl.textContent = `${hours}:${minutes}`;
  }

  updatePhoneTime();
  // Update every 30 seconds so it stays reasonably in sync without spamming
  setInterval(updatePhoneTime, 30000);
})();


  // --- Delayed tooltips for issue counters + hints toggle ---
  (function setupCheckerTooltips() {
    const targets = document.querySelectorAll('[data-tooltip]');
    if (!targets.length) return;

    const bubble = document.createElement('div');
    bubble.className = 'soft-tooltip';
    document.body.appendChild(bubble);

    let hideTimeout = null;

    function hideBubble() {
      if (hideTimeout) {
        window.clearTimeout(hideTimeout);
        hideTimeout = null;
      }
      bubble.classList.remove('visible');
    }

    targets.forEach((el) => {
      let showTimeout = null;

      function clearShowTimeout() {
        if (showTimeout) {
          window.clearTimeout(showTimeout);
          showTimeout = null;
        }
      }

      el.addEventListener('mouseenter', () => {
        const text = el.getAttribute('data-tooltip');
        if (!text) return;

        clearShowTimeout();
        showTimeout = window.setTimeout(() => {
          bubble.innerHTML = text;
          bubble.style.display = 'block';

          // Position above the element, centered
          const rect = el.getBoundingClientRect();
          const bubbleRect = bubble.getBoundingClientRect();
          let top = rect.top - bubbleRect.height - 10;
          let left = rect.left + rect.width / 2 - bubbleRect.width / 2;

          // Keep within viewport bounds a bit
          top = Math.max(8, top);
          left = Math.max(8, Math.min(left, window.innerWidth - bubbleRect.width - 8));

          bubble.style.top = top + 'px';
          bubble.style.left = left + 'px';

          bubble.classList.add('visible');
        }, 2000); // 2 second hover delay
      });

      el.addEventListener('mouseleave', () => {
        clearShowTimeout();
        hideTimeout = window.setTimeout(hideBubble, 60);
      });

      el.addEventListener('blur', () => {
        clearShowTimeout();
        hideTimeout = window.setTimeout(hideBubble, 60);
      });
    });

    window.addEventListener('scroll', hideBubble);
  })();
</script>

<script>
/* MLCX Brain module: internal analysis engine (no UI impact) */
const mlcxBrain = (function(){
  const libraries = {
    emotion: [
      { phrase:"upset", tag:"emotion" },
      { phrase:"angry", tag:"emotion" },
      { phrase:"annoyed", tag:"emotion" },
      { phrase:"frustrated", tag:"emotion" },
      { phrase:"worried", tag:"emotion" },
      { phrase:"anxious", tag:"emotion" },
      { phrase:"stressed", tag:"emotion" },
      { phrase:"disappointed", tag:"emotion" },
      { phrase:"let down", tag:"emotion" },
      { phrase:"unhappy", tag:"emotion" },
      { phrase:"panic", tag:"emotion" },
      { phrase:"furious", tag:"emotion" },
      { phrase:"irritated", tag:"emotion" },
      { phrase:"concerned", tag:"emotion" },
      { phrase:"overwhelmed", tag:"emotion" }
    ],
    clarity: [
      { phrase:"not sure", tag:"clarity" },
      { phrase:"confused", tag:"clarity" },
      { phrase:"don't understand", tag:"clarity" },
      { phrase:"do not understand", tag:"clarity" },
      { phrase:"unclear", tag:"clarity" },
      { phrase:"what does that mean", tag:"clarity" },
      { phrase:"lost", tag:"clarity" },
      { phrase:"explain again", tag:"clarity" },
      { phrase:"can you clarify", tag:"clarity" },
      { phrase:"how does that work", tag:"clarity" },
      { phrase:"i don't follow", tag:"clarity" }
    ],
    cxRisk: [
      { phrase:"liability", tag:"cxRisk", weight:2 },
      { phrase:"excess", tag:"cxRisk" },
      { phrase:"premium", tag:"cxRisk" },
      { phrase:"deductible", tag:"cxRisk" },
      { phrase:"penalty", tag:"cxRisk" },
      { phrase:"surcharge", tag:"cxRisk" },
      { phrase:"fees", tag:"cxRisk" },
      { phrase:"hidden costs", tag:"cxRisk", weight:2 },
      { phrase:"termination", tag:"cxRisk", weight:2 },
      { phrase:"breach", tag:"cxRisk", weight:2 },
      { phrase:"escalate", tag:"cxRisk" },
      { phrase:"escalation", tag:"cxRisk" },
      { phrase:"downtime", tag:"cxRisk", weight:2 },
      { phrase:"outage", tag:"cxRisk", weight:2 },
      { phrase:"compliance risk", tag:"cxRisk", weight:3 },
      { phrase:"legal risk", tag:"cxRisk", weight:3 },
      { phrase:"regulatory", tag:"cxRisk", weight:2 },
      { phrase:"contractual", tag:"cxRisk" },
      { phrase:"costly", tag:"cxRisk" },
      { phrase:"can't afford", tag:"cxRisk", weight:3 },
      { phrase:"cannot afford", tag:"cxRisk", weight:3 },
      { phrase:"expensive", tag:"cxRisk" },
      { phrase:"charges", tag:"cxRisk" }
    ],
    civc: [
      { phrase:"hospital", tag:"civc" },
      { phrase:"can't afford", tag:"civc", weight:3 },
      { phrase:"cannot afford", tag:"civc", weight:3 },
      { phrase:"lost job", tag:"civc", weight:3 },
      { phrase:"job loss", tag:"civc", weight:3 },
      { phrase:"financial hardship", tag:"civc", weight:3 },
      { phrase:"mental health", tag:"civc", weight:2 },
      { phrase:"disability", tag:"civc" },
      { phrase:"mobility issues", tag:"civc" },
      { phrase:"wheelchair", tag:"civc" },
      { phrase:"carer", tag:"civc" },
      { phrase:"caregiver", tag:"civc" },
      { phrase:"domestic abuse", tag:"civc", weight:3 },
      { phrase:"homeless", tag:"civc", weight:3 },
      { phrase:"evicted", tag:"civc", weight:3 },
      { phrase:"eviction", tag:"civc", weight:3 },
      { phrase:"bereavement", tag:"civc", weight:2 },
      { phrase:"grief", tag:"civc", weight:2 },
      { phrase:"recent death", tag:"civc", weight:3 },
      { phrase:"suicidal", tag:"civc", weight:4 },
      { phrase:"depressed", tag:"civc", weight:3 },
      { phrase:"anxiety", tag:"civc" },
      { phrase:"medical bills", tag:"civc" },
      { phrase:"medicine", tag:"civc" },
      { phrase:"prescription", tag:"civc" },
      { phrase:"rent", tag:"civc" },
      { phrase:"mortgage", tag:"civc" },
      { phrase:"food bank", tag:"civc" },
      { phrase:"shelter", tag:"civc" },
      { phrase:"addiction", tag:"civc", weight:3 }
    ]
  };

  function normalise(text){
    return (text || "")
      .toLowerCase()
      .normalize("NFKC")
      .replace(/\s+/g," ")
      .trim();
  }

  function buildRegex(phrase){
    const escaped = phrase.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    // For multi-word phrases allow simple substring match (no word boundaries)
    if (/\s/.test(phrase)){
      return new RegExp(escaped, "i");
    }
    return new RegExp("\\b" + escaped + "\\b","i");
  }

  function scoreCategory(hits){
    const base = hits.reduce((sum,h)=> sum + (h.weight || 1), 0);
    // Scale: each weight unit ~12 points, cap at 100
    return Math.min(100, Math.round(base * 12));
  }

  function runCategory(text, library){
    const hits = [];
    library.forEach(entry=>{
      const rx = entry._rx || (entry._rx = buildRegex(entry.phrase));
      if (rx.test(text)){
        hits.push({ phrase: entry.phrase, tag: entry.tag, weight: entry.weight || 1 });
      }
    });
    return { score: scoreCategory(hits), hits };
  }

  function analyse(rawText){
    const t = normalise(rawText);
    return {
      emotion: runCategory(t, libraries.emotion),
      clarity: runCategory(t, libraries.clarity),
      cxRisk:  runCategory(t, libraries.cxRisk),
      civc:    runCategory(t, libraries.civc)
    };
  }

  // Expose public API
  return {
    libraries,
    analyse,
    runCategory, // optional direct access
    normalise
  };
})();

/* Phase 2 + 3: MLCX deep signal analysis + Notepad integration (no UI changes) */
// Encapsulated state + analysis utilities (namespaced, minimal global exposure)
(function(){
  // In-memory shared state (updated via recomputeMlcxState)
  let mlcxState = {
    sourceText: { customer: "", agent: "", agentNotes: "" }, // Phase 19.20: agentNotes = MLCX notepad text
    categories: {
      emotion: { count: 0, snippets: [], chips: [] },
      clarity: { count: 0, snippets: [], chips: [] },
      cxRisk:  { count: 0, snippets: [], chips: [] },
      safety:  { count: 0, snippets: [], chips: [] }
    },
    severityBand: "low",
    vulnerability: { hasFlag: false, severity: "none", categories: [], phrases: [], notes: "" },
    allChips: [],
    highRiskSnippets: []
  };

  // Phase 14: Central config for tweakable parameters (defaults preserve existing behaviour)
  const mlcxConfig = {
    severityBands: { lowMax: 2, mediumMax: 6 }, // previously: medium >=3 (>2), high >=7 (>6)
    maxSnippetsPerCategory: 5, // previously hard-coded during rendering
    snippetRadius: 60 // previously pad = 60 in extractSnippet
    // future: weights per category, dynamic scaling, etc.
  };

  // CX drawer targeting state + filter helper (Messenger drawer only)
  // - cxDrawerTarget tracks which speaker is shown in the CX drawer
  // - filterMlcxStateBySource derives a per-source view without mutating mlcxState
  // - updateCxDrawerFromMlcxState() rerenders the drawer using the filtered view
  let cxDrawerTarget = "customer"; // "customer" | "agent"

  function filterMlcxStateBySource(state, sourceKey){
    const safeState = state || {};
    const source = sourceKey === "agent" ? "agent" : "customer";
    const filteredCategories = {};
    const categories = ["emotion", "clarity", "cxRisk", "safety"];

    categories.forEach(cat => {
      const catState = safeState.categories?.[cat] || {};
      const filteredSnippets = (catState.snippets || [])
        .filter(snip => (typeof snip === "object" && snip?.source) ? snip.source === source : false)
        .slice(0, mlcxConfig.maxSnippetsPerCategory);

      filteredCategories[cat] = {
        ...catState,
        chips: [],
        snippets: filteredSnippets,
        count: filteredSnippets.length
      };
    });

    const totalSignals = Object.values(filteredCategories).reduce((sum, cat) => sum + (cat.count || 0), 0);
    let severityBand = "low";
    const sb = mlcxConfig.severityBands;
    if (totalSignals > sb.mediumMax) severityBand = "high"; else if (totalSignals > sb.lowMax) severityBand = "medium";

    const safetySnippets = filteredCategories.safety?.snippets || [];
    const vulnCategories = [...new Set(safetySnippets.map(sn => sn.tag).filter(Boolean))];
    const vulnerabilityNote = safetySnippets.length > 0
      ? (source === "agent"
        ? "Agent draft references potential vulnerability themes - adjust tone or signpost support."
        : "Customer may need additional support or vulnerability considerations.")
      : "";

    const vulnerability = {
      hasFlag: safetySnippets.length > 0,
      severity: safetySnippets.length >= 3 ? "high" : safetySnippets.length >= 1 ? "medium" : "none",
      categories: vulnCategories,
      phrases: safetySnippets.slice(0, 3).map(sn => (sn && (sn.text || sn.phrase || "")) || "").filter(Boolean),
      notes: vulnerabilityNote
    };

    return {
      sourceText: {
        customer: source === "customer" ? (safeState.sourceText?.customer || "") : "",
        agent: source === "agent" ? (safeState.sourceText?.agent || "") : "",
        agentNotes: safeState.sourceText?.agentNotes || "",
        notes: ""
      },
      brainV2: (safeState.brainV2 ? (source === "agent" ? safeState.brainV2.agent : safeState.brainV2.customer) : null),
      categories: filteredCategories,
      severityBand,
      vulnerability
    };
  }

  // Phase 11: In-memory snapshot history (max 20 entries)
  const mlcxSnapshots = [];
  let lastSnapshotSeverity = null;

  function pushMlcxSnapshot(state){
    const now = new Date();
    const timeStr = now.toLocaleTimeString("en-GB", { hour: "2-digit", minute: "2-digit" });
    const totals = {
      emotion: state.categories.emotion.count || 0,
      clarity: state.categories.clarity.count || 0,
      cxRisk:  state.categories.cxRisk.count || 0,
      safety:  state.categories.safety.count || 0
    };

    // Only snapshot if severity changed or this is the first snapshot
    if (lastSnapshotSeverity !== state.severityBand || mlcxSnapshots.length === 0){
      mlcxSnapshots.push({
        timestamp: timeStr,
        severityBand: state.severityBand,
        totals
      });
      lastSnapshotSeverity = state.severityBand;

      // Keep max 20 entries
      if (mlcxSnapshots.length > 20){
        mlcxSnapshots.shift();
      }
    }
  }

  // Trigger libraries (regex patterns tuned for broad, plain-language matching)
  // Added optional weighting for future severity refinement.
  const emotionTriggers = [
    { pattern: /\bfrustrat(?:ed|ing|ion)\b/i, tag: "frustration", weight: 2 },
    { pattern: /\bangry\b|\bfurious\b|\birritated\b|\bannoyed\b/i, tag: "anger", weight: 2 },
    { pattern: /\bupset\b|let down|disappoint(?:ed|ing|ment)/i, tag: "upset", weight: 1 },
    { pattern: /\banxious\b|anxiety|\bworr(?:y|ied)\b|\bstressed\b|\boverwhelmed\b|\bpanic\b/i, tag: "anxiety", weight: 2 },
    { pattern: /\b(relieved|that helps|thank you|appreciate it)\b/i, tag: "relief", weight: 1 }
  ];

  const clarityTriggers = [
    { pattern: /not sure|\bunsure\b/i, tag: "uncertainty", weight: 1 },
    { pattern: /\bconfus(?:ed|ing|ion)\b/i, tag: "confusion", weight: 2 },
    { pattern: /don't understand|do not understand|can't understand|cannot understand/i, tag: "understanding", weight: 2 },
    { pattern: /\bunclear\b|makes no sense|doesn't make sense|does not make sense/i, tag: "unclear", weight: 2 },
    { pattern: /explain again|can you explain|can you clarify|clarify that|how does that work|i don't follow|i do not follow/i, tag: "clarify", weight: 1 },
    { pattern: /what does that mean|meaning of that/i, tag: "meaning", weight: 1 }
  ];

  const cxRiskTriggers = [
    { pattern: /\bfee[s]?\b|hidden cost[s]?|charge(?:s|d)?/i, tag: "fees", weight: 2 },
    { pattern: /\bexcess\b|\bdeductible\b|premium(?:s)?/i, tag: "policy_cost", weight: 2 },
    { pattern: /delay(?:ed|s)?|taking too long|long wait|waiting ages|still waiting/i, tag: "delay", weight: 2 },
    { pattern: /claim (?:declined|refused|denied)|won't pay|will not pay/i, tag: "claim_decline", weight: 3 },
    { pattern: /complain(?:t|ing)?|unhappy with service|poor service|bad service/i, tag: "complaint", weight: 2 },
    { pattern: /liabilit(?:y|ies)|breach|penalt(?:y|ies)|surcharge(?:s)?/i, tag: "liability", weight: 3 },
    { pattern: /can't afford|cannot afford|too expensive|costly|pricey/i, tag: "afford", weight: 3 },
    { pattern: /escalat(?:e|ion)|outage|downtime/i, tag: "escalation", weight: 2 }
  ];

  const safetyTriggers = [
    { pattern: /mental health|depressed|depression|anxiety|suicidal|stress disorder/i, tag: "mental", weight: 4 },
    { pattern: /bereavement|recent death|lost (?:my|his|her|our) (?:father|mother|mum|dad|husband|wife|child|son|daughter)/i, tag: "bereavement", weight: 3 },
    { pattern: /domestic abuse|violence at home|unsafe at home/i, tag: "safeguarding", weight: 4 },
    { pattern: /homeless|no (?:place|home)|evicted|eviction/i, tag: "housing", weight: 3 },
    { pattern: /can't afford|cannot afford|financial hardship|struggling financially|money problems|rent arrears|behind on rent/i, tag: "financial", weight: 3 },
    { pattern: /disabilit(?:y|ies)|wheelchair|mobility issues|access needs/i, tag: "disability", weight: 2 },
    { pattern: /addiction|substance (?:misuse|abuse)|alcohol problem|drug problem/i, tag: "addiction", weight: 4 },
    { pattern: /caregiver|carer|needs support|support worker/i, tag: "support", weight: 2 },
    { pattern: /hospital|medical bills|prescription|medicine/i, tag: "medical", weight: 2 }
  ];

  function htmlToPlain(html){
    return (html || "")
      .replace(/<script[\s\S]*?<\/script>/gi, "")
      .replace(/<style[\s\S]*?<\/style>/gi, "")
      .replace(/<[^>]+>/g, " ")
      .replace(/&nbsp;/gi, " ")
      .replace(/&amp;/gi, "&")
      .replace(/&lt;/gi, "<")
      .replace(/&gt;/gi, ">")
      .replace(/\s+/g, " ")
      .trim();
  }

  function extractSnippet(text, start, matchLength){
    const pad = mlcxConfig.snippetRadius; // capture context around match (configurable)
    const s = Math.max(0, start - pad);
    const e = Math.min(text.length, start + matchLength + pad);
    let snippet = text.slice(s, e).trim();
    if (snippet.length > 120){
      snippet = snippet.slice(0, 117).trim() + "…";
    }
    return snippet;
  }

  function spansOverlap(aStart,aEnd,bStart,bEnd){
    const overlap = Math.max(0, Math.min(aEnd,bEnd) - Math.max(aStart,bStart));
    const minLen = Math.min(aEnd-aStart, bEnd-bStart);
    return overlap > 0 && overlap / minLen >= 0.7; // >=70% overlap considered duplicate
  }

  function scanTriggers(text, triggers, source){
    const lower = text.toLowerCase();
    const results = [];
    const spans = []; // track accepted span ranges for dedupe
    triggers.forEach(tr => {
      const regex = tr.pattern;
      let match;
      if (regex.global) regex.lastIndex = 0;
      const collect = (mIndex, mText) => {
        const start = mIndex;
        const end = mIndex + mText.length;
        // Dedupe: skip if largely overlapping with prior accepted span
        for (let i=0;i<spans.length;i++){
          const s = spans[i];
            if (spansOverlap(start,end,s.start,s.end)) return; // discard duplicate
        }
        spans.push({ start, end });
        results.push({ tag: tr.tag, snippet: extractSnippet(lower, start, mText.length), weight: tr.weight || 1, source: source || "unknown" });
      };
      if (regex.global){
        while ((match = regex.exec(lower))){
          collect(match.index, match[0]);
        }
      } else {
        match = lower.match(regex);
        if (match){
          const idx = lower.indexOf(match[0]);
          collect(idx, match[0]);
        }
      }
    });
    return results;
  }

  function analyseMlcxSignals(customerText, agentHtml, notesText){
    const agentText = htmlToPlain(agentHtml || "");
    const notes = (notesText || "").trim();
    const cust = (customerText || "").trim();

    // Aggregate matches across three sources with source labels (Phase 16)
    const emotionHits = [
      ...scanTriggers(cust, emotionTriggers, "customer"),
      ...scanTriggers(agentText, emotionTriggers, "agent"),
      ...scanTriggers(notes, emotionTriggers, "notes")
    ];
    const clarityHits = [
      ...scanTriggers(cust, clarityTriggers, "customer"),
      ...scanTriggers(agentText, clarityTriggers, "agent"),
      ...scanTriggers(notes, clarityTriggers, "notes")
    ];
    const cxRiskHits = [
      ...scanTriggers(cust, cxRiskTriggers, "customer"),
      ...scanTriggers(agentText, cxRiskTriggers, "agent"),
      ...scanTriggers(notes, cxRiskTriggers, "notes")
    ];
    const safetyHits = [
      ...scanTriggers(cust, safetyTriggers, "customer"),
      ...scanTriggers(agentText, safetyTriggers, "agent"),
      ...scanTriggers(notes, safetyTriggers, "notes")
    ];

    // Severity based on raw hit volume (simple), could pivot to weighted later
    const totalRaw = emotionHits.length + clarityHits.length + cxRiskHits.length + safetyHits.length;
    let severityBand = "low";
    const sb = mlcxConfig.severityBands;
    if (totalRaw > sb.mediumMax) severityBand = "high"; else if (totalRaw > sb.lowMax) severityBand = "medium";

    // Phase 19.20: Build vulnerability object from safety triggers
    const vulnerability = {
      hasFlag: safetyHits.length > 0,
      severity: safetyHits.length >= 3 ? "high" : safetyHits.length >= 1 ? "medium" : "none",
      categories: [...new Set(safetyHits.map(m => m.tag))],
      phrases: safetyHits.slice(0, 3).map(m => m.snippet),
      notes: safetyHits.length > 0 ? "Customer may need additional support or vulnerability considerations." : ""
    };

    return {
      sourceText: { customer: cust, agent: agentText, notes: notes },
      categories: {
        emotion: { count: emotionHits.length, snippets: emotionHits.slice(0, mlcxConfig.maxSnippetsPerCategory).map(r=>({ text: r.snippet, tag: r.tag, source: r.source })) },
        clarity: { count: clarityHits.length, snippets: clarityHits.slice(0, mlcxConfig.maxSnippetsPerCategory).map(r=>({ text: r.snippet, tag: r.tag, source: r.source })) },
        cxRisk:  { count: cxRiskHits.length,  snippets: cxRiskHits.slice(0, mlcxConfig.maxSnippetsPerCategory).map(r=>({ text: r.snippet, tag: r.tag, source: r.source })) },
        safety:  { count: safetyHits.length,  snippets: safetyHits.slice(0, mlcxConfig.maxSnippetsPerCategory).map(r=>({ text: r.snippet, tag: r.tag, source: r.source })) }
      },
      severityBand,
      vulnerability
    };
  }

  // Accessors for current live text
  function getCustomerTextForMlcx(){
    const el = document.getElementById("customerInput");
    return el ? (el.value || "") : "";
  }

  /* CX agent-source override for Notepad */
  function getCxAgentSource() {
    const layout = document.body?.dataset?.layout;
    if (layout === "notepad" && npEditor) {
      const npClone = npEditor.cloneNode(true);
      stripColoursAndIssueMarks(npClone);
      return npClone.innerHTML || "";
    }
    if (agentInput) {
      const agentClone = agentInput.cloneNode(true);
      stripColoursAndIssueMarks(agentClone);
      return agentClone.innerHTML || "";
    }
    const el = document.getElementById("agentInput");
    return el ? (el.innerHTML || "") : "";
  }

  function getAgentTextForMlcx(){
    return getCxAgentSource();
  }
  function getMlcxNotepadText(){
    const el = document.querySelector(".mlcx-notes-input");
    return el ? (el.value || "") : "";
  }

  

  // ===============================
  // Phase 1 - MFCX Brain v2 (speaker-aware heuristics)
  // One deterministic analyzer that returns short, human coaching.
  // ===============================

  const __MFCX_V2 = {
    version: "v2.0.0-heuristic",
    // Thresholds are intentionally conservative to avoid noisy coaching.
    jargon: { lowMax: 2, mediumMax: 5 },
    delay:  { minHits: 1 },
    maxInsights: 3
  };

  function normalizeText(s){
    return (s || "")
      .replace(/\u00A0/g, " ")
      .replace(/[ \t]+/g, " ")
      .trim();
  }

  function splitSentences(s){
    const t = normalizeText(s);
    if (!t) return [];
    return t.split(/(?<=[.!?])\s+/).map(x => x.trim()).filter(Boolean);
  }

  function wordCount(s){
    const t = normalizeText(s);
    if (!t) return 0;
    return t.split(/\s+/).filter(Boolean).length;
  }

  function hasAny(re, s){
    try { return re.test(s); } catch(e){ return false; }
  }

  function countRegexHits(re, s){
    try {
      const m = s.match(re);
      return m ? m.length : 0;
    } catch(e){
      return 0;
    }
  }

  function detectDelayMentions(s){
    const t = s || "";
    const delayRe = /\b(delay(ed|s)?|longer\s+than\s+usual|taking\s+(a\s+bit\s+)?longer|holiday\s+period|festive\s+period|busy\s+(time|period)|backlog|next\s+week|within\s+\d+\s+(day|days|week|weeks)|\bETA\b)\b/i;
    return hasAny(delayRe, t);
  }

  function detectReasonGiven(s){
    const t = s || "";
    return hasAny(/\b(because|due\s+to|as\s+we('| a)?re|as\s+it's|since)\b/i, t);
  }

  function detectExpectationSet(s){
    const t = s || "";
    return hasAny(/\b(we('| a)?ll\s+(update|be\s+in\s+touch|contact\s+you)|you('| a)?ll\s+hear\s+from\s+us|by\s+(monday|tuesday|wednesday|thursday|friday|saturday|sunday|\d{1,2}\s+[a-z]{3,9})|in\s+the\s+app|by\s+email)\b/i, t);
  }

  function detectEmpathy(s){
    const t = s || "";
    return hasAny(/\b(sorry|apolog(?:y|ies|ise|ize)|hope\s+everyone'?s\s+ok|hope\s+you('| a)?re\s+ok|i\s+understand|that\s+must\s+be|thanks\s+for\s+letting\s+us\s+know)\b/i, t);
  }

  function detectNextSteps(s){
    const t = s || "";
    return hasAny(/\b(next\s+step|here('?s| is)\s+what\s+we\s+('| a)?ll\s+do|please\s+(confirm|check|send)|you\s+can\s+(do|update)|call\s+us|we\s+('| a)?ll\s+arrange|we\s+('| a)?ve\s+arranged)\b/i, t);
  }

  function detectFinancialStress(text){
    const t = (text || "").toLowerCase();
    const high = /\b(can't\s+afford|cannot\s+afford|struggling|hardship|no\s+money|lost\s+my\s+job|behind\s+on\s+payments|debt)\b/.test(t);
    const medium = /\b(afford|expensive|costly|money\s+worries|financial|bills|payment\s+plan|overdraft)\b/.test(t);
    const low = /\b(excess|fee|charge|charged|cost|price|pricing|quote|valuation)\b/.test(t);
    const level = high ? "high" : medium ? "medium" : low ? "low" : "none";
    const hits = [];
    if (high) hits.push("high");
    else if (medium) hits.push("medium");
    else if (low) hits.push("low");
    return { level, hits };
  }


// Phase 4: Money clarity coaching helpers (who pays what + what's covered)
function detectMoneyMentions(text){
  const t = (text || "").toLowerCase();
  return /\b(excess|fee|fees|charge|charged|cost|costs|price|pay|payment|paid|payout|settlement|valuation|quote|refund|finance|instal+ments?|owe|outstanding|premium|renewal|no\s+claims)\b/.test(t)
    || /[£$€]\s*\d/.test(text || "");
}

function detectAmountPresent(text){
  const raw = text || "";
  const t = raw.toLowerCase();
  if (/[£$€]\s*\d/.test(raw)) return true;
  if (/\b(£|gbp|pounds?|pence|dollars?|usd|euros?|eur)\b/.test(t) && /\d/.test(t)) return true;
  if (/\b(excess|fee|charge|cost|pay|payment|settlement)\b/.test(t) && /\b\d{2,6}(?:\.\d{2})?\b/.test(t)) return true;
  return false;
}

function detectPayerPayeePresent(text){
  const t = (text || "").toLowerCase();
  const payer = /\b(you('|\s)?ll\s+pay|you\s+will\s+pay|pay\s+this\s+to|we('|\s)?ll\s+pay|we\s+will\s+pay|we\s+cover|covered\s+by\s+us|we\s+will\s+cover|we\s+won't\s+cover|not\s+covered)\b/.test(t);
  const payee = /\b(to\s+national\s+windscreens|to\s+enterprise|to\s+copart|to\s+the\s+garage|to\s+the\s+repairer|to\s+the\s+other\s+driver('|\s)?s\s+insurer|to\s+their\s+insurer|to\s+the\s+finance\s+company)\b/.test(t);
  return payer || payee;
}

function detectCoverageLinePresent(text){
  const t = (text || "").toLowerCase();
  return /\b(covered|not\s+covered|included|we('|\s)?ll\s+handle|we\s+will\s+handle|we\s+can\s+cover|we\s+won't\s+cover|only\s+need\s+to\s+pay|excess\s+waived|won't\s+affect\s+your\s+no\s+claims|no\s+claims\s+discount)\b/.test(t);
}

function assessMoneyClarity(text){
  const mentions = detectMoneyMentions(text);
  if (!mentions) return { mentions:false, amount:false, payer:false, coverage:false, clarity:"ok", missing:[] };

  const amount = detectAmountPresent(text);
  const payer = detectPayerPayeePresent(text);
  const coverage = detectCoverageLinePresent(text);
  const missing = [];
  if (!amount) missing.push("amount");
  if (!payer) missing.push("who pays");
  if (!coverage) missing.push("what’s covered");

  const score = (amount?1:0) + (payer?1:0) + (coverage?1:0);
  let clarity = "ok";
  if (score <= 1) clarity = "missing";
  else if (score === 2) clarity = "partial";

  return { mentions:true, amount, payer, coverage, clarity, missing };
}

    function scanJargon(text){
    const t = text || "";
    const tLower = t.toLowerCase();
    const wc = wordCount(t);

    // Known acronyms / shorthand we see in claims messaging.
    // Purpose: nudge “spell it out once, then shorten”.
    const ACR = {
      "NCD":  { label: "no claims discount", variants: ["no claims discount", "no-claims discount", "no claims bonus", "no-claims bonus"] },
      "NCB":  { label: "no claims discount", variants: ["no claims bonus", "no-claims bonus", "no claims discount", "no-claims discount"] },
      "FNOL": { label: "first notification of loss", variants: ["first notification of loss", "first notification", "when you first told us", "when you first reported", "when you first notified us"] },
      "TPI":  { label: "the other driver’s insurer", variants: ["third party insurer", "third-party insurer", "other driver’s insurer", "other driver's insurer", "the other driver’s insurer", "the other driver's insurer"] },
      "TL":   { label: "total loss (written off)", variants: ["total loss", "written off", "write off", "write-off", "written-off"] },
      "T/L":  { label: "total loss (written off)", variants: ["total loss", "written off", "write off", "write-off", "written-off"] },
      "TPFT": { label: "third party, fire and theft", variants: ["third party fire and theft", "third party, fire and theft", "fire and theft"] },
      "TPO":  { label: "third party only", variants: ["third party only"] },
      "V5C":  { label: "V5C logbook (registration document)", variants: ["v5c", "logbook", "registration document", "vehicle registration document", "v5c logbook"] },
      "CAT S":{ label: "Category S (structural damage)", variants: ["category s", "cat s", "structural damage"] },
      "CAT N":{ label: "Category N (non‑structural damage)", variants: ["category n", "cat n", "non-structural damage", "non structural damage"] }
    };

    const specs = (typeof jargonPatterns !== "undefined" && Array.isArray(jargonPatterns)) ? jargonPatterns : [];

    let total = 0;
    let unexplained = 0;
    let unexplainedAcronyms = 0;

    // Keep examples for coaching (“spell it out once…”)
    const examples = [];

    const hasMeans = /\b(means|stands\s+for|that\s+is|i\.e\.|in\s+other\s+words)\b/i.test(t);

    function isAcronymLike(token){
      if (!token) return false;
      if (/^\b[A-Z]{2,6}\b$/.test(token)) return true;
      if (/^\b[A-Z]\d[A-Z0-9]{1,5}\b$/.test(token)) return true;  // V5C-ish
      if (/^\b[A-Z]{1,3}\/[A-Z]{1,3}\b$/.test(token)) return true; // T/L-ish
      return false;
    }

    function normaliseAcrKey(raw){
      const s = (raw || "").trim();
      const upper = s.toUpperCase();

      // Category shorthand (Cat S / Category S)
      if (/^CAT(?:EGORY)?\s*S$/.test(upper)) return "CAT S";
      if (/^CAT(?:EGORY)?\s*N$/.test(upper)) return "CAT N";

      // Normal acronyms
      if (upper === "T/L") return "T/L";
      return upper;
    }

    function hasGlobalExpansion(key){
      const spec = ACR[key];
      if (!spec) return false;

      // For V5C we allow “logbook” etc; for others we look for a plain expansion phrase.
      return (spec.variants || []).some(v => v && tLower.includes(v.toLowerCase()));
    }

    function hasLocalExpansion(afterSlice){
      // If they write “TPI (third party insurer)” or “TPI – the other driver’s insurer”
      if (!afterSlice) return false;
      return (
        /\(\s*[a-z][^)]{2,}\)/i.test(afterSlice) ||
        /[-–:]\s*[a-z]/i.test(afterSlice)
      );
    }

    function recordExample(acrKey){
      if (!ACR[acrKey]) return;
      if (examples.some(x => x.acronym === acrKey)) return;
      examples.push({ acronym: acrKey, expansion: ACR[acrKey].label });
    }

    specs.forEach(spec => {
      if (!spec || !spec.pattern) return;

      let re = spec.pattern;
      // Ensure global for matchAll
      if (!re.global){
        try { re = new RegExp(re.source, re.flags + "g"); } catch(e){ /* ignore */ }
      }

      let match;
      try {
        while ((match = re.exec(t)) !== null){
          const term = match[0];
          const idx = match.index || 0;

          total += 1;

          const after = t.slice(idx + term.length, idx + term.length + 90);
          const acrKey = normaliseAcrKey(term);

          // Decide if this hit is an “acronym/shorthand” worth the “spell it out once” nudge.
          const isAcr = isAcronymLike(term) || (acrKey in ACR) || /^CAT(?:EGORY)?\s+[SN]$/i.test(term);

          // Explained if:
          //  - they’ve used “means/that is”, OR
          //  - a local expansion follows soon, OR
          //  - a plain-language expansion exists anywhere in the message.
          const explained = hasMeans || hasLocalExpansion(after) || hasGlobalExpansion(acrKey);

          if (!explained){
            unexplained += 1;

            if (isAcr){
              unexplainedAcronyms += 1;
              recordExample(acrKey);
            }
          }

          // Prevent infinite loops on zero-width matches
          if (re.lastIndex === idx) re.lastIndex++;
        }
      } catch(e){
        // If anything goes wrong, fail gracefully.
      }
    });

    // Context-based severity:
    // - Short messages amplify jargon impact.
    // - Long messages allow a bit more as long as the message stays readable.
    const densityPer100 = wc > 0 ? (total / wc) * 100 : 0;

    let severity = "none";
    if (total <= 0){
      severity = "none";
    } else if (wc <= 12){
      severity = "high"; // any jargon in a micro-message is likely confusing
    } else if (wc <= 25){
      severity = (unexplainedAcronyms >= 1 || total >= 2) ? "high" : "medium";
    } else if (wc <= 60){
      if (unexplainedAcronyms >= 2 || total >= 4) severity = "high";
      else if (unexplainedAcronyms >= 1 || total >= 2) severity = "medium";
      else severity = "low";
    } else {
      if (densityPer100 >= 6 || unexplainedAcronyms >= 2) severity = "high";
      else if (densityPer100 >= 3 || unexplainedAcronyms >= 1) severity = "medium";
      else severity = "low";
    }

    return { total, unexplained, unexplainedAcronyms, severity, densityPer100, examples: examples.slice(0, 3) };
  }

  // Phase 3: Smart replacements (copy coaching)
  // Build ONE ready-to-paste rewrite line when the message is short or jargon severity is high,
  // and we detect unexplained acronyms. This keeps coaching practical without adding UI.
  const ACR_REWRITE_PRIORITY = ["TPI","NCD","NCB","TL","T/L","FNOL","V5C","CAT S","CAT N","TPFT","TPO"];

  function escRe(s){ return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); }

  function replaceFirstCI(haystack, needle, replacement){
    if (!haystack || !needle) return haystack;
    const re = new RegExp(escRe(needle), "i");
    return haystack.replace(re, replacement);
  }

  function buildQuickRewrite(originalText, jargonSignals){
    const raw = String(originalText || "").trim();
    if (!raw) return null;

    const ex = Array.isArray(jargonSignals?.examples) ? jargonSignals.examples : [];
    if (!ex.length) return null;

    // Pick up to 2 acronyms to expand, prioritised by impact.
    const acrs = ex
      .map(x => (x && x.acronym ? String(x.acronym).toUpperCase().trim() : ""))
      .filter(Boolean);

    const picked = [];
    for (const p of ACR_REWRITE_PRIORITY){
      if (acrs.includes(p) && !picked.includes(p)) picked.push(p);
      if (picked.length >= 2) break;
    }
    // If nothing from the priority list, just take the first one.
    if (!picked.length) picked.push(acrs[0]);

    let rewritten = raw;
    for (const ac of picked){
      const exObj = ex.find(x => x && String(x.acronym || "").toUpperCase().trim() === ac);
      const expansion = (exObj && exObj.expansion) ? String(exObj.expansion) : "";
      if (!expansion) continue;

      // Default expansion format: "plain meaning (ACRONYM)"
      // Avoid doubling if the acronym already appears right next to the expansion.
      const repl = new RegExp(`\\b${escRe(ac)}\\b`, "i");
      const withAcr = expansion.toLowerCase().includes(ac.toLowerCase()) ? expansion : `${expansion} (${ac})`;

      // Replace first occurrence of the exact acronym token (case-insensitive).
      // For acronyms with non-word chars (e.g., T/L), fallback to simple first replace.
      if (/^[A-Z0-9]+$/.test(ac)){
        rewritten = rewritten.replace(repl, withAcr);
      } else {
        rewritten = replaceFirstCI(rewritten, ac, withAcr);
      }
    }

    // Skip if nothing changed or if the rewrite becomes unwieldy.
    if (rewritten.trim() === raw.trim()) return null;
    if (rewritten.length > 260) return null;

    return rewritten;
  }
  // Main deterministic analyzer - returns structured, short coaching.
  function analyzeText(text, speaker, shared){
    const s = normalizeText(text);
    const sp = speaker === "customer" ? "customer" : "agent";
    const sentences = splitSentences(s);
    const wc = wordCount(s);

    const meta = {
      words: wc,
      sentences: sentences.length,
      hasQuestion: /\?/.test(s),
      hasEmpathy: detectEmpathy(s),
      hasNextSteps: detectNextSteps(s),
      hasReason: detectReasonGiven(s),
      hasExpectation: detectExpectationSet(s)
    };

    const signals = {
      reassuranceMissing: false,
      delayExplanationMissing: false,
      jargon: scanJargon(s),
      financialStress: detectFinancialStress(s)
    };

    const insights = [];
    const praise = [];

    // CUSTOMER: translate signals into response anchors (what to address).
    if (sp === "customer"){
      if (signals.financialStress.level !== "none"){
        insights.push("They may be worried about costs - confirm (1) the amount, (2) who pays it, and (3) what’s covered.");
      }
      if ((shared?.state?.categories?.emotion?.count || 0) > 0){
        insights.push("They’re showing frustration or stress - a calm reassurance line will help before you explain steps.");
      }
      if ((shared?.state?.categories?.safety?.count || 0) > 0){
        insights.push("Possible vulnerability signals - offer a flexible contact option (phone/app/email) and keep it simple.");
      }
      return {
        signals,
        insights: insights.slice(0, __MFCX_V2.maxInsights),
        praise,
        meta
      };
    }

    // AGENT: coaching on clarity + tone + process.
    const custNeeds = shared?.customerNeeds || {};
    const customerStress = custNeeds.financialStress?.level && custNeeds.financialStress.level !== "none";
    const customerEmotion = (shared?.state?.categories?.emotion?.count || 0) > 0;

    const mentionsDelay = detectDelayMentions(s);
    const needsReassurance = customerEmotion || customerStress || hasAny(/\b(unfortunately|total\s+loss|write\s*[- ]?off|declin(ed|e)|not\s+covered|unable|charged|fee|storage|recovery|police\s+hold|valuation|revaluation)\b/i, s);

    if (needsReassurance && !meta.hasEmpathy){
      signals.reassuranceMissing = true;
      insights.push("Add a quick reassurance line first (e.g., “Sorry this happened - we’ll help you through it.”).");
    } else if (meta.hasEmpathy && meta.hasNextSteps){
      praise.push("Nice: you’ve got empathy + clear next steps.");
    } else if (meta.hasEmpathy){
      praise.push("Nice: tone is warm - now add a clear next step.");
    }

    if (mentionsDelay){
      const missingReason = !meta.hasReason;
      const missingExpectation = !meta.hasExpectation;
      if (missingReason || missingExpectation){
        signals.delayExplanationMissing = true;
        if (missingReason && missingExpectation){
          insights.push("If there’s a delay, add a brief why + when they’ll hear from us (sets expectations, reduces chasing).");
        } else if (missingReason){
          insights.push("If you mention a delay, add a short reason (“due to the holiday period / higher claim volumes”).");
        } else {
          insights.push("If you mention a delay, add a clear timeframe (“we’ll update you by Monday / within X days”).");
        }
      }
    }
    if (signals.jargon.unexplainedAcronyms > 0){
      const ex = (signals.jargon.examples && signals.jargon.examples[0]) ? signals.jargon.examples[0] : null;
      const exampleText = ex ? ` (e.g., “${ex.expansion} (${ex.acronym})”)` : "";
      insights.push(`Acronym${signals.jargon.unexplainedAcronyms > 1 ? "s" : ""} may be unclear - spell it out once${exampleText}, then you can shorten it.`);
    } else if (signals.jargon.severity === "high" || signals.jargon.unexplained >= 2){
      insights.push("A few industry terms are creeping in - swap to plain English where you can, or explain once then shorten.");
    } else if (signals.jargon.severity === "medium"){
      insights.push("Keep jargon light - if you use an acronym, spell it out the first time.");
    } else if (signals.jargon.severity === "low" && signals.jargon.unexplained > 0){
      insights.push("Small clarity win: if you keep an acronym in, add the plain meaning once.");
    }    // Phase 3: Smart replacement (ready-to-paste) - only for agent text when message is short
    // or jargon severity is high. Keeps it strict: max 1 rewrite suggestion.
    const eligibleRewrite = (sp === "agent") && (meta.words <= 25 || signals.jargon.severity === "high") && (signals.jargon.unexplainedAcronyms > 0);
    const quickRewrite = eligibleRewrite ? buildQuickRewrite(text, signals.jargon) : null;
    if (quickRewrite){
      signals.quickRewrite = quickRewrite;
      // Preserve max 3 insights total by reserving the last slot for the rewrite.
      while (insights.length > 2) insights.pop();
      insights.push(`Quick rewrite: ${quickRewrite}`);
    }

// Phase 4: Money clarity coaching (who pays what + what’s covered)
const money = assessMoneyClarity(s);
signals.moneyClarity = money;

const shouldCoachMoney = customerStress || money.mentions || (signals.financialStress.level !== "none");

if (shouldCoachMoney){
  const missingParts = (money && money.missing && money.missing.length) ? money.missing.join(", ") : "";
  const isShort = wc <= 25;

  // Insert high priority right after reassurance (if present), otherwise at the top.
  const insertMoneyInsight = (line) => {
    if (!line) return;
    if (insights.includes(line)) return;
    const hasReassuranceLine = insights.length && /^Add a quick reassurance line/i.test(insights[0]);
    if (hasReassuranceLine) insights.splice(1, 0, line);
    else insights.unshift(line);
  };

  if (customerStress && !money.mentions){
    insertMoneyInsight("Money tip: they may be worried about costs - confirm what they’ll pay (if anything), what we’ll cover, and the next step.");
  } else if (money.clarity === "missing"){
    insertMoneyInsight(`Cost mentioned but missing key detail - add: amount, who pays, and what’s covered${missingParts ? " (missing: " + missingParts + ")" : ""}.`);
  } else if (money.clarity === "partial"){
    insertMoneyInsight(`Cost mentioned - consider adding what’s missing (${missingParts || "amount / who pays / what’s covered"}) to make it crystal clear.`);
  } else if (money.mentions && (customerStress || (signals.financialStress.level !== "none")) && isShort && !meta.hasNextSteps){
    insights.push("Nice and brief - add one clear next step so they know what happens now.");
  } else if (money.mentions && money.clarity === "ok" && (customerStress || isShort)){
    praise.push("Nice: costs are clear and easy to follow.");
  }
}

// Phase 3 guard: If a quick rewrite was generated, keep it as the last slot (max 1 rewrite).
if (signals.quickRewrite){
  const qrLine = `Quick rewrite: ${signals.quickRewrite}`;
  for (let i = insights.length - 1; i >= 0; i--){
    if (/^Quick rewrite:/i.test(insights[i])) insights.splice(i, 1);
  }
  while (insights.length > 2) insights.pop();
  insights.push(qrLine);
}

    // Trim to max insights
    const trimmed = [];
    for (const line of insights){
      if (!trimmed.includes(line)) trimmed.push(line);
      if (trimmed.length >= __MFCX_V2.maxInsights) break;
    }

    return {
      signals,
      insights: trimmed,
      praise: praise.slice(0, 1),
      meta
    };
  }

  function buildMfcxBrainV2(customerText, agentHtml, notesText, state){
    const cust = normalizeText(customerText || "");
    const agentPlain = htmlToPlain(agentHtml || "");
    const shared = { state: state || null };
    const customerNeeds = analyzeText(cust, "customer", { state: state || null });
    const agentCoach = analyzeText(agentPlain, "agent", { state: state || null, customerNeeds });

    return {
      version: __MFCX_V2.version,
      customer: customerNeeds,
      agent: agentCoach,
      meta: {
        customerWords: wordCount(cust),
        agentWords: wordCount(agentPlain),
        notesWords: wordCount(notesText || "")
      }
    };
  }


  // Phase E: Regression + release hygiene (health + safe mode)
  (function initMirrorFlowHealth(){
    const H = window.__MF_HEALTH = window.__MF_HEALTH || {};
    if (H.__init) return;
    H.__init = true;

    H.listenerCount = H.listenerCount || 0;
    H.listenerMap = H.listenerMap || {};
    H.listeners = H.listeners || [];

    H.lastRecomputeAt = H.lastRecomputeAt || 0;
    H.lastRecomputeDurationMs = H.lastRecomputeDurationMs || 0;
    H.lastInputSource = H.lastInputSource || "";

    H.errorCount = H.errorCount || 0;
    H.errorStreak = H.errorStreak || 0;
    H.errorTimes = H.errorTimes || [];
    H.errorLog = H.errorLog || [];

    // Boot safe mode option (URL: ?safe=1) OR persisted (localStorage: mfSafeMode=1)
    H.safeMode = !!(H.safeMode || (function(){
      try {
        const qs = new URLSearchParams(window.location.search || "");
        if (qs.get('safe') === '1') return true;
        if (localStorage.getItem('mfSafeMode') === '1') return true;
      } catch (e) {}
      return false;
    })());
    window.__MF_DISABLE_LIVE_ANALYSIS = !!H.safeMode;

    function shortErr(err){
      if (!err) return "(unknown error)";
      if (typeof err === 'string') return err.slice(0, 220);
      return (err.message || String(err)).slice(0, 220);
    }

    window.mfRecordError = function mfRecordError(err, where){
      try {
        const now = Date.now();
        H.errorCount += 1;
        H.errorStreak += 1;
        H.errorTimes.push(now);
        // keep last 15s
        H.errorTimes = H.errorTimes.filter(t => (now - t) <= 15000);

        const entry = {
          t: now,
          where: where || "unknown",
          msg: shortErr(err),
          stack: (err && err.stack) ? String(err.stack).slice(0, 1200) : ""
        };
        H.errorLog.push(entry);
        if (H.errorLog.length > 10) H.errorLog = H.errorLog.slice(-10);

        // Auto-safe-mode trigger: 3+ errors within 15s
        if (!H.safeMode && H.errorTimes.length >= 3){
          window.enterMirrorFlowSafeMode && window.enterMirrorFlowSafeMode("auto:" + (where || "unknown"));
        }

        if (typeof window.updateDevLabHealthPanel === 'function') window.updateDevLabHealthPanel();
      } catch (e) {
        // never throw from the recorder
      }
    };

    window.enterMirrorFlowSafeMode = function enterMirrorFlowSafeMode(reason){
      if (H.safeMode) return;
      H.safeMode = true;
      window.__MF_DISABLE_LIVE_ANALYSIS = true;
      try { localStorage.setItem('mfSafeMode', '1'); } catch (e) {}

      // Unwire any tracked listeners
      try {
        (H.listeners || []).forEach(l => {
          try { l.el && l.el.removeEventListener && l.el.removeEventListener(l.type, l.fn, l.opts); } catch (e) {}
        });
        H.listeners = [];
      } catch (e) {}

      try {
        if (typeof showToast === 'function') showToast(`Safe mode enabled (${reason || 'auto'})`, 'warn');
      } catch (e) {}

      if (typeof window.updateDevLabHealthPanel === 'function') window.updateDevLabHealthPanel();
    };

    window.exitMirrorFlowSafeMode = function exitMirrorFlowSafeMode(){
      H.safeMode = false;
      window.__MF_DISABLE_LIVE_ANALYSIS = false;
      H.errorStreak = 0;
      H.errorTimes = [];
      try { localStorage.removeItem('mfSafeMode'); } catch (e) {}
      try { if (typeof showToast === 'function') showToast('Safe mode disabled', 'info'); } catch (e) {}
      // Note: live listeners will be re-wired on next reload or when wireLiveUpdates runs again.
      if (typeof window.updateDevLabHealthPanel === 'function') window.updateDevLabHealthPanel();
    };

    window.mfWire = function mfWire(el, type, handler, opts, label){
      if (!el || !el.addEventListener) return;
      const tag = label || type;
      const wrapped = function(ev){
        H.lastInputSource = tag;
        try { return handler.call(this, ev); }
        catch (err){ window.mfRecordError && window.mfRecordError(err, 'listener:' + tag); }
      };
      try { el.addEventListener(type, wrapped, opts); } catch (e) { return; }
      H.listenerCount += 1;
      H.listenerMap[tag] = (H.listenerMap[tag] || 0) + 1;
      H.listeners.push({ el, type, fn: wrapped, opts, label: tag });
      return wrapped;
    };

    // Global error hooks (keep lightweight)
    window.addEventListener('error', (e) => {
      window.mfRecordError && window.mfRecordError(e && (e.error || e.message), 'window:error');
    });
    window.addEventListener('unhandledrejection', (e) => {
      window.mfRecordError && window.mfRecordError(e && e.reason, 'window:unhandledrejection');
    });

    // Dev Lab health UI updater (no-op outside Dev Lab)
    window.updateDevLabHealthPanel = function updateDevLabHealthPanel(){
      const card = document.getElementById('devHealthCard');
      if (!card) return;
      const statusEl = document.getElementById('devHealthStatus');
      const listenersEl = document.getElementById('devHealthListeners');
      const safeEl = document.getElementById('devHealthSafeMode');
      const lastRecEl = document.getElementById('devHealthLastRecompute');
      const lastSrcEl = document.getElementById('devHealthLastSource');
      const errBox = document.getElementById('devHealthErrors');

      const ok = !H.safeMode && (H.errorTimes || []).length === 0;
      const warn = !H.safeMode && (H.errorTimes || []).length > 0;
      const bad = H.safeMode;

      if (statusEl){
        statusEl.textContent = bad ? 'SAFE MODE' : (warn ? 'WARN' : 'OK');
        statusEl.classList.toggle('is-warn', warn);
        statusEl.classList.toggle('is-bad', bad);
      }
      if (listenersEl) listenersEl.textContent = String(H.listenerCount || 0);
      if (safeEl) safeEl.textContent = H.safeMode ? 'ON (live analysis disabled)' : 'OFF';

      const t = H.lastRecomputeAt || 0;
      if (lastRecEl){
        if (!t) lastRecEl.textContent = '-';
        else {
          const age = Math.max(0, Date.now() - t);
          const sec = Math.round(age/100)/10;
          const hhmm = new Date(t).toLocaleTimeString();
          const dur = (H.lastRecomputeDurationMs || 0).toFixed(1);
          lastRecEl.textContent = `${hhmm} (${sec}s ago · ${dur}ms)`;
        }
      }
      if (lastSrcEl) lastSrcEl.textContent = H.lastInputSource || '-';

      if (errBox){
        const recent = (H.errorLog || []).slice(-5);
        if (!recent.length){
          errBox.style.display = 'none';
        } else {
          errBox.style.display = '';
          errBox.textContent = recent.map(e => {
            const ts = new Date(e.t).toLocaleTimeString();
            return `[${ts}] ${e.where}: ${e.msg}`;
          }).join('\n');
        }
      }
    };

  })();



function recomputeMlcxState(source){
    const H = window.__MF_HEALTH || (window.__MF_HEALTH = {});
    const t0 = (window.performance && performance.now) ? performance.now() : Date.now();

    H.lastInputSource = source || H.lastInputSource || "manual";

    // Safe mode: allow manual runs, but block live auto-recompute
    if (window.__MF_DISABLE_LIVE_ANALYSIS && source && source !== 'manual' && source !== 'init'){
      if (typeof window.updateDevLabHealthPanel === 'function') window.updateDevLabHealthPanel();
      return mlcxState;
    }

    try {
      const customerRaw = getCustomerTextForMlcx();
      const agentRaw = getAgentTextForMlcx();
      const notesRaw = getMlcxNotepadText();
      mlcxState = analyseMlcxSignals(customerRaw, agentRaw, notesRaw); // replace state (immutable semantics)

      // Phase 19.20: Ensure sourceText includes agentNotes for consistency
      mlcxState.sourceText.agentNotes = notesRaw;

      // Phase 1: build speaker-aware heuristics (Brain v2)
      try {
        mlcxState.brainV2 = buildMfcxBrainV2(customerRaw, agentRaw, notesRaw, mlcxState);
        window.mfcxBrainV2 = mlcxState.brainV2; // optional Dev Lab access
      } catch (e) {
        console.warn("[MFCX Brain v2] build failed:", e);
      }

      console.log("[MLCX Phase 19.20]", {
        severity: mlcxState.severityBand,
        emotion: mlcxState.categories.emotion.count,
        clarity: mlcxState.categories.clarity.count,
        cxRisk:  mlcxState.categories.cxRisk.count,
        safety:  mlcxState.categories.safety.count,
        vulnerability: mlcxState.vulnerability?.hasFlag || false,
        sources: mlcxState.sourceText
      });

      // Phase 17: unified snapshot renderer (keeps Notepad + CX drawer in perfect sync)
      refreshAllMlcxSurfaces();

      // Phase 4: feed state into hidden CX drawer bridge (for detailed sections 2-4)
      updateCxDrawerFromMlcxState(mlcxState);

      // Phase 11: snapshot history tracking (if severity changed)
      pushMlcxSnapshot(mlcxState);

      // Phase 19: refresh Dev Lab if in dev layout
      if (typeof window.refreshDevLabContent === "function" && document.body.dataset.layout === "dev"){
        setTimeout(window.refreshDevLabContent, 50);
      }

      H.lastRecomputeAt = Date.now();
      H.lastRecomputeDurationMs = ((window.performance && performance.now) ? performance.now() : Date.now()) - t0;
      H.errorStreak = 0;

      if (typeof window.updateDevLabHealthPanel === 'function') window.updateDevLabHealthPanel();
      return mlcxState;

    } catch (err) {
      H.lastRecomputeAt = Date.now();
      H.lastRecomputeDurationMs = ((window.performance && performance.now) ? performance.now() : Date.now()) - t0;
      if (typeof window.mfRecordError === 'function') window.mfRecordError(err, 'recompute:' + (source || 'manual'));
      if (typeof window.updateDevLabHealthPanel === 'function') window.updateDevLabHealthPanel();
      return mlcxState;
    }
  }

  // ========================================
  // <!-- MF:PHASE F (Event Storm Control) -->
  // <!-- MF:OWNER:PHASE_F_SCHEDULER  |  Do not duplicate this block. -->
  // ========================================
  // [MF:PHASE-F] Canonical heavy recompute scheduler (SINGLE ENTRY POINT)
  // PURPOSE: Stop event storm by routing ALL heavy analysis through ONE debounced pipeline
  // ENTRY POINTS:
  //   - scheduleRecompute(reason) — 160ms trailing debounce on input/compositionend
  //   - runRecomputeNow(reason) — immediate execution on blur/commit/button actions
  // HEAVY PIPELINE: mainHeavyRecomputePipeline(snapshot, reason)
  //   - Runs: Writer Insights (role-aware) + MLCX state recompute (multi-pass analysis)
  //   - Called ONLY by: runRecompute() or runRecomputeNow()
  // IME GUARD: window.__mf_isComposing = true prevents heavy work during IME composition
  //   - Set by: compositionstart handlers (all inputs)
  //   - Cleared by: compositionend handlers + scheduleRecompute("...:compositionend")
  // STATE VARIABLES (all window-scoped):
  //   - window.__mf_isComposing — IME composition flag
  //   - window.__mf_recomputeTimer — debounce timer reference (160ms trailing)
  //   - window.__mf_lastTextSnapshot — previous text hash (avoid redundant scans)
  //   - window.__mf_pendingReason — current scheduled reason string
  // WIRING OWNERS (one per input):
  //   - agentInput → [MF:PHASE-F][OWNER:INPUT_AGENT] at line ~19059
  //   - customerInput → [MF:PHASE-F][OWNER:INPUT_CUSTOMER] at line ~14067
  //   - mlcxNotesInput → [MF:PHASE-F][OWNER:INPUT_NOTES] at line ~15669
  window.__mf_isComposing = window.__mf_isComposing || false;
  window.__mf_recomputeTimer = window.__mf_recomputeTimer || null;
  window.__mf_lastTextSnapshot = window.__mf_lastTextSnapshot || "";
  window.__mf_pendingReason = window.__mf_pendingReason || "";

  function mainHeavyRecomputePipeline(textSnapshot, reason) {
    // [MF:PHASE-F][OWNER:PHASE_F_SCHEDULER] CANONICAL heavy analysis entry point
    // DO NOT CALL THIS DIRECTLY. Entry points: runRecompute() / runRecomputeNow() only.
    // NO recursive scheduling calls allowed (prevents event loop / double-compute).
    try {
      // Messenger Writer Insights (role-aware) — run once per schedule
      if (typeof isMessengerLayout === "function" && isMessengerLayout()) {
        const role = (window.__msWriterRole || "agent");
        if (typeof renderWriterInsights === "function" && typeof writerTargets !== "undefined") {
          renderWriterInsights(textSnapshot || "", writerTargets.messenger, { mode: "messenger", role });
        }
      }

      // MLCX state recompute (multi-pass analysis: emotion, clarity, vulnerability)
      if (typeof recomputeMlcxState === "function") {
        recomputeMlcxState("scheduler:" + (reason || ""));
      }
    } catch (e) {
      console.warn("[MF:PHASE-F] mainHeavyRecomputePipeline error:", e);
    }
  }

  function scheduleRecompute(reason) {
    // [MF:PHASE-F][OWNER:PHASE_F_SCHEDULER] INPUT handler: 160ms trailing debounce
    // Called by: input handlers (all 3 inputs) + compositionend handlers
    // Skipped if: window.__mf_isComposing === true (during IME composition)
    window.__mf_pendingReason = reason || "";
    // Guard: do not schedule heavy work during IME composition
    if (window.__mf_isComposing === true) return;
    // Cancel previous timer + schedule new one (trailing debounce pattern)
    if (window.__mf_recomputeTimer) clearTimeout(window.__mf_recomputeTimer);
    window.__mf_recomputeTimer = setTimeout(() => runRecompute("debounced:" + window.__mf_pendingReason), 160);
  }

  function runRecompute(reason) {
    // [MF:PHASE-F][OWNER:PHASE_F_SCHEDULER] Execute pending recompute (called by: scheduleRecompute timeout)
    // Cancel any pending timer
    if (window.__mf_recomputeTimer) {
      clearTimeout(window.__mf_recomputeTimer);
      window.__mf_recomputeTimer = null;
    }
    // Guard: do not run heavy work mid-composition
    if (window.__mf_isComposing === true) return;
    // Snapshot current text (same approach as Writer Insights)
    const snapshot = (typeof getMessengerWriterSourceText === "function")
      ? getMessengerWriterSourceText(window.__msWriterRole || "agent")
      : "";
    // Optimization: skip redundant scans if text hasn't changed (debounced runs only)
    if (String(snapshot) === String(window.__mf_lastTextSnapshot) && String(reason || "").startsWith("debounced:")) {
      return;
    }
    window.__mf_lastTextSnapshot = String(snapshot);
    mainHeavyRecomputePipeline(window.__mf_lastTextSnapshot, reason);
  }

  function runRecomputeNow(reason) {
    // [MF:PHASE-F][OWNER:PHASE_F_SCHEDULER] BLUR/COMMIT: immediate recompute (no 160ms debounce)
    // Called by: blur handlers (all 3 inputs) + commit handlers + button actions
    // Cancels any pending debounce timer and executes immediately
    if (window.__mf_recomputeTimer) {
      clearTimeout(window.__mf_recomputeTimer);
      window.__mf_recomputeTimer = null;
    }
    // Guard: do not run heavy work mid-composition
    if (window.__mf_isComposing === true) return;
    runRecompute("immediate:" + (reason || ""));
  }

  // Expose minimal debug hooks for Phase F
  window.__MF_PHASEF = { scheduleRecompute, runRecomputeNow, mainHeavyRecomputePipeline };

  // [MF:AUDIT] Phase F CHECKLIST:
  // ✓ SINGLE SCHEDULER: Only one mainHeavyRecomputePipeline + scheduleRecompute/runRecomputeNow (line ~23128)
  // ✓ SINGLE WIRING PER INPUT: One input listener per element (agent/customer/notes)
  // ✓ NO KEYUP HEAVY: keyup listeners remain LIGHT only (preview sync, not heavy analysis)
  // ✓ COMPOSITION GUARD: window.__mf_isComposing blocks heavy work during IME
  // ✓ DEBOUNCE TIMING: 160ms trailing on input; 0ms (immediate) on blur/commit
  // ✓ NO DUPLICATE DEBOUNCE: debouncedRecomputeMlcxState converted to NO-OP (line ~23232)
  // ✓ WINDOW-SCOPED STATE: All __mf_* variables use window scope (no closure shadows)
  
  // [MF:PHASE-F] Legacy debounce utility (NOT USED by Phase F heavy pipeline; converted to NO-OP wrapper)
  function debounce(fn, delay){
    // [MF:PHASE-F] Legacy wrapper — do not wire listeners here
    let t;
    return function(...args){
      clearTimeout(t);
      t = setTimeout(() => fn.apply(this, args), delay);
    };
  }
  // [MF:PHASE-F] NO-OP wrapper: debouncedRecomputeMlcxState does NOT run heavy pipeline
  const debouncedRecomputeMlcxState = (src) => {
    // [MF:PHASE-F] Deprecated: DO NOT attach listeners here. Use Phase F scheduler instead.
    // If called, route to canonical scheduler for safety
    if (typeof scheduleRecompute === 'function') scheduleRecompute('legacy:' + (src || ''));
  };

  // [MF:PHASE-F] Legacy live updates wiring function (LIGHT ONLY — no direct heavy scheduling)
  // Heavy analysis now owned by Phase F input handlers. This function runs LIGHT setup only.
  function wireLiveUpdates(){
    const H = window.__MF_HEALTH || (window.__MF_HEALTH = {});

    // Prevent duplicate wiring unless forced via reload
    if (H.__liveUpdatesWired) {
      // Still update health UI
      if (typeof window.updateDevLabHealthPanel === 'function') window.updateDevLabHealthPanel();
      return;
    }

    const customerEl = document.getElementById("customerInput");
    const agentEl = document.getElementById("agentInput");
    const notesEl = document.querySelector(".mlcx-notes-input");

    // Boot safe mode option disables live analysis wiring, but Dev Lab can still run manual analysis.
    if (window.__MF_DISABLE_LIVE_ANALYSIS){
      H.__liveUpdatesWired = false;
      if (typeof window.updateDevLabHealthPanel === 'function') window.updateDevLabHealthPanel();
      // Still do one initial compute for UI stability
      try { if (typeof runRecomputeNow === 'function') runRecomputeNow('init'); } catch (e) {}
      return;
    }

    const wire = (typeof window.mfWire === 'function') ? window.mfWire : null;

    // [MF:PHASE-F] LIGHT setup only. Heavy input scheduling is OWNED by Phase F input handlers:
    //   - agentInput: input listener at line ~19059
    //   - customerInput: input listener at line ~14067
    //   - mlcxNotesInput: input listener at line ~15669
    // DO NOT attach debouncedRecomputeMlcxState listeners here (will duplicate event storm)

    ensureCxDrawerTargetPills();
    syncCxDrawerTargetUi();

    H.__liveUpdatesWired = true;

    // [MF:PHASE-F] Initial compute via canonical Phase F scheduler
    if (typeof runRecomputeNow === 'function') runRecomputeNow('init');
    if (typeof window.updateDevLabHealthPanel === 'function') window.updateDevLabHealthPanel();
  }

  if (document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", wireLiveUpdates);
  } else {
    wireLiveUpdates();
  }

  // Phase 19.13B + Phase 20: Render MLCX coaching cards from shared config with tooltips
  function renderMlcxCoachingCards() {
    const container = document.getElementById("mlcxCoachingCardsContainer");
    if (!container) return;

    const categories = ["emotion", "clarity", "cxRisk", "safety"];
    const pillarTooltips = {
      "TONE": "Track frustration, anxiety and reassurance opportunities",
      "CLARITY": "Flag confusion and check understanding throughout the call",
      "CX RISK": "Monitor jargon, cost concerns and timeline clarity",
      "SAFETY": "Identify vulnerability signals and support needs"
    };
    let html = "";

    categories.forEach(category => {
      const card = mlcxCoachCards[category];
      if (!card) return;

      const pillarTooltip = pillarTooltips[card.pillar] || "";
      const wordingTooltip = card.suggestedWording || "Example wording not available";

      html += `
        <div class="mlcx-og-card" data-mlcx-category="${category}">
          <div class="mlcx-og-card-header">
            <span>${card.title}</span><span class="mlcx-tag" data-tooltip="${pillarTooltip}" title="${card.pillar}">${card.pillar}</span>
          </div>
          <p>${card.body}</p>
          <ul>${card.bullets.map(b => `<li>${b}</li>`).join("")}</ul>
          <button type="button" class="mlcx-snippet-btn is-new" data-category="${category}" data-tooltip="${wordingTooltip}" title="Example wording">Suggested wording</button>
        </div>
      `;
    });

    container.innerHTML = html;
  }

  // Phase 10: Generate coaching tips based on MLCX state (using shared config)
  function buildMlcxCoachingTips(state){
    const tips = [];
    const emotionCount = state.categories.emotion.count || 0;
    const clarityCount = state.categories.clarity.count || 0;
    const cxriskCount  = state.categories.cxRisk.count || 0;
    const safetyCount  = state.categories.safety.count || 0;
    const severityBand = state.severityBand || "low";

    // Brain v2 (Phase 1): speaker-aware heuristics tips (kept short)
    const v2 = state && state.brainV2 ? state.brainV2 : null;
    if (v2 && typeof v2 === "object") {
      const sig = v2.signals || v2; // support both filtered (agent/customer) and full objects
      const insights = v2.insights || [];
      const praise = v2.praise || [];
      // If we have direct insights, prefer them.
      if (Array.isArray(praise) && praise.length) tips.push(praise[0]);
      if (Array.isArray(insights) && insights.length) {
        insights.slice(0, 2).forEach(line => tips.push(line));
      }
      // Otherwise fall back to signals.
      if (!insights.length && sig && sig.jargon && sig.jargon.severity === "high") {
        tips.push("A lot of jargon detected - simplify or spell acronyms out once, then shorten.");
      }
      if (!insights.length && sig && sig.reassuranceMissing) {
        tips.push("Reassurance missing - add a quick ‘sorry + we’ll help’ line before steps.");
      }
      if (!insights.length && sig && sig.delayExplanationMissing) {
        tips.push("Delay mentioned - add a brief why + when they’ll hear from us.");
      }
      if (!insights.length && sig && sig.financialStress && sig.financialStress.level !== "none") {
        tips.push("Cost concerns detected - be explicit about payments/excess and options.");
      }
    }


    // High severity general tip
    if (severityBand === "high"){
      tips.push("High concern detected - take your time, stay calm, and be extra clear with next steps.");
    }

    // Emotion-specific coaching (referencing shared config)
    if (emotionCount >= 3){
      tips.push("Acknowledge how they're feeling and thank them for their patience.");
      if (mlcxCoachCards.emotion && mlcxCoachCards.emotion.suggestedWording) {
        tips.push(`Example: "${mlcxCoachCards.emotion.suggestedWording}"`);
      }
    } else if (emotionCount >= 1){
      tips.push("Be mindful of tone - keep empathy front and center.");
    }

    // Clarity-specific coaching (referencing shared config)
    if (clarityCount >= 3){
      tips.push("Slow down and recap the next steps in plain language.");
      if (mlcxCoachCards.clarity && mlcxCoachCards.clarity.suggestedWording) {
        tips.push(`Example: "${mlcxCoachCards.clarity.suggestedWording}"`);
      }
    } else if (clarityCount >= 1){
      tips.push("Check understanding: 'Does that make sense?' or 'Would you like me to go over that again?'");
    }

    // CX Risk coaching (jargon, cost, delays) (referencing shared config)
    if (cxriskCount >= 3){
      tips.push("Be extra clear about costs, excess, and timelines - avoid jargon.");
      if (mlcxCoachCards.cxRisk && mlcxCoachCards.cxRisk.suggestedWording) {
        tips.push(`Example: "${mlcxCoachCards.cxRisk.suggestedWording}"`);
      }
    } else if (cxriskCount >= 1){
      tips.push("Watch for technical terms - pause to explain anything that might confuse.");
    }

    // Safety/CiVC coaching (referencing shared config)
    if (safetyCount >= 2){
      tips.push("Potential vulnerability detected - check if they need additional support or a different contact channel.");
      if (mlcxCoachCards.safety && mlcxCoachCards.safety.suggestedWording) {
        tips.push(`Example: "${mlcxCoachCards.safety.suggestedWording}"`);
      }
    } else if (safetyCount >= 1){
      tips.push("Be alert for vulnerability signals - offer support if they mention health, money worries, or personal challenges.");
    }

    // Low/no signals fallback
    if (tips.length === 0){
      tips.push("No major concerns detected - maintain a steady, clear tone.");
      tips.push("Keep language simple and check understanding at key moments.");
    }

    return tips;
  }

  // Phase 10: Render coaching tips in CX drawer
  function renderCxDrawerCoaching(state){
    const drawerSections = document.querySelectorAll("#cxDrawerBody .cx-drawer-section");
    if (drawerSections.length < 4) return;

    const supportSection = drawerSections[3]; // "Support flags & next steps"
    const coachingId = "cxCoachingTips";
    let coachingContainer = document.getElementById(coachingId);

    if (!coachingContainer){
      coachingContainer = document.createElement("div");
      coachingContainer.id = coachingId;
      coachingContainer.style.marginTop = "12px";
      coachingContainer.style.fontSize = "0.74rem";
      coachingContainer.style.lineHeight = "1.5";
      const emptyPara = supportSection.querySelector(".cx-drawer-section-empty");
      if (emptyPara){
        emptyPara.insertAdjacentElement("afterend", coachingContainer);
      } else {
        supportSection.appendChild(coachingContainer);
      }
    }

    const tips = buildMlcxCoachingTips(state);

    // Clear and rebuild
    coachingContainer.innerHTML = "";
    if (tips.length === 0) return;

    const header = document.createElement("div");
    header.style.fontWeight = "600";
    header.style.fontSize = "0.76rem";
    header.style.marginBottom = "6px";
    header.style.textTransform = "uppercase";
    header.style.letterSpacing = "0.08em";
    header.style.opacity = "0.9";
    header.textContent = "Coaching";
    coachingContainer.appendChild(header);

    const list = document.createElement("ul");
    list.style.margin = "0";
    list.style.paddingLeft = "1.2em";
    list.style.listStyleType = "disc";
    tips.forEach(tip => {
      const li = document.createElement("li");
      li.style.marginBottom = "4px";
      li.textContent = tip;
      list.appendChild(li);
    });
    coachingContainer.appendChild(list);
  }

  // Phase 17: Unified MLCX snapshot renderer (shared by Notepad + CX drawer)
  function renderMlcxSnapshotInto(rootEl, state){
    if (!rootEl || !state) return; // defensive: missing container or state

    const severityBand = state.severityBand || "low";
    const emotionCount = state.categories.emotion.count || 0;
    const clarityCount = state.categories.clarity.count || 0;
    const cxriskCount  = state.categories.cxRisk.count || 0;
    const safetyCount  = state.categories.safety.count || 0;
    const totalSignals = emotionCount + clarityCount + cxriskCount + safetyCount;

    // Severity label and color
    let severityLabel = "Low concern";
    let severityColor = "#10b981"; // green
    if (severityBand === "high"){
      severityLabel = "High concern";
      severityColor = "#ef4444"; // red
    } else if (severityBand === "medium"){
      severityLabel = "Medium concern";
      severityColor = "#f59e0b"; // amber
    }

    // Phase 19.14B: Always show snapshot, even when totalSignals === 0
    // For zero signals, show baseline "Low concern · 0 cues"
    const cuesLabel = totalSignals === 1 ? "cue" : "cues";
    const html = `
      <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;font-size:0.72rem;line-height:1.4;">
        <span style="font-weight:600;color:${severityColor};" data-mlcx-chip="severity">${severityLabel}</span>
        <span style="opacity:0.6;">·</span>
        <span style="opacity:0.8;">${totalSignals} ${cuesLabel}</span>
        <span style="opacity:0.6;">·</span>
        <span data-mlcx-chip="emotion">Emotion <strong>${emotionCount}</strong></span>
        <span style="opacity:0.6;">·</span>
        <span data-mlcx-chip="clarity">Clarity <strong>${clarityCount}</strong></span>
        <span style="opacity:0.6;">·</span>
        <span data-mlcx-chip="cxRisk">CX Risk <strong>${cxriskCount}</strong></span>
        <span style="opacity:0.6;">·</span>
        <span data-mlcx-chip="safety">Safety <strong>${safetyCount}</strong></span>
      </div>
    `;

    rootEl.innerHTML = html;
  }

  function syncCxDrawerTargetUi(){
    const buttons = document.querySelectorAll('[data-cx-target]');
    buttons.forEach(btn => {
      const isActive = btn.dataset.cxTarget === cxDrawerTarget;
      btn.classList.toggle("active", isActive);
      btn.setAttribute("aria-pressed", String(isActive));
      btn.style.opacity = isActive ? "1" : "0.75";
      btn.style.borderColor = isActive ? "rgba(56, 189, 248, 0.85)" : "";
    });
  }

  function setCxDrawerTarget(nextTarget){
    const normalized = nextTarget === "agent" ? "agent" : "customer";
    if (cxDrawerTarget === normalized) return;
    cxDrawerTarget = normalized;
    syncCxDrawerTargetUi();
    const drawerSnapshot = document.getElementById("cxDrawerSnapshot");
    if (drawerSnapshot){
      const viewState = filterMlcxStateBySource(mlcxState, cxDrawerTarget);
      renderMlcxSnapshotInto(drawerSnapshot, viewState);
    }
    updateCxDrawerFromMlcxState(mlcxState);
  }

  function ensureCxDrawerTargetPills(){
    const overlay = document.getElementById("cxDrawerOverlay");
    if (!overlay) return;
    const header = overlay.querySelector(".cx-drawer-header");
    if (!header) return;

    let toggle = document.getElementById("cxDrawerTargetToggle");
    if (!toggle){
      toggle = document.createElement("div");
      toggle.id = "cxDrawerTargetToggle";
      toggle.className = "cx-target-toggle";
      toggle.style.display = "inline-flex";
      toggle.style.gap = "6px";
      toggle.style.alignItems = "center";
      toggle.style.marginLeft = "8px";

      const closeBtn = header.querySelector(".cx-drawer-close-btn");
      if (closeBtn){
        header.insertBefore(toggle, closeBtn);
      } else {
        header.appendChild(toggle);
      }
    }

    const ensureButton = (target, label) => {
      let btn = toggle.querySelector(`button[data-cx-target="${target}"]`);
      if (!btn){
        btn = document.createElement("button");
        btn.type = "button";
        btn.dataset.cxTarget = target;
        btn.textContent = label;
        btn.className = "toolbar-pill";
        btn.style.padding = "6px 12px";
        btn.style.fontSize = "0.72rem";
        btn.style.borderRadius = "999px";
        btn.style.whiteSpace = "nowrap";
        toggle.appendChild(btn);
      }
      if (!btn.dataset.cxBound){
        btn.dataset.cxBound = "true";
        btn.addEventListener("click", () => setCxDrawerTarget(target));
      }
    };

    ensureButton("customer", "Customer");
    ensureButton("agent", "Agent");
    syncCxDrawerTargetUi();
  }

  // Phase 17: Dispatcher to refresh all MLCX surfaces (Notepad + CX drawer)
  function refreshAllMlcxSurfaces(){
    const notepadSnapshot = document.getElementById("mlcxNotepadSnapshot");
    const drawerSnapshot = document.getElementById("cxDrawerSnapshot");
    const drawerViewState = filterMlcxStateBySource(mlcxState, cxDrawerTarget);
    
    renderMlcxSnapshotInto(notepadSnapshot, mlcxState);
    renderMlcxSnapshotInto(drawerSnapshot, drawerViewState);
    // Phase 19.13: coach card highlighting
    refreshNotepadCoachingCards(mlcxState);
    // Phase 19.13A: render high-risk snippets
    renderHighRiskSnippets(drawerViewState);
    // Call Notes insights cards
    renderCallNotesInsights(mlcxState);
  }

  // Phase 19.13A: Render high-risk snippets from MLCX state
  function renderHighRiskSnippets(state) {
    const contentEl = document.getElementById("mlcxHighRiskContent");
    if (!contentEl || !state || !state.categories) return;

    // Collect all flagged snippets from all categories, prioritizing safety/civc
    // Prefer category.snippets, fallback to category.cues
    const allSnippets = [];

    // Helper to extract snippets from a category
    function extractSnippets(category, categoryName) {
      if (!category) return;
      
      // Prefer reading from category.snippets (live data)
      const snippets = category.snippets || [];
      if (snippets.length > 0) {
        snippets.forEach(snip => {
          const text = (typeof snip === "string") ? snip : (snip && (snip.text || snip.phrase));
          if (!text || !text.trim()) return;
          allSnippets.push({
            text: text.trim(),
            category: categoryName,
            severity: (typeof snip === "object" && snip && snip.severity) ? snip.severity : (category.severity || "low"),
            source: (typeof snip === "object" && snip && snip.source) ? snip.source : "unknown"
          });
        });
      } else if (category.cues && category.cues.length > 0) {
        // Fallback to cues if no snippets are present
        category.cues.forEach(cue => {
          const snippet = cue.phrase || cue.text || "";
          if (!snippet.trim()) return;
          allSnippets.push({
            text: snippet.trim(),
            category: categoryName,
            severity: cue.severity || category.severity || "low",
            source: "cue"
          });
        });
      }
    }

    // Priority order: safety, cxRisk, emotion, clarity
    extractSnippets(state.categories.safety, "Safety");
    extractSnippets(state.categories.cxRisk, "CX Risk");
    extractSnippets(state.categories.emotion, "Emotion");
    extractSnippets(state.categories.clarity, "Clarity");

    // Filter unique snippets by lowercased text and limit to top 15
    const uniqueSnippets = [];
    const seen = new Set();
    allSnippets.forEach(s => {
      const key = s.text.toLowerCase();
      if (!seen.has(key) && uniqueSnippets.length < 15) {
        uniqueSnippets.push(s);
        seen.add(key);
      }
    });

    // Render
    if (uniqueSnippets.length === 0) {
      contentEl.innerHTML = `<div class="mlcx-highrisk-empty">No high-risk snippets detected yet. This panel will list key phrases as they're flagged.</div>`;
    } else {
      const listItems = uniqueSnippets.map(s => {
        const escaped = s.text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
        return `<li><span class="mlcx-highrisk-chip">${s.category}</span> ${escaped}</li>`;
      }).join("");
      contentEl.innerHTML = `<ul class="mlcx-highrisk-list">${listItems}</ul>`;
    }
  }

  // Phase 19.13: Update coaching cards from mlcxState
  function refreshNotepadCoachingCards(state) {
    if (!state || !state.categories) return;

    const counts = {
      emotion: state.categories.emotion?.count || 0,
      clarity: state.categories.clarity?.count || 0,
      cxRisk:  state.categories.cxRisk?.count  || 0,
      safety:  state.categories.safety?.count  || 0
    };

    Object.keys(counts).forEach(key => {
      const card = document.querySelector(`.mlcx-og-card[data-mlcx-category="${key}"]`);
      if (!card) return;

      const count = counts[key];
      card.classList.toggle("mlcx-card-active", count > 0);

      const header = card.querySelector(".mlcx-og-card-header");
      if (!header) return;

      let badge = header.querySelector(".mlcx-card-count");
      if (!badge) {
        badge = document.createElement("span");
        badge.className = "mlcx-card-count";
        header.appendChild(badge);
      }

      if (count > 0) {
        badge.textContent = String(count);
        badge.style.display = "inline-flex";
      } else {
        badge.textContent = "";
        badge.style.display = "none";
      }
    });
  }

  // Call Notes: render insights chips into the three cards (Emotion, Clarity/Jargon, CV Flags)
  function renderCallNotesInsights(state){
    const emotionEl = document.getElementById("callnotesEmotionBody");
    const clarityEl = document.getElementById("callnotesClarityBody");
    const safetyEl  = document.getElementById("callnotesSafetyBody");
    if (!emotionEl || !clarityEl || !safetyEl || !state || !state.categories) return;

    function buildChips(items) {
      if (!items || !items.length) {
        return "<span class=\"callnotes-chip empty\">No signals yet</span>";
      }

      const limited = items.slice(0, 5);

      return limited.map(item => {
        const rawText = (typeof item === "string")
          ? item
          : (item && (item.text || item.snippet || item.phrase) || "").trim();
        const rawTag  = (typeof item === "object" && item && item.tag) ? String(item.tag).trim() : "";

        const text = (rawText || "").trim();
        const full = (rawTag ? rawTag + " · " : "") + text;

        // Short display version (to keep chips tidy)
        const maxLen = 80;
        let display = full;
        if (display.length > maxLen) {
          display = display.slice(0, maxLen - 1) + "…";
        }

        const safeDisplay = String(display)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");

        const safeFull = String(full)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");

        return `
          <span class="callnotes-chip" title="${safeFull}">
            ${safeDisplay}
          </span>
        `;
      }).join("");
    }

    emotionEl.innerHTML = buildChips(state.categories.emotion?.snippets || []);
    // Merge clarity + cxRisk into a single card body
    const clarityChips = (state.categories.clarity?.snippets || []).concat(state.categories.cxRisk?.snippets || []);
    clarityEl.innerHTML = buildChips(clarityChips);
    safetyEl.innerHTML  = buildChips(state.categories.safety?.snippets || []);

    // Coach lines (static copy) into footers
    const emotionFooter = document.getElementById("callnotesEmotionFooter");
    const clarityFooter = document.getElementById("callnotesClarityFooter");
    const safetyFooter  = document.getElementById("callnotesSafetyFooter");

    if (emotionFooter) {
      emotionFooter.textContent = "Spot the feelings and think: what reassurance would actually help?";
    }
    if (clarityFooter) {
      clarityFooter.textContent = "Watch for repeated questions or jargon you could simplify.";
    }
    if (safetyFooter) {
      safetyFooter.textContent = "Anything that hints at money, health or support needs a clear next step.";
    }
  }

  // Phase 18: Customer text → MLCX notepad sync helper (for demos & live calls)
  function copyCustomerTextToMlcxNotes(){
    // Safe in all layouts: if either element missing, just return
    const customerInput = document.getElementById("customerInput");
    const mlcxNotesInput = document.querySelector(".mlcx-notes-input");
    
    if (!customerInput || !mlcxNotesInput) return; // defensive: missing elements
    
    const customerText = (customerInput.value || "").trim();
    if (!customerText) return; // nothing to copy
    
    // Append with separator if notes already contain text
    const currentNotes = mlcxNotesInput.value || "";
    const separator = currentNotes.trim() ? "\n\n" : "";
    mlcxNotesInput.value = currentNotes + separator + customerText;
    
    // Move caret to end and scroll into view
    mlcxNotesInput.selectionStart = mlcxNotesInput.selectionEnd = mlcxNotesInput.value.length;
    mlcxNotesInput.scrollTop = mlcxNotesInput.scrollHeight;
    
    // Trigger unified recompute to pick up the change
    if (typeof runRecomputeNow === "function") runRecomputeNow('notes:copy-customer');
    
    // Optional: brief visual feedback
    console.log("[MLCX Phase 18] Copied customer text to notepad:", customerText.slice(0, 60) + "...");
  }

  // Phase 9: Render MLCX summary line on Notepad layout (DEPRECATED - replaced by Phase 17 unified renderer)
  function renderMlcxNotepadSummary(state){
    const notepadHeader = document.querySelector(".mlcx-og-header");
    if (!notepadHeader) return;

    const summaryId = "mlcxNotepadSummary";
    let summaryLine = document.getElementById(summaryId);

    // Idempotent: create if missing
    if (!summaryLine){
      summaryLine = document.createElement("div");
      summaryLine.id = summaryId;
      summaryLine.style.marginTop = "6px";
      summaryLine.style.fontSize = "0.72rem";
      summaryLine.style.color = "var(--text-muted)";
      summaryLine.style.letterSpacing = "0.02em";
      summaryLine.style.display = "flex";
      summaryLine.style.alignItems = "center";
      summaryLine.style.gap = "8px";
      summaryLine.style.flexWrap = "wrap";
      notepadHeader.appendChild(summaryLine);
    }

    const severityBand = state.severityBand || "low";
    const emotionCount = state.categories.emotion.count || 0;
    const clarityCount = state.categories.clarity.count || 0;
    const cxriskCount  = state.categories.cxRisk.count || 0;
    const safetyCount  = state.categories.safety.count || 0;

    // Build summary text
    let severityLabel = "Low concern";
    let severityColor = "#10b981"; // green
    if (severityBand === "high"){
      severityLabel = "High concern";
      severityColor = "#ef4444"; // red
    } else if (severityBand === "medium"){
      severityLabel = "Medium concern";
      severityColor = "#f59e0b"; // amber
    }

    summaryLine.innerHTML = `
      <span style="font-weight:600;color:${severityColor};">MLCX: ${severityLabel}</span>
      <span style="opacity:0.6;">·</span>
      <span>Emotion <strong>${emotionCount}</strong></span>
      <span style="opacity:0.6;">·</span>
      <span>Clarity <strong>${clarityCount}</strong></span>
      <span style="opacity:0.6;">·</span>
      <span>CX Risk <strong>${cxriskCount}</strong></span>
      <span style="opacity:0.6;">·</span>
      <span>Safety <strong>${safetyCount}</strong></span>
    `;
  }

  // Phase 8: Render snippets as chips/bullets in CX drawer sections
  function renderCxDrawerSnippets(emotionSnippets, claritySnippets, cxriskSnippets, safetySnippets){
    const drawerSections = document.querySelectorAll("#cxDrawerBody .cx-drawer-section");
    if (drawerSections.length < 4) return;

    const emotionSection = drawerSections[1];
    const civcSection    = drawerSections[2];

    // Remove legacy snippet rows inside the section's empty placeholder, keeping summary line if present
    function stripLegacyRows(section) {
      const empty = section.querySelector(".cx-drawer-section-empty");
      if (!empty) return;
      const firstBlock = empty.firstElementChild;
      if (firstBlock) {
        // Preserve the first block (usually the summary line) and drop the rest
        empty.innerHTML = firstBlock.outerHTML;
      } else {
        // Nothing meaningful; clear to avoid duplicate rows
        empty.textContent = empty.textContent; // no-op but ensures text-only remains
      }
    }

    stripLegacyRows(emotionSection);
    stripLegacyRows(civcSection);

    // Helper: render snippet chips in a container
    function renderSnippetChips(section, containerId, snippets, borderColor){
      let container = section.querySelector(`#${containerId}`);
      if (!container){
        container = document.createElement("div");
        container.id = containerId;
        container.style.marginTop = "8px";
        container.style.display = "flex";
        container.style.flexWrap = "wrap";
        container.style.gap = "6px";
        container.style.fontSize = "0.72rem";
        const emptyPara = section.querySelector(".cx-drawer-section-empty");
        if (emptyPara){
          emptyPara.insertAdjacentElement("afterend", container);
        } else {
          section.appendChild(container);
        }
      }

      // Clear previous chips
      container.innerHTML = "";

      if (!snippets || snippets.length === 0){
        return; // leave empty
      }

      // De-duplicate by normalized text and render up to 5 unique chips
      const seen = new Set();
      for (let i = 0; i < snippets.length && container.childElementCount < 5; i++){
        const snip = snippets[i];
        const raw = (typeof snip === "string") ? snip : (snip && (snip.text || snip.phrase || ""));
        if (!raw) continue;
        const norm = raw.trim();
        if (!norm) continue;
        const key = norm.toLowerCase();
        if (seen.has(key)) continue;
        seen.add(key);

        const chip = document.createElement("span");
        chip.className = "mlcx-pill"; // reuse existing pill class
        chip.style.borderLeft = `3px solid ${borderColor}`;
        chip.style.maxWidth = "100%";
        chip.style.overflow = "hidden";
        chip.style.textOverflow = "ellipsis";
        chip.style.whiteSpace = "nowrap";
        chip.style.fontSize = "0.7rem";
        chip.style.padding = "3px 7px";
        chip.style.display = "inline-flex";
        chip.style.alignItems = "center";
        chip.style.gap = "4px";

        const fullText = norm;
        const source = (typeof snip === "object" && snip && snip.source) ? snip.source : "unknown";
        const display = fullText.length > 80 ? (fullText.slice(0,77) + "…") : fullText;
        
        // Optional: prepend category icon if available from snippet metadata
        const category = (typeof snip === "object" && snip && snip.category) ? snip.category : null;
        let iconHTML = '';
        if (category && window.mlcxCategoryMeta && window.mlcxCategoryMeta[category]) {
          const icon = window.mlcxCategoryMeta[category].icon;
          if (icon) {
            iconHTML = `<span class="cv-chip-icon" style="font-size:0.65rem;opacity:0.8;">${icon}</span>`;
          }
        }
        
        chip.innerHTML = iconHTML + `<span>${display}</span>`;
        chip.title = (typeof snip === "string") ? fullText : `[${source}] ${fullText}`;
        container.appendChild(chip);
      }
    }

    // Emotion section: show emotion + clarity snippets
    const emotionContainer = emotionSection.querySelector("#cxEmotionSnippets");
    if (emotionContainer) emotionContainer.remove(); // clear old container
    renderSnippetChips(emotionSection, "cxEmotionSnippets", 
      [...(emotionSnippets || []), ...(claritySnippets || [])],
      "#f59e0b" // amber border
    );

    // CiVC section: show cxRisk + safety snippets
    const civcContainer = civcSection.querySelector("#cxCivcSnippets");
    if (civcContainer) civcContainer.remove();
    renderSnippetChips(civcSection, "cxCivcSnippets",
      [...(cxriskSnippets || []), ...(safetySnippets || [])],
      "#ef4444" // red border
    );
  }

  // Phase 7: Render category counts in CX drawer section headers
  function renderCxDrawerCategoryCounts(emotionCount, clarityCount, cxriskCount, safetyCount){
    const drawerSections = document.querySelectorAll("#cxDrawerBody .cx-drawer-section");
    if (drawerSections.length < 4) return;

    const emotionSection = drawerSections[1];
    const civcSection    = drawerSections[2];
    const supportSection = drawerSections[3];

    // Helper: idempotent counter badge injection
    function injectCountBadge(section, counterId, countValue){
      const sectionTitle = section.querySelector(".cx-drawer-section-title");
      if (!sectionTitle) return;

      let badge = document.getElementById(counterId);
      if (!badge){
        badge = document.createElement("span");
        badge.id = counterId;
        badge.className = "issue-counter"; // reuse existing badge style
        badge.style.marginLeft = "6px";
        badge.style.fontSize = "0.64rem";
        badge.style.pointerEvents = "none";
        // Apply neutral/low styling by default
        badge.style.border = "1px solid rgba(148, 163, 184, 0.6)";
        badge.style.background = "radial-gradient(circle at top, rgba(15, 23, 42, 0.85), rgba(15, 23, 42, 0.7))";
        badge.style.color = "rgba(226, 232, 240, 0.9)";
        sectionTitle.appendChild(badge);
      }

      // Update count and apply color coding
      badge.textContent = countValue;
      if (countValue === 0){
        badge.style.border = "1px solid rgba(148, 163, 184, 0.5)";
        badge.style.background = "radial-gradient(circle at top, rgba(15, 23, 42, 0.75), rgba(15, 23, 42, 0.6))";
        badge.style.color = "rgba(148, 163, 184, 0.8)";
      } else if (countValue >= 5){
        // High count: red
        badge.style.border = "1px solid rgba(248, 113, 113, 0.85)";
        badge.style.background = "radial-gradient(circle at top, rgba(127, 29, 29, 0.85), rgba(15, 23, 42, 0.35))";
        badge.style.color = "#fee2e2";
      } else if (countValue >= 2){
        // Medium count: amber
        badge.style.border = "1px solid rgba(250, 204, 21, 0.7)";
        badge.style.background = "radial-gradient(circle at top, rgba(180, 83, 9, 0.85), rgba(30, 64, 175, 0.2))";
        badge.style.color = "#fef9c3";
      } else {
        // Low count (1): teal/blue
        badge.style.border = "1px solid rgba(56, 189, 248, 0.7)";
        badge.style.background = "radial-gradient(circle at top, rgba(8, 47, 73, 0.85), rgba(15, 23, 42, 0.5))";
        badge.style.color = "#bfdbfe";
      }
    }

    // Emotion & tone section: combine emotion + clarity
    const emotionTotal = emotionCount + clarityCount;
    injectCountBadge(emotionSection, "cxEmotionCountBadge", emotionTotal);

    // CiVC & vulnerability section: combine cxRisk + safety
    const civcTotal = cxriskCount + safetyCount;
    injectCountBadge(civcSection, "cxCivcCountBadge", civcTotal);

    // Support flags section: show safety count (most critical)
    injectCountBadge(supportSection, "cxSupportCountBadge", safetyCount);
  }

  // Phase 6: Render severity badge in CX drawer header
  function renderCxDrawerSeverity(state){
    const header = document.querySelector(".cx-drawer-header .cx-drawer-title-block");
    if (!header) return;

    const severityBand = state.severityBand || "low";
    let badgeId = "cxSeverityBadge";
    let badge = document.getElementById(badgeId);

    // Idempotent: reuse existing badge if present
    if (!badge){
      badge = document.createElement("span");
      badge.id = badgeId;
      badge.className = "issue-counter"; // reuse existing pill/badge style
      badge.style.marginLeft = "8px";
      badge.style.fontSize = "0.68rem";
      badge.style.pointerEvents = "none"; // not interactive
      // Insert after subtitle if present, or append to title block
      const subtitle = header.querySelector(".cx-drawer-subtitle");
      if (subtitle){
        subtitle.insertAdjacentElement("afterend", badge);
      } else {
        header.appendChild(badge);
      }
    }

    // Map severity to existing color classes & text
    let label = "";
    let colorClass = "";
    if (severityBand === "high"){
      label = "High concern";
      colorClass = "spell-counter"; // red existing class
    } else if (severityBand === "medium"){
      label = "Medium concern";
      colorClass = "uk-counter"; // amber existing class
    } else {
      label = "Low concern";
      colorClass = ""; // neutral (no special class, default styling)
      // Apply manual neutral styling since no dedicated "low" class exists
      badge.style.border = "1px solid rgba(34, 197, 94, 0.7)";
      badge.style.background = "radial-gradient(circle at top, rgba(22, 163, 74, 0.75), rgba(15, 23, 42, 0.3))";
      badge.style.color = "#d1fae5";
    }

    // Reset inline styles if using a class
    if (colorClass){
      badge.style.border = "";
      badge.style.background = "";
      badge.style.color = "";
    }

    // Update class and text
    badge.className = "issue-counter " + colorClass;
    badge.textContent = label;
  }

  // Phase 5: Render live MLCX analysis into existing CX drawer UI
  function renderCxDrawerVisuals(){
    const hiddenStore = document.getElementById("mlcxHiddenState");
    if (!hiddenStore) return; // no data yet

    const severityBand = hiddenStore.dataset.severityBand || "low";
    const emotionCount = parseInt(hiddenStore.dataset.emotionCount || "0", 10);
    const clarityCount = parseInt(hiddenStore.dataset.clarityCount || "0", 10);
    const cxriskCount  = parseInt(hiddenStore.dataset.cxriskCount || "0", 10);
    const safetyCount  = parseInt(hiddenStore.dataset.safetyCount || "0", 10);

    let emotionSnippets = [];
    let claritySnippets = [];
    let cxriskSnippets  = [];
    let safetySnippets  = [];
    try {
      emotionSnippets = JSON.parse(hiddenStore.dataset.emotionSnippets || "[]");
      claritySnippets = JSON.parse(hiddenStore.dataset.claritySnippets || "[]");
      cxriskSnippets  = JSON.parse(hiddenStore.dataset.cxriskSnippets || "[]");
      safetySnippets  = JSON.parse(hiddenStore.dataset.safetySnippets || "[]");
    } catch(e){ /* ignore parse errors */ }

    // Phase 6: update severity badge in header
    renderCxDrawerSeverity({ severityBand });

    // Phase 7: update per-category count badges
    renderCxDrawerCategoryCounts(emotionCount, clarityCount, cxriskCount, safetyCount);

    // Phase 8: render snippet chips
    renderCxDrawerSnippets(emotionSnippets, claritySnippets, cxriskSnippets, safetySnippets);

    // Phase 10: render coaching tips
    renderCxDrawerCoaching({ 
      severityBand,
      categories: {
        emotion: { count: emotionCount },
        clarity: { count: clarityCount },
        cxRisk:  { count: cxriskCount },
        safety:  { count: safetyCount }
      }
    });

    // Target the existing CX drawer sections
    const drawerSections = document.querySelectorAll("#cxDrawerBody .cx-drawer-section");
    if (drawerSections.length < 4) return; // safety: expect 4 sections

    // Phase 17: Overview (section 0) now handled by unified renderMlcxSnapshotInto
    const emotionSection  = drawerSections[1];
    const civcSection     = drawerSections[2];
    const supportSection  = drawerSections[3];

    // SECTION 2: Emotion & tone (chip-only rendering, no legacy text lists)
    const emotionEmpty = emotionSection.querySelector(".cx-drawer-section-empty");
    if (emotionEmpty){
      if (emotionCount === 0 && clarityCount === 0){
        emotionEmpty.textContent = "No emotional or clarity signals detected.";
      } else {
        // Summary line only; chips rendered separately by renderCxDrawerSnippets
        emotionEmpty.innerHTML = `<div style="margin-bottom:8px;"><strong>Emotion:</strong> ${emotionCount} signal(s) | <strong>Clarity:</strong> ${clarityCount} signal(s)</div>`;
      }
    }

    // SECTION 3: CiVC & vulnerability (chip-only rendering, no legacy text lists)
    const civcEmpty = civcSection.querySelector(".cx-drawer-section-empty");
    if (civcEmpty){
      if (cxriskCount === 0 && safetyCount === 0){
        civcEmpty.textContent = "No cost-risk or CiVC vulnerability signals detected.";
      } else {
        // Summary line only; chips rendered separately by renderCxDrawerSnippets
        civcEmpty.innerHTML = `<div style="margin-bottom:8px;"><strong>CX Risk:</strong> ${cxriskCount} signal(s) | <strong>Safety (CiVC):</strong> ${safetyCount} signal(s)</div>`;
      }
    }

    // SECTION 4: Support flags & next steps
    const supportEmpty = supportSection.querySelector(".cx-drawer-section-empty");
    if (supportEmpty){
      const totalFlags = safetyCount + cxriskCount;
      if (totalFlags === 0){
        supportEmpty.textContent = "No support flags raised yet.";
      } else {
        let html = `<div style="margin-bottom:6px;font-size:0.76rem;"><strong>Flags raised:</strong> ${totalFlags}</div>`;
        html += `<ul style="margin:0;padding-left:1.2em;font-size:0.74rem;">`;
        if (safetyCount > 0) html += `<li>Safety/CiVC: ${safetyCount} signal(s) - check for mental health, financial hardship, safeguarding</li>`;
        if (cxriskCount > 0) html += `<li>CX Risk: ${cxriskCount} signal(s) - cost concerns, complaint signals, delays</li>`;
        html += `</ul>`;
        html += `<div style="margin-top:8px;font-size:0.72rem;opacity:0.8;">Next: Acknowledge openly, offer clear next step, avoid jargon.</div>`;
        supportEmpty.innerHTML = html;
      }
    }
  }

  // Phase 4: Hidden state bridge for CX drawer (no UI changes)
  function updateCxDrawerFromMlcxState(state){
    const baseState = state || mlcxState;
    if (!baseState) return;

    // Lazily create hidden state containers if they don't exist
    let hiddenStore = document.getElementById("mlcxHiddenState");
    if (!hiddenStore){
      hiddenStore = document.createElement("div");
      hiddenStore.id = "mlcxHiddenState";
      hiddenStore.style.display = "none";
      hiddenStore.setAttribute("aria-hidden", "true");
      document.body.appendChild(hiddenStore);
    }

    const viewState = filterMlcxStateBySource(baseState, cxDrawerTarget);

    // Store filtered state as dataset attributes (JSON encoded)
    hiddenStore.dataset.target = cxDrawerTarget;
    hiddenStore.dataset.severityBand = viewState.severityBand || "low";
    hiddenStore.dataset.emotionCount = viewState.categories.emotion.count || 0;
    hiddenStore.dataset.clarityCount = viewState.categories.clarity.count || 0;
    hiddenStore.dataset.cxriskCount  = viewState.categories.cxRisk.count || 0;
    hiddenStore.dataset.safetyCount  = viewState.categories.safety.count || 0;

    // Encode snippets as JSON for future drawer read
    hiddenStore.dataset.emotionSnippets = JSON.stringify(viewState.categories.emotion.snippets || []);
    hiddenStore.dataset.claritySnippets = JSON.stringify(viewState.categories.clarity.snippets || []);
    hiddenStore.dataset.cxriskSnippets  = JSON.stringify(viewState.categories.cxRisk.snippets || []);
    hiddenStore.dataset.safetySnippets  = JSON.stringify(viewState.categories.safety.snippets || []);

    // Emit custom event for future listeners (optional, no-op for now)
    document.dispatchEvent(new CustomEvent("mlcxStateUpdated", { detail: baseState }));

    // Phase 5: render CX drawer detailed visuals (sections 2-4)
    renderCxDrawerVisuals();
    renderHighRiskSnippets(viewState);
    
    // Phase 17: unified snapshot renderer already called by recomputeMlcxState
    // (no need to call again here to avoid double-render)
  }

  // Phase 17: REMOVED duplicate recomputeMlcxState (now only one version at line ~12430)
  // The unified version calls refreshAllMlcxSurfaces() which updates both Notepad + CX drawer

  // Debug helpers (intentional minimal global footprint)
  // Phase 19.20: Expose state to window for CX drawer and other surfaces
  window.mlcxState = mlcxState;
  window.debugMlcxState = () => mlcxState;
  window.runMlcxAnalysis = recomputeMlcxState;
  window.debugMlcxSnapshots = () => mlcxSnapshots;
  
  // Phase 18: Expose sync helper for demos & live calls
  window.mlcxCopyCustomerToNotes = copyCustomerTextToMlcxNotes;

  // Phase 19: Dev Lab panel logic
  (function initDevLab(){

    // Phase 19.13B: Initialize coaching cards from shared config
    renderMlcxCoachingCards();

    

    // Phase E: Dev Lab Health panel wiring
    (function wireDevLabHealthPanel(){
      const runBtn = document.getElementById('devHealthRunNow');
      const safeBtn = document.getElementById('devHealthToggleSafe');
      if (runBtn && !runBtn.__wired){
        runBtn.__wired = true;
        runBtn.addEventListener('click', () => {
          try { if (typeof runRecomputeNow === 'function') runRecomputeNow('manual'); } catch (e) {}
          try { if (typeof window.updateDevLabHealthPanel === 'function') window.updateDevLabHealthPanel(); } catch (e) {}
        });
      }
      if (safeBtn && !safeBtn.__wired){
        safeBtn.__wired = true;
        safeBtn.addEventListener('click', () => {
          const H = window.__MF_HEALTH || {};
          if (H.safeMode){
            window.exitMirrorFlowSafeMode && window.exitMirrorFlowSafeMode();
          } else {
            window.enterMirrorFlowSafeMode && window.enterMirrorFlowSafeMode('manual');
          }
        });
      }
      try { if (typeof window.updateDevLabHealthPanel === 'function') window.updateDevLabHealthPanel(); } catch (e) {}
    })();

// Phase 20: Wire Messenger CX Sync button
    const messengerSyncBtn = document.getElementById("mlcxToggleBtn");
    if (messengerSyncBtn) {
      messengerSyncBtn.addEventListener("click", runGlobalCxSync);
    }

    // Demo text blocks (MirrorFlow Master Error & Jargon Field Manual samples)
    const demoBlocks = [
      // Core demo scenarios only
      {
        label: "Multi Mixed UK/US",
        text: `I recognise the authorise timing for the repairs, but I need to recognize if you will authorize the centre repaint and color correction before travelling again. The colour of the vehicle was grey, but the new color used on the replacement panel looks off. I realised afterwards that I should have cancelled the policy sooner, as the premium and voluntary excess kept increasing. Please apologise for the delay and confirm when the settlement and courtesy car cover will be processed. I have been traveling between garages and traveling back home without clear guidance on the deductible and premium impact. The car struck the kerb after sliding toward the curb in wet conditions, causing damage to the bumper and tyre. I want to organise my claim and finalise the paperwork, but I also need to organize my finances and finalize the liability summary. Can you authorise the payment and recognise my concerns about the excess and the total loss valuation? I'm trying to analyse the situation and prioritise getting this resolved with the claims handler, but I also need to analyze the surcharge breakdown before issuing a settlement.`
      },
      {
        label: "Jargon & Cost Stress Test",
        text: `Hi, I'm really confused about my excess and premium. I was told there's a deductible but now you're saying there's a surcharge? I can't afford all these hidden costs. The liability clause in my policy is unclear and I'm worried about compliance risk. This is taking too long and I'm getting really frustrated. Can you escalate this? I need to know about my claim urgency and when I'll get paid because I have medical bills piling up. My premium increased after the last excess adjustment, and the surcharge plus deductible confusion is making me anxious. Please escalate this liability concern because I think there is a compliance issue with how the deductible was applied. The cancelled inspection slot means the canceled report is delaying my payout and I feel frustrated. I kept travelling between garages and traveling back home without clear guidance on the excess and premium impact. Please organise the documents so I can organize my finances; the outstanding excess and surcharge are worrying me.`
      },
      {
        label: "CiVC Escalation (Long Form)",
        text: `My situation has become extremely difficult over the past few months. After losing my job, I have been unable to keep up with rent and bills, and now I am facing eviction. My partner recently passed away, which has left me feeling isolated and overwhelmed. I have no family nearby and my mobility issues make it hard to get to appointments or access support. I am struggling with depression and anxiety, and sometimes I can't even get out of bed. I have reached out for help but the waiting lists are long, and I am worried about my safety and well-being. I need urgent advice on what support is available and how to manage my finances and health during this crisis.`
      },
      {
        label: "Customer: Repair Delay + Courtesy Car",
        text: `I've been waiting three weeks for an update on the repair and the courtesy car still hasn't arrived. The garage keeps saying they're waiting for authorisation and I'm worried about getting to work. Can someone confirm when the parts were ordered, whether the repair is a total loss, and if I still qualify for a replacement vehicle? I'm paying for alternative travel right now and it's expensive.`
      },
      {
        label: "Customer: Vulnerability + Urgency",
        text: `I'm recovering from surgery and can't walk far, so I really need clear guidance. The last call left me confused about excess and whether my no claims discount is protected. I'm anxious about money and the stress is affecting my sleep. Please keep the language simple and let me know what happens next.`
      },
      {
        label: "Agent Reply: Plain & Reassuring",
        text: `Thanks for letting me know what's happening. I'll keep my language simple. We have your claim open and the assessor is reviewing the photos today. You won't need to travel-I'll arrange collection and delivery. Your no claims discount is protected on this policy, so this claim won't remove it. The only cost to you is the £250 excess, which we collect when repairs start. I'll also book a like-for-like hire car for you until your car is back. I'll call you by 3pm with the booking details.`
      },
      {
        label: "Agent Reply: Cost Breakdown",
        text: `I understand you're worried about costs. Here's the breakdown: your compulsory excess is £200 and your voluntary excess is £150, so £350 in total. Because this was a non-fault incident, we expect to recover these costs from the other insurer. If we do, we'll refund the excess to you. Your no claims discount is protected, so it stays in place. I'll update you once recovery is confirmed and before any payment is taken.`
      },
      {
        label: "Agent Reply: Escalation & Clarity",
        text: `I'll escalate this to our specialist team now. They will review the liability decision and the surcharge you mentioned. You'll get an update within one business day. In the meantime, I’ve noted your concerns about the deductible and the inspection delay. If the delay is on our side, we'll cover any reasonable travel costs you've had to make. I'll summarise this in an email so you have it in writing.`
      }
    ];

    // Phase 19.12: Jargon & UK/US snapshot + scenario shuffle
    function updateDevJargonSnapshot(){
      const snapshotEl = document.getElementById("devJargonSnapshot");
      if (!snapshotEl) return;
      const state = mlcxState || {};
      const text = (state.sourceText && state.sourceText.customer) || "";
      const lower = text.toLowerCase();
      const jargonWords = ["excess","deductible","liability","surcharge","compliance","premium","settlement","valuation","escalate","escalation"];
      let jargonCount=0, jargonMatches=[]; jargonWords.forEach(w=>{ if(lower.includes(w)){ jargonCount++; jargonMatches.push(w);} });
      const { count: ukUsCount, examples: ukUsMatches } = summarizeUkusMatches(text);
      if(!text.trim()){ snapshotEl.textContent = "No text available for Dev Lab snapshot yet."; return; }
      const lines=[]; lines.push(`Jargon: ${jargonCount} term(s) · UK/US spelling: ${ukUsCount} issue(s)`);
      if(jargonMatches.length){ lines.push("","Jargon examples:"); jargonMatches.slice(0,5).forEach(w=>lines.push(" • "+w)); }
      if(ukUsMatches.length){ lines.push("","UK/US spelling examples:"); ukUsMatches.slice(0,5).forEach(w=>lines.push(" • "+w)); }
      if(!jargonMatches.length && !ukUsMatches.length){ lines.push("","No jargon or UK/US spelling issues detected in the current text."); }
      snapshotEl.textContent = lines.join("\n");
    }
    let devScenarioIndex = 0;
    // Refresh Dev Lab content
    function refreshDevLabContent(){
      const isDevLayout = document.body.dataset.layout === "dev";
      if (!isDevLayout) return; // only refresh when in dev layout

      // MLCX Summary Debug
      const devMlcxSummary = document.getElementById("devMlcxSummary");
      if (devMlcxSummary){
        const state = mlcxState || {};
        const summary = `MLCX State Summary
===================
Severity: ${state.severityBand || "unknown"}
Emotion: ${state.categories?.emotion?.count || 0} signals
Clarity: ${state.categories?.clarity?.count || 0} signals
CX Risk: ${state.categories?.cxRisk?.count || 0} signals
Safety: ${state.categories?.safety?.count || 0} signals

Source Text Lengths:
- Customer: ${state.sourceText?.customer?.length || 0} chars
- Agent: ${state.sourceText?.agent?.length || 0} chars
- Notes: ${state.sourceText?.notes?.length || 0} chars

Snippets (first 3 per category):
${state.categories?.emotion?.snippets?.slice(0,3).map((s,i) => `  Emotion ${i+1}: ${typeof s === 'string' ? s.slice(0,60) : s.text?.slice(0,60)}...`).join('\\n') || '  (none)'}
${state.categories?.clarity?.snippets?.slice(0,3).map((s,i) => `  Clarity ${i+1}: ${typeof s === 'string' ? s.slice(0,60) : s.text?.slice(0,60)}...`).join('\\n') || '  (none)'}
${state.categories?.cxRisk?.snippets?.slice(0,3).map((s,i) => `  CX Risk ${i+1}: ${typeof s === 'string' ? s.slice(0,60) : s.text?.slice(0,60)}...`).join('\\n') || '  (none)'}
${state.categories?.safety?.snippets?.slice(0,3).map((s,i) => `  Safety ${i+1}: ${typeof s === 'string' ? s.slice(0,60) : s.text?.slice(0,60)}...`).join('\\n') || '  (none)'}`;
        devMlcxSummary.textContent = summary;
      }

      // Section 3: Demo Text Blocks
      const devDemoBlocks = document.getElementById("devDemoBlocks");
      if (devDemoBlocks){
        devDemoBlocks.innerHTML = demoBlocks.map((block, index) => `
          <div class="dev-demo-block">
            <div class="dev-demo-label">${block.label}</div>
            <button class="dev-demo-btn" data-demo-index="${index}">Copy to Clipboard</button>
          </div>
        `).join('');

        // Wire copy buttons
        devDemoBlocks.querySelectorAll('.dev-demo-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            const index = parseInt(btn.dataset.demoIndex, 10);
            const block = demoBlocks[index];
            if (block && block.text){
              if (navigator.clipboard && navigator.clipboard.writeText){
                navigator.clipboard.writeText(block.text).then(() => {
                  console.log(`[Dev Lab] Copied demo block: ${block.label}`);
                  btn.textContent = "✓ Copied!";
                  setTimeout(() => { btn.textContent = "Copy to Clipboard"; }, 1500);
                }).catch(err => {
                  console.warn("[Dev Lab] Clipboard write failed:", err);
                });
              } else {
                console.warn("[Dev Lab] Clipboard API not available");
              }
            }
          });
        });
      }
    }
      try { if (typeof window.updateDevLabHealthPanel === 'function') window.updateDevLabHealthPanel(); } catch (e) {}
    window.refreshDevLabContent = refreshDevLabContent;

    // Refresh when switching to dev layout + close CX drawer
    document.addEventListener("layoutchange", (evt) => {
      if (evt.detail && evt.detail.mode === "dev"){
        refreshDevLabContent();
        // Close CX drawer in dev mode
        const cxDrawerOverlay = document.getElementById("cxDrawerOverlay");
        if (cxDrawerOverlay) {
          cxDrawerOverlay.setAttribute("aria-hidden", "true");
        }
      }
    });

    // Initial render if starting in dev layout
    if (document.body.dataset.layout === "dev"){
      refreshDevLabContent();
    }

    // Phase 19.4: Dev Lab view toggle (MLCX Debug / Library Editor)
    const devPanel = document.querySelector(".dev-panel");
    const viewToggleBtns = document.querySelectorAll(".dev-view-toggle-btn");

    viewToggleBtns.forEach(btn => {
      btn.addEventListener("click", () => {
        const targetView = btn.dataset.targetView;
        if (devPanel.dataset.devView === targetView) return;
        devPanel.dataset.devView = targetView;
        if (targetView === "editor") {
          renderDevLibraryEditor();
        }
      });
    });

    // Phase 19.6: Three-Column Library Editor with Navigator + Collapsible Sections
    let devSelection = new Set();
    let devCurrentEditId = null;
    let devCurrentLibrary = "replies";
    let devSearchQuery = "";

    const devEditorActiveList = document.getElementById("devEditorActiveList");
    const devEditorWaitingList = document.getElementById("devEditorWaitingList");
    const devEditorTitle = document.getElementById("devEditorTitle");
    const devEditorTextarea = document.getElementById("devEditorTextarea");
    const devEditorGroupSelect = document.getElementById("devEditorGroupSelect");
    const devEditorSearch = document.getElementById("devEditorSearch");
    const devSaveItem = document.getElementById("devSaveItem");
    const devDuplicateItem = document.getElementById("devDuplicateItem");
    const devArchiveItem = document.getElementById("devArchiveItem");
    const devDeleteItem = document.getElementById("devDeleteItem");
    const devAddNewItem = document.getElementById("devAddNewItem");
    const devActiveSection = document.getElementById("devActiveSection");
    const devWaitingSection = document.getElementById("devWaitingSection");

    function getCurrentLibraryArray() {
      return devCurrentLibrary === "replies" ? repliesLibrary : phrasesLibrary;
    }

    function filterLibrary(library) {
      if (!devSearchQuery) return library;
      const query = devSearchQuery.toLowerCase();
      return library.filter(item =>
        item.text.toLowerCase().includes(query) ||
        item.group.toLowerCase().includes(query) ||
        item.id.toLowerCase().includes(query)
      );
    }

    function renderDevLibraryEditor() {
      const library = getCurrentLibraryArray();
      const filtered = filterLibrary(library);
      
      const activeItems = filtered.filter(item => item.active);
      const waitingItems = filtered.filter(item => !item.active);

      renderItemList(devEditorActiveList, activeItems);
      renderItemList(devEditorWaitingList, waitingItems);
    }

    function renderItemList(container, items) {
      if (!container) return;
      container.innerHTML = "";

      if (items.length === 0) {
        container.innerHTML = `<div style="font-size:0.72rem;color:var(--text-muted);padding:12px;text-align:center;">No items</div>`;
        return;
      }

      items.forEach(item => {
        const div = document.createElement("div");
        div.className = "dev-editor-item";
        if (!item.active) div.classList.add("is-archived");
        if (devCurrentEditId === item.id) div.classList.add("is-selected");
        div.dataset.id = item.id;

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.className = "dev-editor-item-checkbox";
        checkbox.checked = devSelection.has(item.id);
        checkbox.addEventListener("change", (e) => {
          e.stopPropagation();
          if (checkbox.checked) {
            devSelection.add(item.id);
          } else {
            devSelection.delete(item.id);
          }
        });

        const content = document.createElement("div");
        content.className = "dev-editor-item-content";
        const preview = item.text || '<em style="color:var(--text-muted);">Empty item</em>';
        const truncated = preview.length > 70 ? preview.substring(0, 70) + "..." : preview;
        content.innerHTML = `
          <div class="dev-editor-item-preview">${truncated}</div>
          <div class="dev-editor-item-meta">${item.group} · ${item.id}</div>
        `;
        content.addEventListener("click", () => {
          devCurrentEditId = item.id;
          loadItemIntoEditor(item);
          renderDevLibraryEditor();
        });

        div.appendChild(checkbox);
        div.appendChild(content);
        container.appendChild(div);
      });
    }

    function loadItemIntoEditor(item) {
      if (!item) {
        devEditorTitle.textContent = "Template Editor";
        devEditorTextarea.value = "";
        devEditorGroupSelect.innerHTML = '<option value="">Select an item first</option>';
        devEditorGroupSelect.disabled = true;
        if (devArchiveItem) devArchiveItem.disabled = true;
        if (devDuplicateItem) devDuplicateItem.disabled = true;
        if (devSaveItem) devSaveItem.disabled = true;
        if (devDeleteItem) devDeleteItem.disabled = true;
        return;
      }

      devEditorTitle.textContent = `Editing: ${item.id}`;
      devEditorTextarea.value = item.text;
      updateGroupDropdown();
      devEditorGroupSelect.value = item.group;
      devEditorGroupSelect.disabled = false;
      if (devArchiveItem) devArchiveItem.disabled = false;
      if (devDuplicateItem) devDuplicateItem.disabled = false;
      if (devSaveItem) devSaveItem.disabled = false;
      if (devDeleteItem) devDeleteItem.disabled = false;
      
      // Update archive button text
      if (devArchiveItem) {
        if (item.active) {
          devArchiveItem.textContent = "Archive";
          devArchiveItem.dataset.archived = "false";
        } else {
          devArchiveItem.textContent = "Restore";
          devArchiveItem.dataset.archived = "true";
        }
      }
    }

    function updateGroupDropdown() {
      if (!devEditorGroupSelect || !devCurrentEditId) return;
      
      let groups = [];
      if (devCurrentLibrary === "replies") {
        groups = ["Opening", "Acknowledgement", "Resolution", "Closing"];
      } else if (devCurrentLibrary === "phrases") {
        groups = ["Empathy", "Clarification", "Reassurance", "Appreciation"];
      }
      
      devEditorGroupSelect.innerHTML = groups.map(g => `<option value="${g}">${g}</option>`).join("");
      
      const library = getCurrentLibraryArray();
      const item = library.find(t => t.id === devCurrentEditId);
      if (item) {
        devEditorGroupSelect.value = item.group;
      }
    }

    // Library Navigator
    const navBtns = document.querySelectorAll(".dev-editor-nav-btn[data-library]");
    navBtns.forEach(btn => {
      btn.addEventListener("click", () => {
        devCurrentLibrary = btn.dataset.library;
        navBtns.forEach(b => b.classList.remove("is-active"));
        btn.classList.add("is-active");
        devSelection.clear();
        devCurrentEditId = null;
        loadItemIntoEditor(null);
        renderDevLibraryEditor();
      });
    });

    // Search
    if (devEditorSearch) {
      devEditorSearch.addEventListener("input", (e) => {
        devSearchQuery = e.target.value.trim();
        renderDevLibraryEditor();
      });
    }

    // Collapsible sections
    [devActiveSection, devWaitingSection].forEach(section => {
      if (!section) return;
      const header = section.querySelector(".dev-editor-section-header");
      if (header) {
        header.addEventListener("click", () => {
          section.classList.toggle("is-collapsed");
        });
      }
    });

    // Add New Item
    if (devAddNewItem) {
      devAddNewItem.addEventListener("click", () => {
        const library = getCurrentLibraryArray();
        const prefix = devCurrentLibrary === "replies" ? "reply_" : "phrase_";
        const existingIds = library.map(t => t.id).filter(id => id.startsWith(prefix));
        const numbers = existingIds.map(id => parseInt(id.split("_")[1]) || 0);
        const nextNum = numbers.length > 0 ? Math.max(...numbers) + 1 : library.length + 1;
        const newId = `${prefix}${nextNum}`;

        const defaultGroup = devCurrentLibrary === "replies" ? "Opening" : "Empathy";
        const newItem = {
          id: newId,
          group: defaultGroup,
          text: "",
          active: true
        };

        library.push(newItem);
        devCurrentEditId = newId;
        renderRepliesAndPhrasesFromLibrary();
        renderDevLibraryEditor();
        loadItemIntoEditor(newItem);
        devEditorTextarea.focus();
        console.log("[DevEditor] Created:", newId);
      });
    }

    // Save item
    if (devSaveItem) {
      devSaveItem.addEventListener("click", () => {
        if (!devCurrentEditId) return;
        const library = getCurrentLibraryArray();
        const item = library.find(t => t.id === devCurrentEditId);
        if (item) {
          item.text = devEditorTextarea.value.trim();
          item.group = devEditorGroupSelect.value;
          renderRepliesAndPhrasesFromLibrary();
          renderDevLibraryEditor();
          loadItemIntoEditor(item);
          console.log("[DevEditor] Saved:", item.id);
        }
      });
    }

    // Duplicate item
    if (devDuplicateItem) {
      devDuplicateItem.addEventListener("click", () => {
        if (!devCurrentEditId) return;
        const library = getCurrentLibraryArray();
        const item = library.find(t => t.id === devCurrentEditId);
        if (!item) return;

        const prefix = devCurrentLibrary === "replies" ? "reply_" : "phrase_";
        const existingIds = library.map(t => t.id).filter(id => id.startsWith(prefix));
        const numbers = existingIds.map(id => parseInt(id.split("_")[1]) || 0);
        const nextNum = numbers.length > 0 ? Math.max(...numbers) + 1 : library.length + 1;
        const newId = `${prefix}${nextNum}`;

        const duplicate = {
          id: newId,
          group: item.group,
          text: item.text + " (copy)",
          active: item.active
        };

        library.push(duplicate);
        devCurrentEditId = newId;
        renderRepliesAndPhrasesFromLibrary();
        renderDevLibraryEditor();
        loadItemIntoEditor(duplicate);
        console.log("[DevEditor] Duplicated:", item.id, "→", newId);
      });
    }

    // Archive/Restore item
    if (devArchiveItem) {
      devArchiveItem.addEventListener("click", () => {
        if (!devCurrentEditId) return;
        const library = getCurrentLibraryArray();
        const item = library.find(t => t.id === devCurrentEditId);
        if (!item) return;

        item.active = !item.active;
        renderRepliesAndPhrasesFromLibrary();
        renderDevLibraryEditor();
        loadItemIntoEditor(item);
        console.log("[DevEditor]", item.active ? "Restored:" : "Archived:", item.id);
      });
    }

    // Delete item
    if (devDeleteItem) {
      devDeleteItem.addEventListener("click", () => {
        if (!devCurrentEditId) return;
        if (!confirm("Delete this item? This cannot be undone.")) return;

        const library = getCurrentLibraryArray();
        const index = library.findIndex(t => t.id === devCurrentEditId);
        if (index !== -1) {
          library.splice(index, 1);
          devCurrentEditId = null;
          loadItemIntoEditor(null);
          renderRepliesAndPhrasesFromLibrary();
          renderDevLibraryEditor();
          console.log("[DevEditor] Deleted");
        }
      });
    }

    // Group selector change
    if (devEditorGroupSelect) {
      devEditorGroupSelect.addEventListener("change", () => {
        if (!devCurrentEditId) return;
        const library = getCurrentLibraryArray();
        const item = library.find(t => t.id === devCurrentEditId);
        if (item) {
          item.group = devEditorGroupSelect.value;
          renderDevLibraryEditor();
          console.log("[DevEditor] Changed group:", item.id, "→", item.group);
        }
      });
    }

    // Bulk actions
    const bulkBtns = document.querySelectorAll(".dev-editor-bulk-btn[data-action]");
    bulkBtns.forEach(btn => {
      btn.addEventListener("click", () => {
        const action = btn.dataset.action;
        const section = btn.closest(".dev-editor-section");
        const listContainer = section ? section.querySelector(".dev-editor-section-content") : null;
        if (!listContainer) return;

        // Get selected items from this section only
        const sectionCheckboxes = listContainer.querySelectorAll(".dev-editor-item-checkbox:checked");
        const sectionIds = Array.from(sectionCheckboxes).map(cb => cb.closest(".dev-editor-item").dataset.id);
        
        if (sectionIds.length === 0) return;

        const library = getCurrentLibraryArray();

        if (action === "delete-active" || action === "delete-waiting") {
          if (!confirm(`Delete ${sectionIds.length} item(s)? This cannot be undone.`)) return;
          sectionIds.forEach(id => {
            const index = library.findIndex(t => t.id === id);
            if (index !== -1) library.splice(index, 1);
          });
          if (sectionIds.includes(devCurrentEditId)) {
            devCurrentEditId = null;
            loadItemIntoEditor(null);
          }
        } else if (action === "archive-active") {
          sectionIds.forEach(id => {
            const item = library.find(t => t.id === id);
            if (item) item.active = false;
          });
        } else if (action === "activate-waiting") {
          sectionIds.forEach(id => {
            const item = library.find(t => t.id === id);
            if (item) item.active = true;
          });
        }

        devSelection.clear();
        renderRepliesAndPhrasesFromLibrary();
        renderDevLibraryEditor();
        if (devCurrentEditId) {
          const item = library.find(t => t.id === devCurrentEditId);
          loadItemIntoEditor(item);
        }
        console.log("[DevEditor] Bulk action:", action, sectionIds);
      });
    });

    window.renderDevLibraryEditor = renderDevLibraryEditor;
  })();

  // Phase 11: Render snapshot history list on Notepad layout
  function renderMlcxSnapshotList(){
    // Only render in MLCX (Notepad) layout
    if (document.body.dataset.layout !== "mlcx") return;

    const header = document.querySelector(".mlcx-og-header");
    if (!header) return;

    // Create or update snapshot list container
    let listContainer = document.getElementById("mlcxSnapshotList");
    if (!listContainer){
      listContainer = document.createElement("div");
      listContainer.id = "mlcxSnapshotList";
      listContainer.style.cssText = "margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-3); max-height: 8rem; overflow-y: auto; border-top: 1px solid var(--border-1); padding-top: 0.5rem;";
      // Insert after summary line if exists, else append to header
      const summary = document.getElementById("mlcxNotepadSummary");
      if (summary && summary.nextSibling){
        header.insertBefore(listContainer, summary.nextSibling);
      } else {
        header.appendChild(listContainer);
      }
    }

    // Build list HTML
    if (mlcxSnapshots.length === 0){
      listContainer.innerHTML = "<em style='color: var(--text-4);'>No snapshots yet</em>";
      return;
    }

    const items = mlcxSnapshots.map(snap => {
      const severityColor = snap.severityBand === "high" ? "#e74c3c" : snap.severityBand === "medium" ? "#f39c12" : "#27ae60";
      const severityLabel = snap.severityBand.charAt(0).toUpperCase() + snap.severityBand.slice(1);
      return `<div style="margin-bottom: 0.25rem; line-height: 1.4;">
        <span style="font-weight: 500;">${snap.timestamp}</span> - 
        <span style="color: ${severityColor}; font-weight: 600;">${severityLabel}</span>
        <span style="color: var(--text-4);"> (Emotion ${snap.totals.emotion} · Clarity ${snap.totals.clarity} · CX ${snap.totals.cxRisk} · Safety ${snap.totals.safety})</span>
      </div>`;
    }).join("");

    listContainer.innerHTML = items;
  }

  /* Phase 12: Dev helper to build and copy concise MLCX summary (no UI changes) */
  function buildMlcxSummaryText(state){
    if (!state){
      return "MLCX: No state available.";
    }
    const severityMap = { low: "Low concern", medium: "Medium concern", high: "High concern" };
    const sevLabel = severityMap[state.severityBand] || state.severityBand;
    const cats = state.categories || {};
    const emotionCount = (cats.emotion && cats.emotion.count) || 0;
    const clarityCount = (cats.clarity && cats.clarity.count) || 0;
    const cxRiskCount  = (cats.cxRisk && cats.cxRisk.count) || 0;
    const safetyCount  = (cats.safety && cats.safety.count) || 0;

    // Collect up to two representative snippets (first available per category order)
    const snippets = [];
    ["emotion","clarity","cxRisk","safety"].forEach(cat => {
      if (snippets.length >= 2) return;
      const arr = (cats[cat] && cats[cat].snippets) ? cats[cat].snippets : [];
      if (arr.length){
        let sn = arr[0];
        if (typeof sn !== "string") sn = String(sn || "");
        sn = sn.replace(/\s+/g, " ").trim();
        if (sn.length > 80) sn = sn.slice(0,77) + "…";
        snippets.push(`'${sn}'`);
      }
    });
    const snippetPart = snippets.length ? ` Key snippets: ${snippets.join(", ")}.` : " Key snippets: none.";
    return `MLCX: ${sevLabel}. Emotion ${emotionCount}, Clarity ${clarityCount}, CX Risk ${cxRiskCount}, Safety ${safetyCount}.${snippetPart}`;
  }

  async function copyMlcxSummaryToClipboard(){
    try {
      let state = (typeof window.debugMlcxState === "function") ? window.debugMlcxState() : null;
      if (!state && typeof window.runMlcxAnalysis === "function"){
        state = window.runMlcxAnalysis();
      }
      const summary = buildMlcxSummaryText(state);
      if (navigator.clipboard && navigator.clipboard.writeText){
        await navigator.clipboard.writeText(summary);
        console.info("[MLCX] Summary copied to clipboard.", summary);
        return true;
      }
      // Fallback attempt
      const ta = document.createElement("textarea");
      ta.value = summary;
      ta.style.position = "fixed";
      ta.style.opacity = "0";
      document.body.appendChild(ta);
      ta.focus();
      ta.select();
      const ok = document.execCommand && document.execCommand("copy");
      document.body.removeChild(ta);
      if (ok){
        console.info("[MLCX] Summary copied via fallback.", summary);
        return true;
      }
      console.warn("[MLCX] Clipboard API unavailable; copy fallback failed.", summary);
      return false;
    } catch (err){
      console.warn("[MLCX] Clipboard copy error", err);
      return false;
    }
  }

  // Expose Phase 12 dev helper
  window.copyMlcxSummary = copyMlcxSummaryToClipboard;

  /* Phase 15: Internal self-test harness (manual invocation only) */
  function runMlcxSelfTest(){
    const cases = [
      {
        id: 1,
        customer: "I am really frustrated and upset about these unexpected charges. This is costing me more than I can afford and I'm overwhelmed.",
        agent: "We can review the billing details and ensure clarity.",
        notes: "", // agent notes empty
        expected: "high"
      },
      {
        id: 2,
        customer: "I'm confused about the process and worried about the extra fee.",
        agent: "Let me clarify the next steps for you.",
        notes: "",
        expected: "medium"
      },
      {
        id: 3,
        customer: "Thanks, that helps.",
        agent: "Glad it's clearer now.",
        notes: "",
        expected: "low"
      },
      {
        id: 4,
        customer: "My elderly mother depends on this and I'm anxious we might lose support.",
        agent: "I'll make sure we protect her access.",
        notes: "",
        expected: "medium" // safety + emotion triggers likely push into medium
      },
      {
        id: 5,
        customer: "I don't understand any of this jargon, it's confusing and stressing me out.",
        agent: "I'll simplify the explanation.",
        notes: "",
        expected: "medium"
      }
    ];

    console.group("[MLCX-TEST] Starting self-test (" + cases.length + " cases)");
    cases.forEach(c => {
      const res = analyseMlcxSignals(c.customer, c.agent, c.notes);
      const summary = `Case ${c.id} expected: ${c.expected}, actual: ${res.severityBand}`;
      console.log(summary, {
        counts: {
          emotion: res.categories.emotion.count,
          clarity: res.categories.clarity.count,
          cxRisk: res.categories.cxRisk.count,
          safety: res.categories.safety.count
        },
        snippets: {
          emotion: res.categories.emotion.snippets.slice(0,2),
          clarity: res.categories.clarity.snippets.slice(0,2),
          cxRisk: res.categories.cxRisk.snippets.slice(0,2),
          safety: res.categories.safety.snippets.slice(0,2)
        }
      });
    });
    console.groupEnd();
    console.info("[MLCX-TEST] Completed. Review mismatches manually; no assertions thrown.");
  }

  // Expose Phase 15 dev helper
  window.runMlcxSelfTest = runMlcxSelfTest;

})();
</script>
<div class="context-menu" hidden="" id="editorContextMenu">
<button data-cmd="copy">Copy</button>
<button data-cmd="cut">Cut</button>
<button data-cmd="paste">Paste</button>
<div class="context-divider" data-role="issue-divider" hidden=""></div>
<button data-cmd="applySuggestion" data-role="issue-action" hidden="">Apply suggestion</button>
<button data-cmd="ignoreIssue" data-role="issue-action" hidden="">Ignore</button>
</div>
<!-- Dimension controls overlay removed for final build -->
<script>
 // Phase 19.4: Replies / Phrases library system (flat item structure with IDs + active flag)
 const repliesLibrary = [];
 const phrasesLibrary = [];

 // Hydrate libraries from existing DOM structure
 function hydrateLibrariesFromDOM() {
   const repliesPanel = document.getElementById("repliesPanel");
   const phrasesPanel = document.getElementById("phrasesPanel");

   function extractLibrary(panel, prefix) {
     const items = [];
     if (!panel) return items;

     let currentGroup = "";
     let itemCounter = 0;
     const children = Array.from(panel.children);

     for (const child of children) {
       if (child.classList.contains("qr-label")) {
         currentGroup = child.textContent.trim();
       } else if (child.classList.contains("qr-item")) {
         itemCounter++;
         items.push({
           id: `${prefix}_${itemCounter}`,
           group: currentGroup,
           text: child.textContent.trim(),
           active: true  // default all existing templates to active
         });
       }
     }

     return items;
   }

   repliesLibrary.length = 0;
   extractLibrary(repliesPanel, "reply").forEach(item => repliesLibrary.push(item));

   phrasesLibrary.length = 0;
   extractLibrary(phrasesPanel, "phrase").forEach(item => phrasesLibrary.push(item));

   console.log("[Library] Hydrated from DOM:", { 
     replies: repliesLibrary.length, 
     phrases: phrasesLibrary.length 
   });
 }

 // Render libraries back to DOM (only active items)
 function renderRepliesAndPhrasesFromLibrary() {
   const repliesPanel = document.getElementById("repliesPanel");
   const phrasesPanel = document.getElementById("phrasesPanel");

   function renderLibrary(panel, library) {
     if (!panel) return;
     panel.innerHTML = "";

     // Filter to active items only
     const activeItems = library.filter(item => item.active);
     
     // Group active items by their group property
     const grouped = {};
     activeItems.forEach(item => {
       if (!grouped[item.group]) {
         grouped[item.group] = [];
       }
       grouped[item.group].push(item);
     });

     const groupNames = Object.keys(grouped);
     groupNames.forEach((groupName, groupIndex) => {
       const labelDiv = document.createElement("div");
       labelDiv.className = "qr-label";
       labelDiv.textContent = groupName;
       panel.appendChild(labelDiv);

       grouped[groupName].forEach(item => {
         const itemDiv = document.createElement("div");
         itemDiv.className = "qr-item";
         itemDiv.textContent = item.text;
         panel.appendChild(itemDiv);
       });

       if (groupIndex < groupNames.length - 1) {
         const divider = document.createElement("div");
         divider.className = "qr-divider";
         panel.appendChild(divider);
       }
     });
   }

   renderLibrary(repliesPanel, repliesLibrary);
   renderLibrary(phrasesPanel, phrasesLibrary);

   console.log("[Library] Rendered to DOM (active items only)");
 }

 // Debug hooks (Phase 19.3 + 19.4)
 window.debugRepliesLibrary = () => ({ repliesLibrary, phrasesLibrary });
 window.dumpTemplateLibraries = () => ({
   replies: repliesLibrary,
   phrases: phrasesLibrary
 });

 // Hydrate on load
 if (document.readyState === "loading") {
   document.addEventListener("DOMContentLoaded", () => {
     hydrateLibrariesFromDOM();
     renderRepliesAndPhrasesFromLibrary();
   });
 } else {
   hydrateLibrariesFromDOM();
   renderRepliesAndPhrasesFromLibrary();
 }

 // Replies / Phrases dropdown logic (anchored to toolbar)
(function () {
  const agentInput  = document.getElementById("agentInput");
  const customerMsg = document.getElementById("customerInput");

  if (!agentInput) return;

  const allPanels = document.querySelectorAll("#repliesPanel, #phrasesPanel");

  function setupDropdown(btnId, panelId) {
    const btn   = document.getElementById(btnId);
    const panel = document.getElementById(panelId);

    if (!btn || !panel) return;

    function closePanel() {
      panel.classList.remove("visible");
    }

    btn.addEventListener("click", function (e) {
      e.stopPropagation();

      // Close any other open panel
      allPanels.forEach(p => {
        if (p !== panel) p.classList.remove("visible");
      });

      // Position the panel under the clicked button, anchored to the toolbar
      const toolbar = btn.closest(".toolbar");
      const tbRect  = toolbar ? toolbar.getBoundingClientRect() : { left: 0, top: 0 };
      const btnRect = btn.getBoundingClientRect();

      panel.style.left = (btnRect.left - tbRect.left) + "px";
      panel.style.top  = (btnRect.bottom - tbRect.top + 8) + "px";

      panel.classList.toggle("visible");
    });

    // Close when clicking outside
    document.addEventListener("click", function (e) {
      if (!panel.contains(e.target) && e.target !== btn) {
        closePanel();
      }
    });

    // Insert text when a template is clicked
    panel.addEventListener("click", function (e) {
      const item = e.target.closest(".qr-item");
      if (!item) return;

      let text = item.textContent.trim();

      // Optional: auto-[name] from customer message
      let name = "there";
      if (customerMsg && customerMsg.value) {
        const match = customerMsg.value.match(/\b([A-Z][a-z]{1,})\b/);
        if (match) name = match[1];
      }
      text = text.replace("[name]", name);

      agentInput.focus();

      // Sentence-aware insertion: put each sentence on its own line
      // with a blank line between groups for Messenger-style layout.
      (function () {
        let output = text.trim();

        // Basic sentence splitter – keeps punctuation.
        const sentences = output.match(/[^.!?\u2026]+[.!?\u2026]?/g);

        if (sentences && sentences.length > 1) {
          output = sentences
            .map(s => s.trim())
            .filter(s => s.length > 0)
            .join("\n\n");
        }

        document.execCommand("insertText", false, output + "\n");
      })();;

      // Normalise + run your SpellLite pipeline
      setTimeout(() => {
        agentInput.innerHTML = cleanHtml(agentInput.innerHTML || "");
        runCleanPipeline();
      }, 10);

      closePanel();
    });
  }

  setupDropdown("repliesBtn", "repliesPanel");
  setupDropdown("phrasesBtn", "phrasesPanel");
})();

// 🔹 Rolling agent tips ticker in the phone input bar
const AGENT_TIPS = [
  "One idea per sentence keeps things clear.",
  "Use the customer’s name once - it helps it feel personal.",
  "If you’re not sure, say what you can do next, not what you can’t.",
  "Avoid jargon where possible - plain language wins.",
  "Check names, dates and amounts before sending your reply.",
  "Short paragraphs are easier to read on mobile.",
  "If you’ve made a mistake, own it and fix it quickly.",
  "Summarise long chats in one clear closing message.",
  "Let the customer know what will happen after the chat ends.",
  "Use reassuring phrases like “I’ll keep you updated” or “I’ll watch this for you”.",
  "If you need time to check, tell them what you’re checking.",
  "Match the customer’s tone - calm, steady, and helpful.",
  "If it’s bad news, be clear and kind, not robotic.",
  "If you’ve asked a question, give them space to answer.",
  "Always double-check spelling of names and registration numbers.",
  "If your reply looks like a WhatsApp rant, breathe and rewrite it.",
  "The spellchecker is your co-pilot - you still fly the message."
];


(function setupAgentTips() {
  const el = document.getElementById("agentTipTicker");
  if (!el || !AGENT_TIPS.length) return;

  // Little send icon inside the phone input bar
  const sendIcon = document.querySelector(".chat-input-send");

  let tipIndex = 0;
  let charIndex = 0;
  let glitchThisTip = false;
  let glitchPosition = 0;
  let glitchDone = false;

  // Track when a tip is fully on screen and any pending "hold" timeout
  let tipComplete = false;
  let holdTimeoutId = null;

  function prepareTipBehaviour(tip) {
    // Decide if this tip will do the little "typo then fix" flourish
    glitchThisTip = tip.length > 30 && Math.random() < 0.28;
    glitchPosition = glitchThisTip ? Math.floor(tip.length * 0.45) : 0;
    glitchDone = false;
  }

  // Jump to the next tip, either because the timer expired or the agent
  // "sent" a message using the phone send icon.
  function jumpToNextTip() {
    if (!tipComplete) return;

    tipComplete = false;

    if (holdTimeoutId) {
      clearTimeout(holdTimeoutId);
      holdTimeoutId = null;
    }

    el.classList.remove("tip-fade-in");
    el.classList.add("tip-fade-out");

    setTimeout(() => {
      tipIndex = (tipIndex + 1) % AGENT_TIPS.length;
      charIndex = 0;
      el.textContent = "";
      el.classList.remove("tip-fade-out");
      typeCurrentTip();
    }, 220);
  }

  function typeCurrentTip() {
    const tip = AGENT_TIPS[tipIndex];

    if (charIndex === 0) {
      // Starting a new tip
      el.textContent = "";
      el.classList.remove("tip-fade-out");
      el.classList.add("tip-fade-in");
      prepareTipBehaviour(tip);
    }

    // Optional tiny "bug into feature" moment:
    // occasionally insert a small wrong word, then delete it and carry on.
    if (glitchThisTip && !glitchDone && charIndex === glitchPosition) {
      const wrongChunk = " teh ";
      el.textContent += wrongChunk;
      glitchDone = true;

      // Pause briefly, then erase the wrong bit and resume normal typing
      setTimeout(() => {
        el.textContent = el.textContent.slice(0, -wrongChunk.length);
        typeCurrentTip();
      }, 500);
      return;
    }

    if (charIndex < tip.length) {
      tipComplete = false;
      el.textContent += tip.charAt(charIndex);
      charIndex++;
      // Typing speed (ms per character)
      const delay = 80 + Math.random() * 40;
      setTimeout(typeCurrentTip, delay);
    } else {
      // Finished typing: hold the full tip on screen for longer (1–2 minutes)
      tipComplete = true;
      const holdMs = 60000 + Math.random() * 60000; // 60–120 seconds
      holdTimeoutId = setTimeout(() => {
        jumpToNextTip();
      }, holdMs);
    }
  }

  // Hook the phone send icon so agents can manually step to the next tip
  if (sendIcon) {
    sendIcon.addEventListener("click", () => {
      jumpToNextTip();
    });
  }

  typeCurrentTip();
})();</script>
<script>
  (function setupLayoutToggle() {
    const btn = document.getElementById("viewToggleBtn");
    if (!btn) return;
    const labelSpan = btn.querySelector(".view-toggle-btn-label");
    const iconSpan = btn.querySelector(".view-toggle-btn-icon");

    function syncLayoutToggle() {
      const mode = document.body.dataset.layout || "split";
      let label = "";
      let icon = "";
      let aria = "";

      if (mode === "split") {
        label = "Full text";
        icon = "⤢";
        aria = "Enter full text mode (hide phone preview)";
      } else if (mode === "notepad") {
        label = "MLCX coach";
        icon = "⚡";
        aria = "Enter MLCX coaching notepad view";
      } else {
        // MLCX mode
        label = "Split view";
        icon = "▣";
        aria = "Return to split view with phone preview";
      }

      if (labelSpan) {
        labelSpan.textContent = label;
      }
      if (iconSpan) {
        iconSpan.textContent = icon;
      }

      // Consider any non-split state as "pressed"
      btn.setAttribute("aria-pressed", mode === "split" ? "false" : "true");
      btn.setAttribute("aria-label", aria);
    }

    btn.addEventListener("click", () => {
      const current = document.body.dataset.layout || "split";
      let next;
      if (current === "split") {
        next = "notepad";
      } else if (current === "notepad") {
        next = "mlcx";
      } else {
        next = "split";
      }
      document.body.dataset.layout = next;
      syncLayoutToggle();
      document.dispatchEvent(new CustomEvent("layoutchange", { detail: { mode: next } }));
    });

    syncLayoutToggle();
    document.dispatchEvent(new CustomEvent("layoutchange", { detail: { mode: document.body.dataset.layout || "split" } }));
  })();

  // Phase 9 + 11: Refresh notepad summary & snapshot list on layout switch to MLCX
  document.addEventListener("layoutchange", (evt) => {
    if (evt.detail && evt.detail.mode === "mlcx"){
      if (typeof window.runMlcxAnalysis === "function"){
        window.runMlcxAnalysis();
            // Phase 11: snapshot on layout switch & render history
            if (typeof renderMlcxSnapshotList === "function"){
              renderMlcxSnapshotList();
            }
      }
    }
  });
</script>
<script>
// Hard sync agent editor -> phone preview bubble
document.addEventListener('DOMContentLoaded', function () {
  var agentInput = document.getElementById('agentInput');
  var agentBubble = document.getElementById('agentBubble');

  if (!agentInput || !agentBubble) return;

  function simpleClean(html) {
    // Basic normalisation: trim and avoid empty <div><br></div> spam
    if (!html) return "";
    // Replace multiple <div> with breaks
    html = html.replace(/<div><br><\/div>/gi, '<br>');
    html = html.replace(/<div>/gi, '<br>');
    html = html.replace(/<\/div>/gi, '');
    return html.trim();
  }

  function syncAgentToPhone() {
    var raw = agentInput.innerHTML || "";
    var cleaned = simpleClean(raw);

    if (!cleaned) {
      agentBubble.innerHTML = "<p>Hi,<br>Thanks for reaching out, how can I help?</p>";
    } else {
      agentBubble.innerHTML = "<p>" + cleaned + "</p>";
    }
  }

  agentInput.addEventListener('input', syncAgentToPhone);
  agentInput.addEventListener('keyup', syncAgentToPhone);
  agentInput.addEventListener('blur', syncAgentToPhone);

  // Initial sync on load
  syncAgentToPhone();
});

  // --- MLCX coach panel interactions ---
  if (mlcxRails && mlcxCoachPanel && mlcxCoachSentence && mlcxCoachMessage) {
    mlcxRails.addEventListener("click", function (e) {
      const target = e.target.closest(".mlcx-sentence");
      if (!target) return;
      const msg = target.dataset.coachMessage || "";
      const sentenceText = target.textContent || "";
      if (!msg && !sentenceText) return;

      mlcxCoachSentence.textContent = sentenceText;
      mlcxCoachMessage.textContent = msg;
      mlcxCoachPanel.classList.remove("mlcx-coach-hidden");
    });
  }
  if (mlcxCoachClose && mlcxCoachPanel) {
    mlcxCoachClose.addEventListener("click", function () {
      mlcxCoachPanel.classList.add("mlcx-coach-hidden");
    });
  }
</script>
<script>
  (function setupLayoutCornerSwitch() {
    const buttons = document.querySelectorAll(".layout-mode-btn");
    if (!buttons.length) return;

    function updateButtons(mode) {
      const current = mode || (document.body.dataset.layout || "split");
      buttons.forEach((btn) => {
        const target = btn.dataset.targetLayout;
        if (!target) return;
        const isCurrent = target === current;
        btn.disabled = isCurrent;
      });
    }

    buttons.forEach((btn) => {
      btn.addEventListener("click", () => {
        const target = btn.dataset.targetLayout;
        if (!target) return;
        if (document.body.dataset.layout === target) return;
        document.body.dataset.layout = target;
        document.dispatchEvent(new CustomEvent("layoutchange", { detail: { mode: target } }));
      });
    });

    document.addEventListener("layoutchange", (evt) => {
      const mode = evt.detail && evt.detail.mode;
      updateButtons(mode);
    });

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", () => updateButtons());
    } else {
      updateButtons();
    }
  })();
</script>


<script>
// Phase 16: CX Notch + Sliding Drawer wiring
(function(){
  const notch = document.getElementById("cxNotchToggle");
  const overlay = document.getElementById("cxDrawerOverlay");
  const closeBtn = document.getElementById("cxDrawerClose");
  if (!overlay) return;

  function openDrawer(){
    overlay.classList.add("is-open");
    overlay.setAttribute("aria-hidden", "false");
    notch?.classList.add("is-hot");
    document.body.classList.add("cx-drawer-open");
    // Phase 5: refresh drawer visuals on open
    if (typeof window.runMlcxAnalysis === "function"){
      window.runMlcxAnalysis();
    }
    // MLCX Alpha – vulnerability summary wiring (non-destructive patch)
    if (typeof renderVulnerabilitySummary === "function"){
      renderVulnerabilitySummary();
    }
    if (typeof renderVulnerabilityDebug === "function"){
      renderVulnerabilityDebug();
    }
  }

  function closeDrawer(){
    overlay.classList.remove("is-open");
    overlay.setAttribute("aria-hidden", "true");
    notch?.classList.remove("is-hot");
    document.body.classList.remove("cx-drawer-open");
  }

  function toggleDrawer(){
    if (overlay.classList.contains("is-open")){
      closeDrawer();
    } else {
      openDrawer();
    }
  }

  notch?.addEventListener("click", toggleDrawer);
  if (closeBtn){
    closeBtn.addEventListener("click", closeDrawer);
  }

  // Close when clicking on dimmed backdrop
  const dim = overlay.querySelector(".cx-dim");
  if (dim){
    dim.addEventListener("click", closeDrawer);
  }

  // Esc key handling
  document.addEventListener("keydown", function(evt){
    if (evt.key === "Escape"){
      closeDrawer();
    }
  });

  window.toggleCxDrawer = toggleDrawer;
})();
</script>
<script>
// Phase 19.11: clean gate for Notepad mode to hide/disable CX drawer
function hideCxDrawerCompletely(){
  const notch = document.getElementById("cxNotchToggle");
  const overlay = document.getElementById("cxDrawerOverlay");
  if (overlay){
    overlay.classList.remove("is-open");
    overlay.setAttribute("aria-hidden", "true");
  }
  if (notch){
    notch.classList.remove("is-hot");
    notch.setAttribute("aria-hidden", "true");
  }
}

document.addEventListener("layoutchange", (evt) => {
  const mode = evt.detail && evt.detail.mode;
  if (mode === "dev") {
    hideCxDrawerCompletely();
  } else {
    // restore aria state for other modes
    const notch = document.getElementById("cxNotchToggle");
    if (notch){ notch.removeAttribute("aria-hidden"); }
  }
});
</script>
<script>
// Phase X: Coaching master toggle (single toggle controlling visibility of CX + Writer Insights notches)
(function(){
  const toggleBtn = document.getElementById("coachingMasterToggle");

  // Off by default (as requested)
  let coachingMode = false;

  // Selectors for ALL coaching-gated UI entry points (some are injected later)
  const ENTRY_SELECTORS = [
    "#cxNotchToggle",
    "#cxNotchCallnotesToggle",
    ".cx-notch",
    ".cx-notch-callnotes",
    ".cx-notch-main",
    ".cx-notch-callnotes-main",
    "#msWriterNotch",
    ".ms-writer-notch",
    "[data-role='writer-insights-notch']"
  ];

  const OVERLAY_SELECTORS = [
    "#cxDrawerOverlay",
    "#cxDrawerCallnotesOverlay",
    "#msWriterOverlay",
    "[data-role='writer-insights-overlay']"
  ];

  function qsa(list){
    const out = [];
    list.forEach(sel => {
      document.querySelectorAll(sel).forEach(el => out.push(el));
    });
    return out;
  }

  function closeCxDrawerSoft(){
    // Close messenger + callnotes CX drawers if present
    document.querySelectorAll("#cxDrawerOverlay.is-open, #cxDrawerCallnotesOverlay.is-open").forEach(ov => {
      ov.classList.remove("is-open");
      ov.setAttribute("aria-hidden","true");
    });
    document.body.classList.remove("cx-drawer-open","cx-callnotes-drawer-open");

    // Clear hot state on any notch buttons that exist
    document.querySelectorAll("#cxNotchToggle.is-hot, #cxNotchCallnotesToggle.is-hot, .cx-notch.is-hot, .cx-notch-callnotes.is-hot").forEach(btn=>{
      btn.classList.remove("is-hot");
      btn.setAttribute?.("aria-expanded","false");
    });
  }

  function closeWriterDrawerSoft(){
    const ov = document.querySelector("#msWriterOverlay, [data-role='writer-insights-overlay']");
    if (ov){
      ov.classList.remove("is-open");
      ov.setAttribute("aria-hidden","true");
    }
    document.body.classList.remove("writer-drawer-open");

    document.querySelectorAll("#msWriterNotch.is-hot, .ms-writer-notch.is-hot, [data-role='writer-insights-notch'].is-hot").forEach(btn=>{
      btn.classList.remove("is-hot");
      btn.setAttribute?.("aria-expanded","false");
    });
  }

  function applyCoachingVisibilityCore(){
    const isOn = !!coachingMode;
    document.body.dataset.coaching = isOn ? "on" : "off";

    // If turning OFF, close any open panels first
    if (!isOn){
      closeCxDrawerSoft();
      closeWriterDrawerSoft();
    }

    // Show/Hide all known entry points (re-queried each time, so injected nodes are handled)
    qsa(ENTRY_SELECTORS).forEach(el => {
      el.classList.toggle("is-hidden", !isOn);
      if (!isOn) el.blur?.();
    });

    // Extra safety: while coaching is OFF, ensure overlays cannot flash/appear
    qsa(OVERLAY_SELECTORS).forEach(el => {
      el.classList.toggle("is-hidden", !isOn);
      if (!isOn){
        el.classList.remove("is-open");
        el.setAttribute?.("aria-hidden","true");
      }
    });

    if (toggleBtn){
      toggleBtn.classList.toggle("active", isOn);
      toggleBtn.setAttribute("aria-pressed", String(isOn));
      toggleBtn.textContent = isOn ? "Coach: ON" : "Coach: OFF";
    }
  }

  let __coachApplyScheduled = false;
  let __coachApplyRunning = false;

  function applyCoachingVisibility(){
    // Debounced / rAF-scheduled apply to prevent thrashing when other scripts inject/remove nodes.
    if (__coachApplyScheduled) return;
    __coachApplyScheduled = true;

    requestAnimationFrame(() => {
      __coachApplyScheduled = false;
      if (__coachApplyRunning) return;
      __coachApplyRunning = true;
      try{
        applyCoachingVisibilityCore();
      } finally {
        __coachApplyRunning = false;
      }
    });
  }

  function setCoachingMode(next){
    coachingMode = !!next;
    applyCoachingVisibility();
  }

  toggleBtn?.addEventListener("click", () => setCoachingMode(!coachingMode));

  // Default OFF on load
  setCoachingMode(false);

  // Keep consistent across layout changes
  document.addEventListener("layoutchange", () => applyCoachingVisibility());

  // If any UI is injected after load, re-apply (debounced)
  const mo = new MutationObserver(() => applyCoachingVisibility());
  mo.observe(document.body, {childList:true, subtree:true});

// Expose for quick debug
  window.setCoachingMode = setCoachingMode;
})();</script>



  <!-- Phone spotlight overlay (Mobile Focus) -->
  <div id="phoneSpotlightOverlay" aria-hidden="true">
    <button class="phone-spotlight-close" type="button" aria-label="Exit mobile focus">✕</button>
  </div>

<script>
// CV Notch + Drawer wiring for Call Notes
(function(){
  const cvNotch = document.getElementById("cvNotchCallnotesToggle");
  const cvOverlay = document.getElementById("cvDrawerCallnotesOverlay");
  const cvCloseBtn = document.getElementById("cvDrawerCallnotesClose");
  if (!cvNotch || !cvOverlay) return;

  function openCvDrawer(){
    if (document.body.dataset.layout !== "callnotes") return;
    cvOverlay.classList.add("is-open");
    cvOverlay.setAttribute("aria-hidden", "false");
    cvNotch.classList.add("is-hot");
    // Update CV drawer with latest Call Notes analysis
    if (typeof updateCvCallnotesDrawer === "function"){
      updateCvCallnotesDrawer();
    }
  }

  function closeCvDrawer(){
    cvOverlay.classList.remove("is-open");
    cvOverlay.setAttribute("aria-hidden", "true");
    cvNotch.classList.remove("is-hot");
  }

  function toggleCvDrawer(){
    if (document.body.dataset.layout !== "callnotes") return;
    if (cvOverlay.classList.contains("is-open")){
      closeCvDrawer();
    } else {
      openCvDrawer();
    }
  }

  cvNotch.addEventListener("click", toggleCvDrawer);
  if (cvCloseBtn){
    cvCloseBtn.addEventListener("click", closeCvDrawer);
  }

  // Close when clicking on dimmed backdrop
  const dim = cvOverlay.querySelector(".cx-dim");
  if (dim){
    dim.addEventListener("click", closeCvDrawer);
  }

  // Esc key handling
  document.addEventListener("keydown", function(evt){
    if (evt.key === "Escape"){
      closeCvDrawer();
    }
  });
})();

// CX Notch + Drawer wiring for Call Notes
(function(){
  const cxNotchCallnotes = document.getElementById("cxNotchCallnotesToggle");
  const cxOverlayCallnotes = document.getElementById("cxDrawerCallnotesOverlay");
  const cxCloseBtnCallnotes = document.getElementById("cxDrawerCallnotesClose");
  if (!cxNotchCallnotes || !cxOverlayCallnotes) return;

  function openCxCallnotesDrawer(){
    if (document.body.dataset.layout !== "callnotes") return;
    cxOverlayCallnotes.classList.add("is-open");
    cxOverlayCallnotes.setAttribute("aria-hidden", "false");
    cxNotchCallnotes.classList.add("is-hot");
    document.body.classList.add("cx-callnotes-drawer-open");
    if (typeof updateCxCallnotesDrawerFromPinned === "function"){
      updateCxCallnotesDrawerFromPinned();
    }
  }

  function closeCxCallnotesDrawer(){
    cxOverlayCallnotes.classList.remove("is-open");
    cxOverlayCallnotes.setAttribute("aria-hidden", "true");
    cxNotchCallnotes.classList.remove("is-hot");
    document.body.classList.remove("cx-callnotes-drawer-open");
  }

  function toggleCxCallnotesDrawer(){
    if (document.body.dataset.layout !== "callnotes") return;
    if (cxOverlayCallnotes.classList.contains("is-open")){
      closeCxCallnotesDrawer();
    } else {
      openCxCallnotesDrawer();
    }
  }

  cxNotchCallnotes.addEventListener("click", toggleCxCallnotesDrawer);
  if (cxCloseBtnCallnotes){
    cxCloseBtnCallnotes.addEventListener("click", closeCxCallnotesDrawer);
  }

  const dim = cxOverlayCallnotes.querySelector(".cx-dim");
  if (dim){ dim.addEventListener("click", closeCxCallnotesDrawer); }

  document.addEventListener("keydown", function(evt){
    if (evt.key === "Escape"){ closeCxCallnotesDrawer(); }
  });
})();

// Update CV Drawer with Call Notes vulnerability analysis
function updateCvCallnotesDrawer() {
  const notesText = (typeof mlcxNotesInput !== 'undefined' && mlcxNotesInput) ? mlcxNotesInput.value : '';
  const lowerText = notesText.toLowerCase();
  
  const cvSnapshot = document.getElementById('cvCallnotesSnapshot');
  const cvVulnSummary = document.getElementById('cvCallnotesVulnSummary');
  const cvHighRiskContent = document.getElementById('cvCallnotesHighRiskContent');
  const cvGuidanceContent = document.getElementById('cvCallnotesGuidanceContent');
  
  if (!cvSnapshot || !cvVulnSummary || !cvHighRiskContent || !cvGuidanceContent) return;
  
  // Scan CiVC library
  const civcHits = new Set();
  const vulnSnippets = [];
  
  if (typeof civcLibrary !== 'undefined') {
    Object.keys(civcLibrary).forEach((key) => {
      const entry = civcLibrary[key];
      if (!entry || !Array.isArray(entry.triggers)) return;
      entry.triggers.forEach((phrase) => {
        const needle = phrase.toLowerCase();
        if (needle && lowerText.includes(needle)) {
          civcHits.add(key);
          vulnSnippets.push({
            text: phrase,
            category: key,
            type: 'civc'
          });
        }
      });
    });
  }
  
  // Render snapshot
  const vulnCount = civcHits.size;
  const severityLevel = vulnCount === 0 ? 'LOW' : vulnCount < 3 ? 'MEDIUM' : 'HIGH';
  const severityClass = vulnCount === 0 ? 'mlcx-severity-low' : vulnCount < 3 ? 'mlcx-severity-medium' : 'mlcx-severity-high';
  
  cvSnapshot.innerHTML = `
    <span class="mlcx-snapshot-severity ${severityClass}">${severityLevel} CONCERN</span>
    <div class="mlcx-snapshot-counts">
      Vulnerability areas: ${vulnCount}
    </div>
  `;
  
  // Render vulnerability summary
  if (vulnCount === 0) {
    cvVulnSummary.innerHTML = '<p class="cx-drawer-section-empty">No vulnerability indicators detected.</p>';
  } else {
    const areasList = Array.from(civcHits).map(key => {
      const label = civcLibrary[key]?.meta?.label || key;
      return `<div class="mlcx-vuln-line">• ${label}</div>`;
    }).join('');
    cvVulnSummary.innerHTML = `
      <div style="margin-bottom:8px;color:rgba(251,146,60,0.95);font-weight:600;">Vulnerability level: ${severityLevel === 'MEDIUM' ? 'Medium' : 'High'}</div>
      <div><strong>Areas:</strong></div>
      ${areasList}
    `;
  }
  
  // Render high-risk snippets
  if (vulnSnippets.length === 0) {
    cvHighRiskContent.innerHTML = '<div class="mlcx-highrisk-empty">No high-risk indicators detected yet.</div>';
  } else {
    const snippetsHtml = vulnSnippets.slice(0, 8).map(s => {
      const categoryLabel = civcLibrary[s.category]?.meta?.label || s.category;
      return `<li><span class="mlcx-highrisk-chip mlcx-highrisk-chip-safety">${categoryLabel.toUpperCase()}</span> ${s.text}</li>`;
    }).join('');
    cvHighRiskContent.innerHTML = `<ul class="mlcx-highrisk-list">${snippetsHtml}</ul>`;
  }
  
  // Render guidance
  if (vulnCount === 0) {
    cvGuidanceContent.innerHTML = '<p class="cx-drawer-section-empty">No specific guidance needed at this time.</p>';
  } else {
    const guidancePoints = [];
    if (civcHits.has('financial')) guidancePoints.push('Consider offering financial hardship support or payment flexibility.');
    if (civcHits.has('mentalHealth')) guidancePoints.push('Approach with empathy and consider mental health support signposting.');
    if (civcHits.has('safeguarding')) guidancePoints.push('Follow safeguarding protocols and escalate if necessary.');
    if (civcHits.has('disability')) guidancePoints.push('Ensure accessibility and reasonable adjustments are offered.');
    if (civcHits.has('bereavement')) guidancePoints.push('Show compassion and allow extra time for processing.');
    if (civcHits.has('language')) guidancePoints.push('Consider translation services or simplified language.');
    
    const guidanceHtml = guidancePoints.map(g => `<li>${g}</li>`).join('');
    cvGuidanceContent.innerHTML = `<ul style="margin:0;padding-left:18px;line-height:1.6;font-size:0.88rem;">${guidanceHtml}</ul>`;
  }
}

// Update CX Drawer for Call Notes (mirrors pinned drawer)
function updateCxCallnotesDrawerFromPinned() {
  const notesText = (typeof mlcxNotesInput !== 'undefined' && mlcxNotesInput) ? mlcxNotesInput.value : '';
  const lowerText = notesText.toLowerCase();
  
  const cxSnapshot = document.getElementById('cxCallnotesSnapshot');
  const cxEmotionSection = document.getElementById('cxCallnotesEmotionSection');
  const cxVulnSummary = document.getElementById('cxCallnotesVulnSummary');
  const cxHighRiskContent = document.getElementById('cxCallnotesHighRiskContent');
  const cxCoachingContent = document.getElementById('cxCallnotesCoachingContent');
  
  if (!cxSnapshot) return;
  
  const mlcxHits = new Set();
  const civcHits = new Set();
  const allSnippets = [];
  
  if (typeof mlcxLibrary !== 'undefined') {
    Object.keys(mlcxLibrary).forEach((key) => {
      const entry = mlcxLibrary[key];
      if (!entry || !Array.isArray(entry.triggers)) return;
      entry.triggers.forEach((phrase) => {
        const needle = phrase.toLowerCase();
        if (needle && lowerText.includes(needle)) {
          mlcxHits.add(key);
          allSnippets.push({ text: phrase, category: entry.meta ? entry.meta.label : key, type: 'mlcx' });
        }
      });
    });
  }
  
  if (typeof civcLibrary !== 'undefined') {
    Object.keys(civcLibrary).forEach((key) => {
      const entry = civcLibrary[key];
      if (!entry || !Array.isArray(entry.triggers)) return;
      entry.triggers.forEach((phrase) => {
        const needle = phrase.toLowerCase();
        if (needle && lowerText.includes(needle)) {
          civcHits.add(key);
          allSnippets.push({ text: phrase, category: key, type: 'civc' });
        }
      });
    });
  }
  
  const emotionSnippets = allSnippets.filter(s => s.type === 'mlcx' && (s.category.toLowerCase().includes('emotion') || s.category.toLowerCase().includes('frustration') || s.category.toLowerCase().includes('anxiety')));
  const claritySnippets = allSnippets.filter(s => s.type === 'mlcx' && s.category.toLowerCase().includes('clarity'));
  const safetySnippets = allSnippets.filter(s => s.type === 'civc' && (s.category === 'safeguarding' || s.category === 'mentalHealth'));
  const vulnSnippets = allSnippets.filter(s => s.type === 'civc' && s.category !== 'safeguarding' && s.category !== 'mentalHealth');
  
  const totalSignals = mlcxHits.size + civcHits.size;
  const severityLevel = totalSignals === 0 ? 'LOW' : totalSignals < 3 ? 'MEDIUM' : 'HIGH';
  const severityClass = totalSignals === 0 ? 'mlcx-severity-low' : totalSignals < 3 ? 'mlcx-severity-medium' : 'mlcx-severity-high';
  
  cxSnapshot.innerHTML = `<span class="mlcx-snapshot-severity ${severityClass}">${severityLevel} CONCERN</span><div class="mlcx-snapshot-counts">Emotion ${emotionSnippets.length} · Clarity ${claritySnippets.length} · Safety ${safetySnippets.length + vulnSnippets.length}</div>`;
  
  if (cxEmotionSection) {
    if (emotionSnippets.length === 0 && claritySnippets.length === 0) {
      cxEmotionSection.innerHTML = '<p class="cx-drawer-section-empty">No emotional or clarity signals detected.</p>';
    } else {
      let html = '<div style="margin-bottom:8px;"><strong>Emotion:</strong> ' + emotionSnippets.length + ' | <strong>Clarity:</strong> ' + claritySnippets.length + '</div>';
      if (emotionSnippets.length > 0) {
        html += '<div style="margin-top:6px;">';
        emotionSnippets.slice(0, 5).forEach(s => { html += '<span class="mlcx-highrisk-chip" style="margin:2px;display:inline-block;">' + s.category + '</span> '; });
        html += '</div>';
      }
      cxEmotionSection.innerHTML = html;
    }
  }
  
  if (cxVulnSummary) {
    const vulnCount = civcHits.size;
    if (vulnCount === 0) {
      cxVulnSummary.innerHTML = '<p class="cx-drawer-section-empty">No vulnerability indicators detected.</p>';
    } else {
      const areasList = Array.from(civcHits).map(key => {
        const label = (typeof civcLibrary !== 'undefined' && civcLibrary[key]?.meta?.label) || key;
        return '<div class="mlcx-vuln-line">• ' + label + '</div>';
      }).join('');
      cxVulnSummary.innerHTML = '<div style="margin-bottom:8px;color:rgba(251,146,60,0.95);font-weight:600;">Vulnerability level: ' + (vulnCount < 3 ? 'Medium' : 'High') + '</div><div><strong>Areas:</strong></div>' + areasList;
    }
  }
  
  if (cxHighRiskContent) {
    const highRiskSnippets = [...safetySnippets, ...vulnSnippets];
    if (highRiskSnippets.length === 0) {
      cxHighRiskContent.innerHTML = '<div class="mlcx-highrisk-empty">No high-risk snippets detected yet.</div>';
    } else {
      const snippetsHtml = highRiskSnippets.slice(0, 8).map(s => {
        const categoryLabel = s.type === 'civc' ? ((typeof civcLibrary !== 'undefined' && civcLibrary[s.category]?.meta?.label) || s.category) : s.category;
        return '<li><span class="mlcx-highrisk-chip mlcx-highrisk-chip-safety">' + categoryLabel.toUpperCase() + '</span> ' + s.text + '</li>';
      }).join('');
      cxHighRiskContent.innerHTML = '<ul class="mlcx-highrisk-list">' + snippetsHtml + '</ul>';
    }
  }
  
  if (cxCoachingContent) {
    if (totalSignals === 0) {
      cxCoachingContent.innerHTML = '<p class="cx-drawer-section-empty">Coaching tips will appear based on your analysis.</p>';
    } else {
      const coachingPoints = [];
      if (civcHits.has('financial')) coachingPoints.push('Consider offering financial hardship support.');
      if (civcHits.has('mentalHealth')) coachingPoints.push('Approach with empathy and mental health support signposting.');
      if (civcHits.has('safeguarding')) coachingPoints.push('Follow safeguarding protocols and escalate if necessary.');
      if (emotionSnippets.length > 2) coachingPoints.push('Multiple emotion signals - use calming language.');
      if (claritySnippets.length > 2) coachingPoints.push('Avoid jargon and explain in plain language.');
      
      if (coachingPoints.length > 0) {
        const coachingHtml = coachingPoints.map(c => '<li>' + c + '</li>').join('');
        cxCoachingContent.innerHTML = '<ul style="margin:0;padding-left:18px;line-height:1.6;font-size:0.88rem;">' + coachingHtml + '</ul>';
      } else {
        cxCoachingContent.innerHTML = '<p class="cx-drawer-section-empty">Analysis complete.</p>';
      }
    }
  }
}

/* --- View toggles wiring --- */
(function(){
  const bodyRoot = document.body;
  const phoneBtn = document.getElementById('phoneSpotlightBtn');
const overlay = document.getElementById('phoneSpotlightOverlay');
  const htmlRoot = document.documentElement;
  function syncSpotlightClosePos(){
    const app = document.querySelector('main.app');
    if(!app) return;
    const r = app.getBoundingClientRect();
    htmlRoot.style.setProperty('--mf-app-top', `${r.top}px`);
    htmlRoot.style.setProperty('--mf-app-right', `${r.right}px`);
  }


  function setPressed(btn, on){
    if(!btn) return;
    btn.setAttribute('aria-pressed', on ? 'true' : 'false');
  }

  function togglePhoneSpotlight(force){
    const on = (typeof force === 'boolean') ? force : (bodyRoot.getAttribute('data-phone') !== 'on');
    bodyRoot.setAttribute('data-phone', on ? 'on' : 'off');
    
    if(on){
      syncPhoneSpotlightScale();
      body.classList.add('phone-spotlight-enter');
      setTimeout(()=>body.classList.remove('phone-spotlight-enter'), 340);
    }
// Keep legacy selector & future CSS compatibility
    bodyRoot.classList.toggle('phone-spotlight-on', on);
    if(overlay){ overlay.setAttribute('aria-hidden', on ? 'false' : 'true'); }
    if(on){
      syncSpotlightClosePos();
      window.addEventListener('resize', syncSpotlightClosePos);
      window.addEventListener('scroll', syncSpotlightClosePos, true);
      requestAnimationFrame(syncSpotlightClosePos);
    }else{
      window.removeEventListener('resize', syncSpotlightClosePos);
      window.removeEventListener('scroll', syncSpotlightClosePos, true);
      htmlRoot.style.removeProperty('--mf-app-top');
      htmlRoot.style.removeProperty('--mf-app-right');
    }
// Close any open drawers while spotlight is active
    try{ if(typeof hideCxDrawerCompletely === 'function') hideCxDrawerCompletely(); }catch(e){}
    try{ if(typeof closeMessengerDrawer === 'function') closeMessengerDrawer(); }catch(e){}
    setPressed(phoneBtn, on);
    bodyRoot.style.overflow = on ? 'hidden' : '';
  }
  function syncPhoneSpotlightScale(){
    if(body.dataset.phone !== 'on') return;
    const frame = document.querySelector('.phone-frame');
    if(!frame) return;
    // Measure current rendered height (non-transformed) and scale to fit viewport height.
    const rect = frame.getBoundingClientRect();
    const baseH = Math.max(1, rect.height || 820);
    const targetH = Math.max(520, window.innerHeight * 0.86);
    const scale = Math.min(1.32, Math.max(1.0, targetH / baseH));
    document.documentElement.style.setProperty('--mf-phone-spotlight-scale', scale.toFixed(3));
  }

  window.addEventListener('resize', () => {
    // Keep phone scaled correctly if user resizes window while in phone focus
    syncPhoneSpotlightScale();
  });

  if(phoneBtn){
    phoneBtn.addEventListener('click', ()=>togglePhoneSpotlight());
  }
const closeBtn = document.querySelector('#phoneSpotlightOverlay .phone-spotlight-close');
  if(closeBtn){
    closeBtn.addEventListener('click', (e)=>{ e.stopPropagation(); togglePhoneSpotlight(false); });
  }
  window.addEventListener('keydown', (e)=>{
    if(e.key === 'Escape'){
      if(bodyRoot.getAttribute('data-phone') === 'on'){ togglePhoneSpotlight(false); return; }
}
  });
})();

</script>


    <script>
    const ukusData = [
        { uk: "realise", us: "realize", type: "ise/ize" },
        { uk: "organise", us: "organize", type: "ise/ize" },
        { uk: "recognise", us: "recognize", type: "ise/ize" },
        { uk: "analyses", us: "analyze", type: "ise/ize" },
        { uk: "maximise", us: "maximize", type: "ise/ize" },
        { uk: "theorise", us: "theorize", type: "ise/ize" },
        { uk: "authorise", us: "authorize", type: "ise/ize" },
        { uk: "realisation", us: "realization", type: "ise/ize" },
        { uk: "apologise", us: "apologize", type: "ise/ize" },
        { uk: "specialise", us: "specialize", type: "ise/ize" },
        { uk: "capitalise", us: "capitalize", type: "ise/ize" },
        { uk: "colour", us: "color", type: "our/or" },
        { uk: "flavour", us: "flavor", type: "our/or" },
        { uk: "honour", us: "honor", type: "our/or" },
        { uk: "labour", us: "labor", type: "our/or" },
        { uk: "valour", us: "valor", type: "our/or" },
        { uk: "favour", us: "favor", type: "our/or" },
        { uk: "behaviour", us: "behavior", type: "our/or" },
        { uk: "neighbour", us: "neighbor", type: "our/or" },
        { uk: "odour", us: "odor", type: "our/or" },
        { uk: "travelling", us: "traveling", type: "double-l" },
        { uk: "cancelled", us: "canceled", type: "double-l" },
        { uk: "counselling", us: "counseling", type: "double-l" },
        { uk: "revelled", us: "reveled", type: "double-l" },
        { uk: "enrolment", us: "enrollment", type: "double-l" },
        { uk: "defence", us: "defense", type: "misc" },
        { uk: "licence", us: "license", type: "misc" },
        { uk: "offence", us: "offense", type: "misc" },
        { uk: "cheque", us: "check", type: "misc" },
        { uk: "centre", us: "center", type: "misc" },
        { uk: "theatre", us: "theater", type: "misc" },
        { uk: "aeroplane", us: "airplane", type: "misc" },
        { uk: "tyre", us: "tire", type: "misc" }
    ];
    </script>

    <script>
    // Jargon terms added to the "Jargon" section
    const jargonData = [
        { term: "Claimant", severity: "HIGH", expansion: "The person making a claim under an insurance policy.", notes: "Used in all claim-based scenarios.", examples: ["The claimant reported the incident to the insurer."] },
        { term: "Policyholder", severity: "HIGH", expansion: "The individual or entity that owns an insurance policy.", notes: "Refers to the person or company who has purchased insurance coverage.", examples: ["The policyholder is responsible for paying the premium."] },
        { term: "Premium", severity: "HIGH", expansion: "The amount paid for an insurance policy.", notes: "Usually paid monthly or annually.", examples: ["The premium for the car insurance was increased due to a claim."] },
        { term: "Excess", severity: "MED", expansion: "The amount the policyholder must pay before the insurance policy pays out.", notes: "A higher excess typically lowers the premium.", examples: ["The excess on this policy is £500."] },
        { term: "Indemnity", severity: "HIGH", expansion: "Compensation for damages or loss.", notes: "Commonly used in liability insurance.", examples: ["The insurance company offered indemnity for the damages caused during the accident."] },
        { term: "Liability", severity: "HIGH", expansion: "Responsibility for something, often involving legal responsibility.", notes: "Typically refers to legal obligations to compensate for damage or injury.", examples: ["The company assumed liability for the faulty product."] },
        { term: "Underwriting", severity: "MED", expansion: "The process of evaluating and approving insurance policies.", notes: "Underwriters assess risk before issuing an insurance policy.", examples: ["The underwriter approved the policy after assessing the applicant's risk profile."] },
        { term: "Coverage", severity: "HIGH", expansion: "The extent of protection provided by an insurance policy.", notes: "Defines what is and isn’t covered under the policy.", examples: ["The policy provides coverage for fire, theft, and vandalism."] },
        { term: "Claim", severity: "HIGH", expansion: "A request for payment under an insurance policy.", notes: "The formal process of asking the insurance company to compensate for a loss.", examples: ["The homeowner filed a claim after the storm caused significant damage."] },
        { term: "Deductible", severity: "MED", expansion: "The amount the insured must pay before the insurance policy pays out.", notes: "A higher deductible can lower your premium but increases your out-of-pocket costs.", examples: ["The deductible on the auto policy is $1,000."] },
        { term: "Surcharge", severity: "MED", expansion: "An additional charge added to the premium due to increased risk.", notes: "Common with high-risk policies.", examples: ["The insurer added a surcharge for the increased risk of flooding."] },
        { term: "Settlement", severity: "HIGH", expansion: "The process of resolving a claim, often through payment.", notes: "May involve negotiations between the insurer and the policyholder.", examples: ["The claim was settled for £5,000 after mediation."] },
        { term: "Recovery", severity: "MED", expansion: "The act of regaining something, like lost property or funds.", notes: "Common in scenarios where property or money was lost.", examples: ["The recovery of stolen goods was handled by the insurer."] },
        { term: "Loss Adjuster", severity: "MED", expansion: "A person who assesses the damage after an insurance claim.", notes: "Loss adjusters determine the payout amount for a claim.", examples: ["A loss adjuster will visit the property to assess the damage."] }
    ];
    </script>
    
    <script>
    // Phase B: Create ENGINE_ASSETS object and populate it with legacy data for read-only view
    
    const ENGINE_ASSETS = {
      meta: {
        version: "1.0.0",
        updatedAt: "2025-12-29",
        notes: "Populated from legacy data for display"
      },
      jargon: [],
      ukus: [],
      coaching: [],
      money: {},
      safeWords: []
    };

    const ENGINE_UKUS_CANONICAL = [
      // ise/ize (AUTO)
      { id: 'ukus_realise_realize', uk: 'realise', us: 'realize', type: 'ise/ize', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_realisation_realization', uk: 'realisation', us: 'realization', type: 'ise/ize', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_recognise_recognize', uk: 'recognise', us: 'recognize', type: 'ise/ize', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_authorise_authorize', uk: 'authorise', us: 'authorize', type: 'ise/ize', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_apologise_apologize', uk: 'apologise', us: 'apologize', type: 'ise/ize', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_specialise_specialize', uk: 'specialise', us: 'specialize', type: 'ise/ize', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_capitalise_capitalize', uk: 'capitalise', us: 'capitalize', type: 'ise/ize', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_organise_organize', uk: 'organise', us: 'organize', type: 'ise/ize', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_finalise_finalize', uk: 'finalise', us: 'finalize', type: 'ise/ize', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_analyse_analyze', uk: 'analyse', us: 'analyze', type: 'ise/ize', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },

      // our/or (AUTO)
      { id: 'ukus_colour_color', uk: 'colour', us: 'color', type: 'our/or', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_flavour_flavor', uk: 'flavour', us: 'flavor', type: 'our/or', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_honour_honor', uk: 'honour', us: 'honor', type: 'our/or', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_labour_labor', uk: 'labour', us: 'labor', type: 'our/or', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_valour_valor', uk: 'valour', us: 'valor', type: 'our/or', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_favour_favor', uk: 'favour', us: 'favor', type: 'our/or', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_behaviour_behavior', uk: 'behaviour', us: 'behavior', type: 'our/or', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_neighbour_neighbor', uk: 'neighbour', us: 'neighbor', type: 'our/or', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_odour_odor', uk: 'odour', us: 'odor', type: 'our/or', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },

      // double-l (AUTO)
      { id: 'ukus_travelling_traveling', uk: 'travelling', us: 'traveling', type: 'double-l', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_travelled_traveled', uk: 'travelled', us: 'traveled', type: 'double-l', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_cancelled_canceled', uk: 'cancelled', us: 'canceled', type: 'double-l', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_counselling_counseling', uk: 'counselling', us: 'counseling', type: 'double-l', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_revelled_reveled', uk: 'revelled', us: 'reveled', type: 'double-l', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_enrolment_enrollment', uk: 'enrolment', us: 'enrollment', type: 'double-l', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },

      // re/er (AUTO)
      { id: 'ukus_centre_center', uk: 'centre', us: 'center', type: 're/er', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_metre_meter', uk: 'metre', us: 'meter', type: 're/er', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_theatre_theater', uk: 'theatre', us: 'theater', type: 're/er', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },

      // misc (AUTO)
      { id: 'ukus_defence_defense', uk: 'defence', us: 'defense', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_licence_license', uk: 'licence', us: 'license', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_offence_offense', uk: 'offence', us: 'offense', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_cheque_check', uk: 'cheque', us: 'check', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_aeroplane_airplane', uk: 'aeroplane', us: 'airplane', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_tyre_tire', uk: 'tyre', us: 'tire', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_grey_gray', uk: 'grey', us: 'gray', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_kerb_curb', uk: 'kerb', us: 'curb', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_programme_program', uk: 'programme', us: 'program', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_catalogue_catalog', uk: 'catalogue', us: 'catalog', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_aluminium_aluminum', uk: 'aluminium', us: 'aluminum', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_mould_mold', uk: 'mould', us: 'mold', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },

      // verb variants (AUTO)
      { id: 'ukus_focussed_focused', uk: 'focussed', us: 'focused', type: 'variants', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_focussing_focusing', uk: 'focussing', us: 'focusing', type: 'variants', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_modelled_modeled', uk: 'modelled', us: 'modeled', type: 'variants', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_modelling_modeling', uk: 'modelling', us: 'modeling', type: 'variants', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },

      // claims-context pairs (AUTO)
      { id: 'ukus_repair_centre_repair_center', uk: 'repair centre', us: 'repair center', type: 'claims-phrases', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_hire_car_rental_car', uk: 'hire car', us: 'rental car', type: 'claims-phrases', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_petrol_gasoline', uk: 'petrol', us: 'gasoline', type: 'claims-phrases', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_postcode_zip_code', uk: 'postcode', us: 'zip code', type: 'claims-phrases', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_motorway_highway', uk: 'motorway', us: 'highway', type: 'claims-phrases', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_roundabout_traffic_circle', uk: 'roundabout', us: 'traffic circle', type: 'claims-phrases', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },

      // manual context checks (MANUAL)
      { id: 'ukus_practise_practice_manual', uk: 'practise', us: 'practice', type: 'manual', badge: 'MANUAL', notes: 'Manual check - context sensitive' },
      { id: 'ukus_licence_license_manual', uk: 'licence', us: 'license', type: 'manual', badge: 'MANUAL', notes: 'Manual check - noun vs verb' },
      { id: 'ukus_defence_defense_manual', uk: 'defence', us: 'defense', type: 'manual', badge: 'MANUAL', notes: 'Manual check - context sensitive' },
      { id: 'ukus_programme_program_manual', uk: 'programme', us: 'program', type: 'manual', badge: 'MANUAL', notes: 'Manual check - TV vs software' },

      // additional auto rules (AUTO)
      { id: 'ukus_litre_liter', uk: 'litre', us: 'liter', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_fibre_fiber', uk: 'fibre', us: 'fiber', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_jewellery_jewelry', uk: 'jewellery', us: 'jewelry', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_manoeuvre_maneuver', uk: 'manoeuvre', us: 'maneuver', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_plough_plow', uk: 'plough', us: 'plow', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_ageing_aging', uk: 'ageing', us: 'aging', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_cosy_cozy', uk: 'cosy', us: 'cozy', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_learnt_learned', uk: 'learnt', us: 'learned', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_spelt_spelled', uk: 'spelt', us: 'spelled', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_dreamt_dreamed', uk: 'dreamt', us: 'dreamed', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_burnt_burned', uk: 'burnt', us: 'burned', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_smelt_smelled', uk: 'smelt', us: 'smelled', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_leapt_leaped', uk: 'leapt', us: 'leaped', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_fitted_fit', uk: 'fitted', us: 'fit', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_got_gotten', uk: 'got', us: 'gotten', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },
      { id: 'ukus_whilst_while', uk: 'whilst', us: 'while', type: 'misc', badge: 'AUTO', notes: 'Engine canonical UK->US pair' },

      // expanded canonical pairs (AUTO)
      { id: 'ukus_favourite_favorite', uk: 'favourite', us: 'favorite', type: 'our/or', badge: 'AUTO', notes: 'Expanded canonical UK->US pair' },
      { id: 'ukus_favourites_favorites', uk: 'favourites', us: 'favorites', type: 'our/or', badge: 'AUTO', notes: 'Expanded canonical UK->US pair' },
      { id: 'ukus_jewellery_jewelry2', uk: 'jewellery', us: 'jewelry', type: 'misc', badge: 'AUTO', notes: 'Expanded canonical UK->US pair' },
      { id: 'ukus_manoeuvre_maneuver2', uk: 'manoeuvre', us: 'maneuver', type: 'misc', badge: 'AUTO', notes: 'Expanded canonical UK->US pair' },
      { id: 'ukus_dialogue_dialog', uk: 'dialogue', us: 'dialog', type: 'misc', badge: 'AUTO', notes: 'Expanded canonical UK->US pair' },
      { id: 'ukus_catalogue_catalog', uk: 'catalogue', us: 'catalog', type: 'misc', badge: 'AUTO', notes: 'Expanded canonical UK->US pair' },
      { id: 'ukus_analogue_analog', uk: 'analogue', us: 'analog', type: 'misc', badge: 'AUTO', notes: 'Expanded canonical UK->US pair' },
      { id: 'ukus_prologue_prolog', uk: 'prologue', us: 'prolog', type: 'misc', badge: 'AUTO', notes: 'Expanded canonical UK->US pair' },
      { id: 'ukus_monologue_monolog', uk: 'monologue', us: 'monolog', type: 'misc', badge: 'AUTO', notes: 'Expanded canonical UK->US pair' },
      { id: 'ukus_sombrE_somber', uk: 'sombre', us: 'somber', type: 're/er', badge: 'AUTO', notes: 'Expanded canonical UK->US pair' },

    ];

    // Populate ENGINE_ASSETS with legacy data (read-only, no scanner changes)
    const populateEngineFromLegacy = () => {
      const safeText = (v) => (v == null ? '' : String(v));
      const firstQuoted = (t) => {
        const m = safeText(t).match(/["'“”‘’]([^"'“”‘’]+)["'“”‘’]/);
        return m ? m[1].trim() : '';
      };

      ENGINE_ASSETS.meta.updatedAt = new Date().toISOString();

      // Jargon (legacy shape: jargonPatterns)
      if (Array.isArray(typeof jargonPatterns !== 'undefined' ? jargonPatterns : null)) {
        ENGINE_ASSETS.jargon = (jargonPatterns || []).map((j, i) => {
          const pat = j.pattern;
          const patSrc = pat && pat.source ? pat.source : safeText(pat);
          let term = safeText(j.term || j.acronym || j.word || '');
          if (!term && patSrc) {
            const m = patSrc.match(/\\b([A-Za-z0-9]{2,})\\b/);
            term = m ? m[1] : patSrc.replace(/\\W+/g, ' ').trim().slice(0, 24) || `legacy_jargon_${i}`;
          }
          return {
            id: j.id || `legacy_jargon_${i}`,
            term,
            severity: j.severity || 'HIGH',
            expansion: safeText(j.suggestion || j.expansion || ''),
            notes: safeText(j.note || j.notes || ''),
            patterns: [patSrc || safeText(pat)],
            examples: j.examples || (j.example ? [j.example] : []),
          };
        });
      } else {
        ENGINE_ASSETS.jargon = [];
      }

      // UK/US: canonical engine data (70 entries, engine is source of truth)
      ENGINE_ASSETS.ukus = ENGINE_UKUS_CANONICAL.map((p, i) => ({ ...p, id: p.id || `eng_ukus_${i}` }));

      // Coaching (placeholder only)
      ENGINE_ASSETS.coaching = [];

      // Money keywords (read-only aggregation)
      const moneySources = [];
      if (Array.isArray(typeof MONEY_KEYWORDS !== 'undefined' ? MONEY_KEYWORDS : null)) moneySources.push(...MONEY_KEYWORDS);
      if (Array.isArray(typeof moneyKeywords !== 'undefined' ? moneyKeywords : null)) moneySources.push(...moneyKeywords);
      ENGINE_ASSETS.money = { keywords: Array.from(new Set(moneySources.map(safeText))).filter(Boolean) };

      // Safe words
      const safeWordsRaw = [];
      if (typeof SAFE_WORDS !== 'undefined') {
        if (Array.isArray(SAFE_WORDS)) safeWordsRaw.push(...SAFE_WORDS);
        else if (SAFE_WORDS instanceof Set) safeWordsRaw.push(...Array.from(SAFE_WORDS));
      }
      ENGINE_ASSETS.safeWords = safeWordsRaw.map((w, i) => ({ id: `safe_${i}`, term: safeText(w), type: 'legacy', notes: 'Legacy allowlist term' }));

      // Expose for Dev Lab / debugging
      window.ENGINE_ASSETS = ENGINE_ASSETS;
    };

    // Populate the data on load
    populateEngineFromLegacy();

    // --- Canonical Jargon seed (view-only) ---
    const JARGON_CANONICAL_V1 = [{"id": "jargon_seed_0", "term": "FNOL", "severity": "misc", "expansion": "First notification of loss", "notes": "Canonical seed (view-only)", "patterns": ["\\bFNOL\\b"]}, {"id": "jargon_seed_1", "term": "TP", "severity": "misc", "expansion": "Third party", "notes": "Canonical seed (view-only)", "patterns": ["\\bTP\\b"]}, {"id": "jargon_seed_2", "term": "PH", "severity": "misc", "expansion": "Policyholder", "notes": "Canonical seed (view-only)", "patterns": ["\\bPH\\b"]}, {"id": "jargon_seed_3", "term": "NCD", "severity": "misc", "expansion": "No claims discount", "notes": "Canonical seed (view-only)", "patterns": ["\\bNCD\\b"]}, {"id": "jargon_seed_4", "term": "SLA", "severity": "misc", "expansion": "Service level agreement", "notes": "Canonical seed (view-only)", "patterns": ["\\bSLA\\b"]}, {"id": "jargon_seed_5", "term": "KPI", "severity": "misc", "expansion": "Key performance indicator", "notes": "Canonical seed (view-only)", "patterns": ["\\bKPI\\b"]}, {"id": "jargon_seed_6", "term": "AHT", "severity": "misc", "expansion": "Average handling time", "notes": "Canonical seed (view-only)", "patterns": ["\\bAHT\\b"]}, {"id": "jargon_seed_7", "term": "ETA", "severity": "misc", "expansion": "Estimated time", "notes": "Canonical seed (view-only)", "patterns": ["\\bETA\\b"]}, {"id": "jargon_seed_8", "term": "EOD", "severity": "misc", "expansion": "End of day", "notes": "Canonical seed (view-only)", "patterns": ["\\bEOD\\b"]}, {"id": "jargon_seed_9", "term": "ASAP", "severity": "misc", "expansion": "As soon as possible", "notes": "Canonical seed (view-only)", "patterns": ["\\bASAP\\b"]}, {"id": "jargon_seed_10", "term": "T&Cs", "severity": "misc", "expansion": "Terms and conditions", "notes": "Canonical seed (view-only)", "patterns": ["T\\&Cs"]}, {"id": "jargon_seed_11", "term": "GDPR", "severity": "misc", "expansion": "Data protection rules", "notes": "Canonical seed (view-only)", "patterns": ["\\bGDPR\\b"]}, {"id": "jargon_seed_12", "term": "ICO", "severity": "misc", "expansion": "UK data regulator", "notes": "Canonical seed (view-only)", "patterns": ["\\bICO\\b"]}, {"id": "jargon_seed_13", "term": "FOS", "severity": "misc", "expansion": "Financial Ombudsman Service", "notes": "Canonical seed (view-only)", "patterns": ["\\bFOS\\b"]}, {"id": "jargon_seed_14", "term": "FCA", "severity": "misc", "expansion": "Financial Conduct Authority", "notes": "Canonical seed (view-only)", "patterns": ["\\bFCA\\b"]}, {"id": "jargon_seed_15", "term": "DVLA", "severity": "misc", "expansion": "Driver and Vehicle Licensing Agency", "notes": "Canonical seed (view-only)", "patterns": ["\\bDVLA\\b"]}, {"id": "jargon_seed_16", "term": "VRM", "severity": "misc", "expansion": "Vehicle registration mark", "notes": "Canonical seed (view-only)", "patterns": ["\\bVRM\\b"]}, {"id": "jargon_seed_17", "term": "V5C", "severity": "misc", "expansion": "Vehicle log book", "notes": "Canonical seed (view-only)", "patterns": ["\\bV5C\\b"]}, {"id": "jargon_seed_18", "term": "MOT", "severity": "misc", "expansion": "Vehicle roadworthiness test", "notes": "Canonical seed (view-only)", "patterns": ["\\bMOT\\b"]}, {"id": "jargon_seed_19", "term": "AD", "severity": "misc", "expansion": "Accidental damage", "notes": "Canonical seed (view-only)", "patterns": ["\\bAD\\b"]}, {"id": "jargon_seed_20", "term": "TL", "severity": "misc", "expansion": "Total loss", "notes": "Canonical seed (view-only)", "patterns": ["\\bTL\\b"]}, {"id": "jargon_seed_21", "term": "PAV", "severity": "misc", "expansion": "Pre-accident value", "notes": "Canonical seed (view-only)", "patterns": ["\\bPAV\\b"]}, {"id": "jargon_seed_22", "term": "CAT N", "severity": "misc", "expansion": "Write-off category: non-structural", "notes": "Canonical seed (view-only)", "patterns": ["CAT\\ N"]}, {"id": "jargon_seed_23", "term": "CAT S", "severity": "misc", "expansion": "Write-off category: structural", "notes": "Canonical seed (view-only)", "patterns": ["CAT\\ S"]}, {"id": "jargon_seed_24", "term": "BI", "severity": "misc", "expansion": "Bodily injury", "notes": "Canonical seed (view-only)", "patterns": ["\\bBI\\b"]}, {"id": "jargon_seed_25", "term": "PI", "severity": "misc", "expansion": "Personal injury", "notes": "Canonical seed (view-only)", "patterns": ["\\bPI\\b"]}, {"id": "jargon_seed_26", "term": "TPI", "severity": "misc", "expansion": "Third party insurer", "notes": "Canonical seed (view-only)", "patterns": ["\\bTPI\\b"]}, {"id": "jargon_seed_27", "term": "TPPD", "severity": "misc", "expansion": "Third party property damage", "notes": "Canonical seed (view-only)", "patterns": ["\\bTPPD\\b"]}, {"id": "jargon_seed_28", "term": "TPBI", "severity": "misc", "expansion": "Third party bodily injury", "notes": "Canonical seed (view-only)", "patterns": ["\\bTPBI\\b"]}, {"id": "jargon_seed_29", "term": "Liability", "severity": "misc", "expansion": "Who is at fault / responsible", "notes": "Canonical seed (view-only)", "patterns": ["\\bLiability\\b"]}, {"id": "jargon_seed_30", "term": "Indemnity", "severity": "misc", "expansion": "Putting you back to where you were before", "notes": "Canonical seed (view-only)", "patterns": ["\\bIndemnity\\b"]}, {"id": "jargon_seed_31", "term": "Subrogation", "severity": "misc", "expansion": "Recovering costs from the responsible party", "notes": "Canonical seed (view-only)", "patterns": ["\\bSubrogation\\b"]}, {"id": "jargon_seed_32", "term": "Recoveries", "severity": "misc", "expansion": "Process to recover claim costs", "notes": "Canonical seed (view-only)", "patterns": ["\\bRecoveries\\b"]}, {"id": "jargon_seed_33", "term": "Salvage", "severity": "misc", "expansion": "Vehicle remains after a total loss", "notes": "Canonical seed (view-only)", "patterns": ["\\bSalvage\\b"]}, {"id": "jargon_seed_34", "term": "Settlement", "severity": "misc", "expansion": "Payment to resolve the claim", "notes": "Canonical seed (view-only)", "patterns": ["\\bSettlement\\b"]}, {"id": "jargon_seed_35", "term": "Excess", "severity": "misc", "expansion": "Amount you pay towards a claim", "notes": "Canonical seed (view-only)", "patterns": ["\\bExcess\\b"]}, {"id": "jargon_seed_36", "term": "Voluntary excess", "severity": "misc", "expansion": "Extra excess you chose", "notes": "Canonical seed (view-only)", "patterns": ["Voluntary\\ excess"]}, {"id": "jargon_seed_37", "term": "Compulsory excess", "severity": "misc", "expansion": "Excess applied by policy rules", "notes": "Canonical seed (view-only)", "patterns": ["Compulsory\\ excess"]}, {"id": "jargon_seed_38", "term": "Betterment", "severity": "misc", "expansion": "An improvement beyond pre-loss condition", "notes": "Canonical seed (view-only)", "patterns": ["\\bBetterment\\b"]}, {"id": "jargon_seed_39", "term": "Depreciation", "severity": "misc", "expansion": "Reduction in value over time", "notes": "Canonical seed (view-only)", "patterns": ["\\bDepreciation\\b"]}, {"id": "jargon_seed_40", "term": "Ex gratia", "severity": "misc", "expansion": "Goodwill payment without admitting liability", "notes": "Canonical seed (view-only)", "patterns": ["Ex\\ gratia"]}, {"id": "jargon_seed_41", "term": "Validation", "severity": "misc", "expansion": "Checking details are correct", "notes": "Canonical seed (view-only)", "patterns": ["\\bValidation\\b"]}, {"id": "jargon_seed_42", "term": "Verification", "severity": "misc", "expansion": "Confirming identity / facts", "notes": "Canonical seed (view-only)", "patterns": ["\\bVerification\\b"]}, {"id": "jargon_seed_43", "term": "ID&V", "severity": "misc", "expansion": "Identity and verification", "notes": "Canonical seed (view-only)", "patterns": ["ID\\&V"]}, {"id": "jargon_seed_44", "term": "Referral", "severity": "misc", "expansion": "Passing to another team", "notes": "Canonical seed (view-only)", "patterns": ["\\bReferral\\b"]}, {"id": "jargon_seed_45", "term": "Escalation", "severity": "misc", "expansion": "Raising to a higher support level", "notes": "Canonical seed (view-only)", "patterns": ["\\bEscalation\\b"]}, {"id": "jargon_seed_46", "term": "Vulnerability", "severity": "misc", "expansion": "Customer may need extra support", "notes": "Canonical seed (view-only)", "patterns": ["\\bVulnerability\\b"]}, {"id": "jargon_seed_47", "term": "Safeguarding", "severity": "misc", "expansion": "Protecting at-risk individuals", "notes": "Canonical seed (view-only)", "patterns": ["\\bSafeguarding\\b"]}, {"id": "jargon_seed_48", "term": "Reasonable adjustments", "severity": "misc", "expansion": "Changes to support accessibility needs", "notes": "Canonical seed (view-only)", "patterns": ["Reasonable\\ adjustments"]}, {"id": "jargon_seed_49", "term": "Network", "severity": "misc", "expansion": "Approved repairer network", "notes": "Canonical seed (view-only)", "patterns": ["\\bNetwork\\b"]}, {"id": "jargon_seed_50", "term": "Repair authorisation", "severity": "misc", "expansion": "Approval to proceed with repairs", "notes": "Canonical seed (view-only)", "patterns": ["Repair\\ authorisation"]}, {"id": "jargon_seed_51", "term": "Estimate", "severity": "misc", "expansion": "Repair cost estimate", "notes": "Canonical seed (view-only)", "patterns": ["\\bEstimate\\b"]}, {"id": "jargon_seed_52", "term": "Engineer", "severity": "misc", "expansion": "Damage assessor", "notes": "Canonical seed (view-only)", "patterns": ["\\bEngineer\\b"]}, {"id": "jargon_seed_53", "term": "Hire", "severity": "misc", "expansion": "Temporary replacement vehicle", "notes": "Canonical seed (view-only)", "patterns": ["\\bHire\\b"]}, {"id": "jargon_seed_54", "term": "Courtesy car", "severity": "misc", "expansion": "Replacement vehicle provided (subject to cover)", "notes": "Canonical seed (view-only)", "patterns": ["Courtesy\\ car"]}, {"id": "jargon_seed_55", "term": "Credit hire", "severity": "misc", "expansion": "Hire on credit (often via solicitor)", "notes": "Canonical seed (view-only)", "patterns": ["Credit\\ hire"]}, {"id": "jargon_seed_56", "term": "Non-fault", "severity": "misc", "expansion": "Customer not responsible", "notes": "Canonical seed (view-only)", "patterns": ["Non\\-fault"]}, {"id": "jargon_seed_57", "term": "Fault claim", "severity": "misc", "expansion": "Customer held responsible", "notes": "Canonical seed (view-only)", "patterns": ["Fault\\ claim"]}, {"id": "jargon_seed_58", "term": "Write-off", "severity": "misc", "expansion": "Vehicle deemed uneconomical to repair", "notes": "Canonical seed (view-only)", "patterns": ["Write\\-off"]}, {"id": "jargon_seed_59", "term": "Repudiation", "severity": "misc", "expansion": "Declining a claim", "notes": "Canonical seed (view-only)", "patterns": ["\\bRepudiation\\b"]}, {"id": "jargon_seed_60", "term": "Supplier", "severity": "misc", "expansion": "External partner company", "notes": "Canonical seed (view-only)", "patterns": ["\\bSupplier\\b"]}, {"id": "jargon_seed_61", "term": "Stakeholder", "severity": "misc", "expansion": "Any involved party", "notes": "Canonical seed (view-only)", "patterns": ["\\bStakeholder\\b"]}, {"id": "jargon_seed_62", "term": "OEM", "severity": "misc", "expansion": "Original equipment manufacturer", "notes": "Canonical seed (view-only)", "patterns": ["\\bOEM\\b"]}, {"id": "jargon_seed_63", "term": "QC", "severity": "misc", "expansion": "Quality check", "notes": "Canonical seed (view-only)", "patterns": ["\\bQC\\b"]}, {"id": "jargon_seed_64", "term": "B2B", "severity": "misc", "expansion": "Business to business", "notes": "Canonical seed (view-only)", "patterns": ["\\bB2B\\b"]}, {"id": "jargon_seed_65", "term": "B2C", "severity": "misc", "expansion": "Business to customer", "notes": "Canonical seed (view-only)", "patterns": ["\\bB2C\\b"]}, {"id": "jargon_seed_66", "term": "TPFT", "severity": "misc", "expansion": "Third party, fire and theft", "notes": "Canonical seed (view-only)", "patterns": ["\\bTPFT\\b"]}, {"id": "jargon_seed_67", "term": "SD&P", "severity": "misc", "expansion": "Social, domestic and pleasure", "notes": "Canonical seed (view-only)", "patterns": ["SD\\&P"]}, {"id": "jargon_seed_68", "term": "CUE", "severity": "misc", "expansion": "Claims and Underwriting Exchange", "notes": "Canonical seed (view-only)", "patterns": ["\\bCUE\\b"]}, {"id": "jargon_seed_69", "term": "SORN", "severity": "misc", "expansion": "Statutory Off Road Notification", "notes": "Canonical seed (view-only)", "patterns": ["\\bSORN\\b"]}, {"id": "jargon_seed_70", "term": "ABI", "severity": "misc", "expansion": "Association of British Insurers", "notes": "Canonical seed (view-only)", "patterns": ["\\bABI\\b"]}, {"id": "jargon_seed_71", "term": "Intervention", "severity": "misc", "expansion": "Any action taken to progress a case", "notes": "Canonical seed (view-only)", "patterns": ["\\bIntervention\\b"]}, {"id": "jargon_seed_72", "term": "Repair pathway", "severity": "misc", "expansion": "How the claim will be handled", "notes": "Canonical seed (view-only)", "patterns": ["Repair\\ pathway"]}, {"id": "jargon_seed_73", "term": "Settlement offer", "severity": "misc", "expansion": "Proposed amount to resolve", "notes": "Canonical seed (view-only)", "patterns": ["Settlement\\ offer"]}, {"id": "jargon_seed_74", "term": "Documentation", "severity": "misc", "expansion": "Paperwork / forms needed", "notes": "Canonical seed (view-only)", "patterns": ["\\bDocumentation\\b"]}];

    if (!Array.isArray(ENGINE_ASSETS.jargon) || ENGINE_ASSETS.jargon.length === 0) {
      ENGINE_ASSETS.jargon = JARGON_CANONICAL_V1;
    }


    // --- UK/US RULEPACK (US -> UK) : flat ENGINE_ASSETS.ukus + smart inflections ---
    // Adds broader coverage + regex/function variants (kept lightweight).
    // This does NOT remove your existing ENGINE_UKUS_CANONICAL; we merge + de-dupe.

    /**
     * fnIzeToIse
     * Converts US -ize family spellings to UK -ise equivalents (safe-by-design).
     */
    function fnIzeToIse(match) {
      const original = match;
      let result = match
        .replace(/izer(s)?$/i, "iser$1")
        .replace(/izing$/i, "ising")
        .replace(/ized$/i, "ised")
        .replace(/ize(s)?$/i, "ise$1");
      if (/^[A-Z][a-z]+$/.test(original)) {
        result = result.charAt(0).toUpperCase() + result.slice(1);
      }
      return result;
    }

    const ENGINE_UKUS_RULEPACK_FLAT = [
      // -or -> -our
      { id:"or_color", direction:"US_TO_UK", type:"literal", us:"color", uk:"colour", category:"or_to_our" },
      { id:"or_flavor", direction:"US_TO_UK", type:"literal", us:"flavor", uk:"flavour", category:"or_to_our" },
      { id:"or_honor", direction:"US_TO_UK", type:"literal", us:"honor", uk:"honour", category:"or_to_our" },
      { id:"or_labor", direction:"US_TO_UK", type:"literal", us:"labor", uk:"labour", category:"or_to_our" },
      { id:"or_neighbor", direction:"US_TO_UK", type:"literal", us:"neighbor", uk:"neighbour", category:"or_to_our" },
      { id:"or_behavior", direction:"US_TO_UK", type:"literal", us:"behavior", uk:"behaviour", category:"or_to_our" },
      { id:"or_humor", direction:"US_TO_UK", type:"literal", us:"humor", uk:"humour", category:"or_to_our" },
      { id:"or_vigor", direction:"US_TO_UK", type:"literal", us:"vigor", uk:"vigour", category:"or_to_our" },
      { id:"or_odor", direction:"US_TO_UK", type:"literal", us:"odor", uk:"odour", category:"or_to_our" },
      { id:"or_rumor", direction:"US_TO_UK", type:"literal", us:"rumor", uk:"rumour", category:"or_to_our" },

      // -ize families (function patterns)
      { id:"ize_organize_family", direction:"US_TO_UK", type:"function", category:"ize_to_ise", pattern:"\\\\borganize(?:d|s|r|rs|ing)?\\\\b", fn:"fnIzeToIse" },
      { id:"ize_recognize_family", direction:"US_TO_UK", type:"function", category:"ize_to_ise", pattern:"\\\\brecognize(?:d|s|r|rs|ing)?\\\\b", fn:"fnIzeToIse" },
      { id:"ize_realize_family", direction:"US_TO_UK", type:"function", category:"ize_to_ise", pattern:"\\\\brealize(?:d|s|r|rs|ing)?\\\\b", fn:"fnIzeToIse" },
      { id:"ize_apologize_family", direction:"US_TO_UK", type:"function", category:"ize_to_ise", pattern:"\\\\bapologize(?:d|s|r|rs|ing)?\\\\b", fn:"fnIzeToIse" },
      { id:"ize_criticize_family", direction:"US_TO_UK", type:"function", category:"ize_to_ise", pattern:"\\\\bcriticize(?:d|s|r|rs|ing)?\\\\b", fn:"fnIzeToIse" },
      { id:"ize_authorize_family", direction:"US_TO_UK", type:"function", category:"ize_to_ise", pattern:"\\\\bauthorize(?:d|s|r|rs|ing)?\\\\b", fn:"fnIzeToIse" },
      { id:"ize_specialize_family", direction:"US_TO_UK", type:"function", category:"ize_to_ise", pattern:"\\\\bspecialize(?:d|s|r|rs|ing)?\\\\b", fn:"fnIzeToIse" },
      { id:"ize_capitalize_family", direction:"US_TO_UK", type:"function", category:"ize_to_ise", pattern:"\\\\bcapitalize(?:d|s|r|rs|ing)?\\\\b", fn:"fnIzeToIse" },
      { id:"ize_finalize_family", direction:"US_TO_UK", type:"function", category:"ize_to_ise", pattern:"\\\\bfinalize(?:d|s|r|rs|ing)?\\\\b", fn:"fnIzeToIse" },

      // noun forms
      { id:"ize_organization", direction:"US_TO_UK", type:"literal", us:"organization", uk:"organisation", category:"ize_to_ise" },
      { id:"ize_globalization", direction:"US_TO_UK", type:"literal", us:"globalization", uk:"globalisation", category:"ize_to_ise" },
      { id:"ize_privatize", direction:"US_TO_UK", type:"function", category:"ize_to_ise", pattern:"\\\\bprivatize(?:d|s|r|rs|ing)?\\\\b", fn:"fnIzeToIse" },
      { id:"ize_privatization", direction:"US_TO_UK", type:"literal", us:"privatization", uk:"privatisation", category:"ize_to_ise" },

      // analyze/analyse family (function to avoid false hits on "analysis")
      { id:"yze_analyze_family", direction:"US_TO_UK", type:"function", category:"ize_to_ise", pattern:"\\\\banalyz(?:e|ed|es|ing|er|ers)\\\\b", fn:"fnAnalyzeToAnalyse", notes:"analyze family -> analyse family" },

      // -er -> -re
      { id:"er_center", direction:"US_TO_UK", type:"literal", us:"center", uk:"centre", category:"er_to_re" },
      { id:"er_theater", direction:"US_TO_UK", type:"literal", us:"theater", uk:"theatre", category:"er_to_re" },
      { id:"er_fiber", direction:"US_TO_UK", type:"literal", us:"fiber", uk:"fibre", category:"er_to_re" },
      { id:"er_liter", direction:"US_TO_UK", type:"literal", us:"liter", uk:"litre", category:"er_to_re" },
      { id:"er_somber", direction:"US_TO_UK", type:"literal", us:"somber", uk:"sombre", category:"er_to_re" },
      { id:"er_meter_s", direction:"US_TO_UK", type:"regex", category:"er_to_re", pattern:"\\\\bmeter(s)?\\\\b", replacement:"metre$1" },

      // -og -> -ogue
      { id:"ogue_dialog", direction:"US_TO_UK", type:"literal", us:"dialog", uk:"dialogue", category:"og_to_ogue" },
      { id:"ogue_catalog", direction:"US_TO_UK", type:"literal", us:"catalog", uk:"catalogue", category:"og_to_ogue" },
      { id:"ogue_analog", direction:"US_TO_UK", type:"literal", us:"analog", uk:"analogue", category:"og_to_ogue" },
      { id:"ogue_monolog", direction:"US_TO_UK", type:"literal", us:"monolog", uk:"monologue", category:"og_to_ogue" },
      { id:"ogue_prolog", direction:"US_TO_UK", type:"literal", us:"prolog", uk:"prologue", category:"og_to_ogue" },

      // double-l families (regex)
      { id:"ll_travel_family", direction:"US_TO_UK", type:"regex", category:"double_l", pattern:"\\\\btravel(ing|ed|er|ers)\\\\b", replacement:"travell$1" },
      { id:"ll_cancel_family", direction:"US_TO_UK", type:"regex", category:"double_l", pattern:"\\\\bcancel(ed|ing|er|ers|ation|ations)\\\\b", replacement:"cancell$1" },
      { id:"ll_fuel_family", direction:"US_TO_UK", type:"regex", category:"double_l", pattern:"\\\\bfuel(ed|ing)\\\\b", replacement:"fuell$1" },
      { id:"ll_model_family", direction:"US_TO_UK", type:"regex", category:"double_l", pattern:"\\\\bmodel(ing|ed|er|ers)\\\\b", replacement:"modell$1" },
      { id:"ll_jewelry", direction:"US_TO_UK", type:"literal", us:"jewelry", uk:"jewellery", category:"double_l" },

      // -ense -> -ence
      { id:"ence_defense", direction:"US_TO_UK", type:"regex", category:"ense_to_ence", pattern:"\\\\bdefense(s)?\\\\b", replacement:"defence$1" },
      { id:"ence_offense", direction:"US_TO_UK", type:"regex", category:"ense_to_ence", pattern:"\\\\boffense(s)?\\\\b", replacement:"offence$1" },
      { id:"ence_pretense", direction:"US_TO_UK", type:"regex", category:"ense_to_ence", pattern:"\\\\bpretense(s)?\\\\b", replacement:"pretence$1" },
      { id:"ence_license_noun", direction:"US_TO_UK", type:"literal", us:"license", uk:"licence", category:"ense_to_ence", notes:"noun only", badge:"MANUAL" },

      // -e -> -ae / -oe
      { id:"ae_estrogen", direction:"US_TO_UK", type:"literal", us:"estrogen", uk:"oestrogen", category:"e_to_ae_oe" },
      { id:"ae_pediatric", direction:"US_TO_UK", type:"literal", us:"pediatric", uk:"paediatric", category:"e_to_ae_oe" },
      { id:"ae_encyclopedia", direction:"US_TO_UK", type:"literal", us:"encyclopedia", uk:"encyclopaedia", category:"e_to_ae_oe" },
      { id:"ae_fetus", direction:"US_TO_UK", type:"literal", us:"fetus", uk:"foetus", category:"e_to_ae_oe" },
      { id:"ae_maneuver", direction:"US_TO_UK", type:"literal", us:"maneuver", uk:"manoeuvre", category:"e_to_ae_oe" },

      // -ck -> -que (gated: financial)
      { id:"que_check_financial", direction:"US_TO_UK", type:"literal", us:"check", uk:"cheque", category:"ck_to_que", gate:"financial", notes:"financial only" },
      { id:"que_paycheck", direction:"US_TO_UK", type:"literal", us:"paycheck", uk:"pay cheque", category:"ck_to_que", gate:"financial" },
      { id:"que_checker_pattern", direction:"US_TO_UK", type:"literal", us:"checker", uk:"chequer", category:"ck_to_que", notes:"pattern only" },

      // misc
      { id:"misc_gray", direction:"US_TO_UK", type:"literal", us:"gray", uk:"grey", category:"misc" },
      { id:"misc_curb", direction:"US_TO_UK", type:"literal", us:"curb", uk:"kerb", category:"misc", notes:"road edge" },
      { id:"misc_tire", direction:"US_TO_UK", type:"literal", us:"tire", uk:"tyre", category:"misc", notes:"vehicle" },
      { id:"misc_draft", direction:"US_TO_UK", type:"literal", us:"draft", uk:"draught", category:"misc" },
      { id:"misc_plow", direction:"US_TO_UK", type:"literal", us:"plow", uk:"plough", category:"misc" },
      { id:"misc_mold", direction:"US_TO_UK", type:"literal", us:"mold", uk:"mould", category:"misc" },
      { id:"misc_mustache", direction:"US_TO_UK", type:"literal", us:"mustache", uk:"moustache", category:"misc" },
      { id:"misc_program_tv", direction:"US_TO_UK", type:"literal", us:"program", uk:"programme", category:"misc", badge:"MANUAL", notes:"TV/arts only (keep program for software)" },
      { id:"misc_sulfur", direction:"US_TO_UK", type:"literal", us:"sulfur", uk:"sulphur", category:"misc" },
      { id:"misc_aluminum", direction:"US_TO_UK", type:"literal", us:"aluminum", uk:"aluminium", category:"misc" },
      { id:"misc_diarrhea", direction:"US_TO_UK", type:"literal", us:"diarrhea", uk:"diarrhoea", category:"misc" },
      { id:"misc_checkmark", direction:"US_TO_UK", type:"literal", us:"checkmark", uk:"tick", category:"misc" },
      { id:"misc_stroller", direction:"US_TO_UK", type:"literal", us:"stroller", uk:"pushchair", category:"misc" },
      { id:"misc_apartment", direction:"US_TO_UK", type:"literal", us:"apartment", uk:"flat", category:"misc" },
      { id:"misc_cookie", direction:"US_TO_UK", type:"literal", us:"cookie", uk:"biscuit", category:"misc" }
    ];

    // Function helper: analyze -> analyse family (kept tight)
    function fnAnalyzeToAnalyse(match) {
      const original = match;
      let result = match
        .replace(/yzer(s)?$/i, "yser$1")     // analyzer(s) -> analyser(s)
        .replace(/yzing$/i, "ysing")        // analyzing -> analysing
        .replace(/yzed$/i, "ysed")          // analyzed -> analysed
        .replace(/yze(s)?$/i, "yse$1");     // analyze(s) -> analyse(s)
      if (/^[A-Z][a-z]+$/.test(original)) {
        result = result.charAt(0).toUpperCase() + result.slice(1);
      }
      return result;
    }

    // Merge + de-dupe (prefer rulepack when ids collide)
    (function mergeUkusRulepackIntoEngine(){
      try{
        const normalize = (o, i) => {
          if (!o || typeof o !== 'object') return null;

          // Already new schema?
          if (o.match && o.replace) {
            return {
              id: o.id || `ukus_${i}`,
              direction: o.direction || 'US_TO_UK',
              mode: (String(o.mode || o.badge || '').toUpperCase() === 'MANUAL') ? 'MANUAL' : 'AUTO',
              category: o.category || o.type || 'spelling.misc',
              match: {
                type: String(o.match.type || 'literal').toLowerCase(),
                value: String(o.match.value || '').trim(),
                flags: o.match.flags || 'gi',
              },
              replace: {
                type: String(o.replace.type || 'literal').toLowerCase(),
                value: o.replace.value,
              },
              gate: (o.gate == null) ? null : o.gate,
              notes: o.notes || '',
              examples: Array.isArray(o.examples) ? o.examples : [],
            };
          }

          // Legacy flat rulepack shape
          const isRegex = (String(o.type || '').toLowerCase() === 'regex' || !!o.pattern);
          const isFn = (String(o.type || '').toLowerCase() === 'function' || !!o.fn);

          const match = isRegex
            ? { type: 'regex', value: String(o.pattern || '').trim(), flags: 'gi' }
            : { type: 'literal', value: String(o.us || '').trim() };

          const replace = isFn
            ? { type: 'fn', value: String(o.fn || '').trim() }
            : { type: 'literal', value: (o.replacement != null ? o.replacement : o.uk) };

          return {
            id: o.id || `ukus_${i}`,
            direction: o.direction || 'US_TO_UK',
            mode: (String(o.badge || '').toUpperCase() === 'MANUAL') ? 'MANUAL' : 'AUTO',
            category: o.category || 'spelling.misc',
            match,
            replace,
            gate: (o.gate == null || String(o.gate).trim()==='') ? null : o.gate,
            notes: o.notes || '',
            examples: Array.isArray(o.examples) ? o.examples : [],
          };
        };

        const cur = Array.isArray(ENGINE_ASSETS.ukus) ? ENGINE_ASSETS.ukus.slice() : [];
        const merged = [];
        cur.forEach((o, i) => { const n = normalize(o, i); if (n) merged.push(n); });
        ENGINE_UKUS_RULEPACK_FLAT.forEach((o, i) => { const n = normalize(o, 10000+i); if (n) merged.push(n); });

        const keyOf = (o) => {
          const dir = String(o.direction || 'US_TO_UK');
          const mode = String(o.mode || 'AUTO');
          const cat = String(o.category || '');
          const mv = String(o.match?.value || '').toLowerCase();
          const rv = String(o.replace?.value || '').toLowerCase();
          const gt = String(o.gate || '').toLowerCase();
          return `${dir}|${mode}|${cat}|${gt}|${mv}|${rv}`;
        };

        const byKey = new Map();
        merged.forEach(o => byKey.set(keyOf(o), o));

        ENGINE_ASSETS.ukus = Array.from(byKey.values());

        // Keep the scanner + UI in sync with what’s actually in ENGINE_ASSETS.ukus
        try { hydrateLegacyGlobalsFromEngine(); } catch (_) {}
        try { if (typeof refreshDevLabContent === 'function') refreshDevLabContent(); } catch (_) {}


      }catch(e){ console.warn("UKUS rulepack merge failed", e); }
    })();


    // Optional: Populate the view with a toggle to switch between legacy vs engine data
    const toggleSource = document.getElementById('dictSourceToggle');
    if (toggleSource) {
      toggleSource.addEventListener('change', (e) => {
        const useEngine = e.target.checked;
        if (useEngine) {
          console.log('Using Engine data');
          // Code to render ENGINE_ASSETS data
        } else {
          console.log('Using Legacy data');
          // Code to render legacy data
        }
      });
    }

    // === Phase C: Legacy-shaped adapters sourced from ENGINE_ASSETS ===
    function escapeRegex(str) {
      return String(str).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    function buildUkusPattern(usValue) {
      const raw = String(usValue || '').trim();
      if (!raw) return null;

      // If it already looks like a regex source, try compile as-is.
      const looksLikeRegex = /\\b|\(|\)|\[|\]|\?|\||\+|\*|\^|\$|\{/.test(raw);
      if (looksLikeRegex) {
        try { return new RegExp(raw.replace(/\u0008/g, "\\b"), 'gi'); } catch(_) {}
      }

      // Normalise whitespace phrases into flexible spaces
      const parts = raw.split(/\s+/).filter(Boolean).map(escapeRegex);
      if (!parts.length) return null;
      const body = parts.length > 1 ? parts.join('\\s+') : parts[0];
      return new RegExp(`\\b${body}\\b`, 'gi');
    }

    function getJargonPatternsLegacy() {
      const eng = (typeof window !== 'undefined') ? window.ENGINE_ASSETS : null;
      if (!eng || !Array.isArray(eng.jargon)) return (typeof jargonPatterns !== 'undefined') ? jargonPatterns : [];
      const out = [];
      eng.jargon.forEach((j, i) => {
        const src = (j.patterns && j.patterns[0]) ? j.patterns[0] : (j.term ? `\\b${escapeRegex(j.term)}\\b` : '');
        if (!src) return;
        try {
          out.push({
            id: j.id || `eng_jargon_${i}`,
            pattern: new RegExp(src, 'gi'),
            suggestion: j.expansion || '',
            note: j.notes || '',
            severity: j.severity || 'HIGH',
            examples: j.examples || [],
          });
        } catch(_) {}
      });
      return out;
    }

    function getUkusPairsLegacy() {
      const eng = (typeof window !== 'undefined') ? window.ENGINE_ASSETS : null;
      if (!eng || !Array.isArray(eng.ukus)) {
        const fallbackRules = (typeof globalThis !== 'undefined' && globalThis.UKUS_RULES)
          ? globalThis.UKUS_RULES
          : { autoReplace: [], manualCheck: [] };
        return fallbackRules || { autoReplace: [], manualCheck: [] };
      }

      const autoReplace = [];
      const manualCheck = [];

      const getFn = (fnName) => {
        try {
          if (!fnName) return null;
          const fn = (typeof globalThis !== 'undefined') ? globalThis[String(fnName).trim()] : null;
          return (typeof fn === 'function') ? fn : null;
        } catch(_) { return null; }
      };

      const ensureFlags = (flags) => {
        let f = String(flags || 'gi');
        if (!f.includes('g')) f += 'g';
        if (!f.includes('i')) f += 'i';
        return f;
      };

      eng.ukus.forEach((p, i) => {
        const id = p.id || `eng_ukus_${i}`;

        // New schema fields (preferred)
        const mode = String(p.mode || p.badge || '').toUpperCase() === 'MANUAL' ? 'MANUAL' : 'AUTO';
        const category = p.category || p.type || 'misc';
        const gate = (p.gate == null) ? '' : String(p.gate).trim().toLowerCase();

        let pattern = null;
        let replacement = null;

        try {
          // --- MATCH ---
          if (p.match && typeof p.match === 'object') {
            const mt = String(p.match.type || 'literal').toLowerCase();
            const mv = String(p.match.value || '').trim();
            if (!mv) return;

            if (mt === 'regex') {
              pattern = new RegExp(mv.replace(/\u0008/g, "\\b"), ensureFlags(p.match.flags));
            } else {
              pattern = buildUkusPattern(mv);
            }
          } else {
            // Legacy schema support
            const badge = String(p.badge || '').toUpperCase();
            const ruleType = String(p.type || 'literal').toLowerCase();
            const src = String(p.pattern || '').trim();

            if (ruleType === 'regex' || ruleType === 'function') {
              if (!src) return;
              pattern = new RegExp(src.replace(/\u0008/g, "\\b"), 'gi');
            } else {
              const us = String(p.us || '').trim();
              const uk = String(p.uk || '').trim();
              if (!us || !uk) return;
              pattern = buildUkusPattern(us);
            }

            // carry badge/mode (legacy)
            if (badge === 'MANUAL' && String(p.mode || '').toUpperCase() !== 'MANUAL') {
              // allow legacy badge to force MANUAL
            }
          }

          if (!pattern) return;

          // --- REPLACE ---
          if (p.replace && typeof p.replace === 'object') {
            const rt = String(p.replace.type || 'literal').toLowerCase();
            const rv = (p.replace.value == null) ? '' : String(p.replace.value);
            if (rt === 'fn') {
              const fn = getFn(rv);
              replacement = fn || (m => m);
            } else {
              replacement = rv;
            }
          } else {
            // Legacy schema support
            const ruleType = String(p.type || 'literal').toLowerCase();
            if (ruleType === 'function') {
              const fn = getFn(p.fn);
              replacement = fn || (m => m);
            } else if (ruleType === 'regex') {
              replacement = String(p.replacement || p.uk || '');
            } else {
              replacement = String(p.uk || '');
            }
          }

          const base = { id, pattern, type: category, gate };

          if (mode === 'MANUAL') {
            manualCheck.push({ ...base, replacement });
          } else {
            autoReplace.push({ ...base, replacement });
          }
        } catch(_) {}
      });

      return { autoReplace, manualCheck };
    }
function getSafeWordsLegacy() {
      const eng = (typeof window !== 'undefined') ? window.ENGINE_ASSETS : null;
      if (!eng || !Array.isArray(eng.safeWords)) return (typeof SAFE_WORDS !== 'undefined') ? Array.from(SAFE_WORDS || []) : [];
      return eng.safeWords.map(sw => sw.term).filter(Boolean);
    }

    function getMoneyKeywordsLegacy() {
      const eng = (typeof window !== 'undefined') ? window.ENGINE_ASSETS : null;
      if (!eng || !eng.money || !Array.isArray(eng.money.keywords)) return (typeof MONEY_KEYWORDS !== 'undefined') ? MONEY_KEYWORDS : [];
      return eng.money.keywords.slice();
    }

    function hydrateLegacyGlobalsFromEngine() {
      const eng = (typeof window !== 'undefined') ? window.ENGINE_ASSETS : null;
      if (!eng) return;
      try {
        if (typeof jargonPatterns !== 'undefined') jargonPatterns = getJargonPatternsLegacy();
        if (typeof UKUS_RULES !== 'undefined') UKUS_RULES = getUkusPairsLegacy();
        if (typeof SAFE_WORDS !== 'undefined') SAFE_WORDS = new Set(getSafeWordsLegacy());
        if (typeof moneyKeywords !== 'undefined') moneyKeywords = getMoneyKeywordsLegacy();
        if (typeof MONEY_KEYWORDS !== 'undefined') MONEY_KEYWORDS = getMoneyKeywordsLegacy();
      } catch (e) {
        console.warn('ENGINE_ASSETS adapter hydration failed', e);
      }
    }

    hydrateLegacyGlobalsFromEngine();
    </script>

    <!-- Dev Lab keyboard toggle. Press Alt+D to enter or exit Dev Lab mode. -->
    <script>
    // Allow developers to enter Dev Lab mode using Alt+D.  This avoids needing a visible
    // button when the standard layout toggle cycles through split/notepad/MLCX only.
    (function enableDevLabHotkey(){
      document.addEventListener('keydown', function(e) {
        const key = e.key;
        // Normalise ctrl/cmd detection
        const isCtrlOrCmd = e.ctrlKey || e.metaKey;

        // Alt+D toggles dev mode on/off.  Use lowercase or uppercase D.
        const altTrigger = e.altKey && (key === 'd' || key === 'D');

        // Ctrl/Cmd + Shift + D also toggles dev mode (matches usage notes)
        const ctrlShiftTrigger = isCtrlOrCmd && e.shiftKey && (key === 'd' || key === 'D');

        if (altTrigger || ctrlShiftTrigger) {
          e.preventDefault();
          const current = document.body.dataset.layout || 'split';
          const next = current === 'dev' ? 'split' : 'dev';
          document.body.dataset.layout = next;
          // Fire a layoutchange event so other panels can update
          document.dispatchEvent(new CustomEvent('layoutchange', { detail: { mode: next } }));
          // If entering dev layout, attempt to initialise Dev Lab subviews after a tick.  This ensures the
          // Library Editor and Dictionaries panels have their event handlers bound even if they were
          // unavailable during DOMContentLoaded.
          if (next === 'dev') {
            setTimeout(() => {
              try {
                if (typeof initDevLabLibraryEditor === 'function') initDevLabLibraryEditor();
              } catch (err) {
                console.warn('[DevLab] Library Editor init on hotkey failed:', err);
              }
              try {
                if (typeof initDevLabDictionaries === 'function') initDevLabDictionaries();
              } catch (err) {
                console.warn('[DevLab] Dictionaries init on hotkey failed:', err);
              }
            }, 0);
          }
        }
      });
    })();

    // Dev Lab view hotkeys: Alt+1 (MLCX Debug); Alt+2/Alt+3 only when enabled via flags
    (function enableDevLabViewHotkeys(){
      document.addEventListener('keydown', function(e) {
        if (!e.altKey) return;
        const key = e.key;
        if (key !== '1' && key !== '2' && key !== '3') return;

        // Phase D: respect Dev Lab feature flags
        const showEditor = !!window.__DEVLAB_SHOW_LIBRARY_EDITOR;
        const showDict   = !!window.__DEVLAB_SHOW_DICTIONARIES;
        if (key === '2' && !showEditor) return;
        if (key === '3' && !showDict) return;

        const devPanel = document.querySelector('.dev-panel');
        if (!devPanel || typeof devPanel.__setDevView !== 'function') return;
        e.preventDefault();
        const mapping = { '1': 'mlcx', '2': 'editor', '3': 'dict' };
        devPanel.__setDevView(mapping[key]);
      });
    })();
    </script>

    <!-- Ensure Dev Lab subviews initialise when entering Dev mode.  The library editor and dictionaries
         panels may not exist at initial DOMContentLoaded, so their initialisation functions can return
         early.  Wire a listener on layoutchange to call them again once the Dev layout is active. -->
    <script>
    (function wireDevlabInitOnLayoutChange(){
      document.addEventListener('layoutchange', function(evt){
        if (evt && evt.detail && evt.detail.mode === 'dev'){
          // Defer initialisation to allow DOM to settle (panels are inserted after layout switch)
          setTimeout(() => {
            try {
              if (typeof initDevLabLibraryEditor === 'function') {
                initDevLabLibraryEditor();
              }
            } catch (e) {
              console.warn('[DevLab] Library Editor init on layoutchange failed:', e);
            }
            try {
              if (typeof initDevLabDictionaries === 'function') {
                initDevLabDictionaries();
              }
            } catch (e) {
              console.warn('[DevLab] Dictionaries init on layoutchange failed:', e);
            }
          }, 0);
        }
      });
    })();
    </script>

    <!-- Fallback Dev Lab view toggler. Some builds do not wire the view toggles correctly; this script
         ensures the Library Editor and Dictionaries tabs function even if the primary setDevView wiring
         fails. It also exposes __setDevView for hotkey integration. -->
    <script>
    (function attachDevlabFallbackToggle(){
      document.addEventListener('DOMContentLoaded', function(){
        const panel = document.querySelector('.dev-panel');
        if (!panel) return;
        const buttons = Array.from(panel.querySelectorAll('.devlab-toggle-btn'));
        const views   = Array.from(panel.querySelectorAll('.devlab-view'));
        const switchView = function(name){
          views.forEach(v => {
            const match = (v.getAttribute('data-dev-view') === name);
            // use both hidden and inline style for maximum compatibility
            v.hidden = !match;
            v.style.display = match ? '' : 'none';
          });
          panel.setAttribute('data-current-view', name);
          panel.setAttribute('data-dev-view', name);
          buttons.forEach(b => b.classList.toggle('is-active', (b.getAttribute('data-view') === name)));
          // When switching views ensure corresponding panels are initialised.  If the init functions
          // fail because elements are missing, the try/catch prevents errors from breaking switching.
          if (name === 'editor') {
            try {
              if (typeof initDevLabLibraryEditor === 'function') initDevLabLibraryEditor();
            } catch (e) {
              console.warn('[DevLab] Library Editor init on view switch failed:', e);
            }
          } else if (name === 'dict') {
            try {
              if (typeof initDevLabDictionaries === 'function') initDevLabDictionaries();
            } catch (e) {
              console.warn('[DevLab] Dictionaries init on view switch failed:', e);
            }
          }
        };
        // Expose as debug/hotkey hook
        panel.__setDevView = switchView;
        buttons.forEach(btn => {
          btn.addEventListener('click', function(e){
            const view = btn.getAttribute('data-view');
            if (view) {
              e.preventDefault();
              switchView(view);
            }
          });
        });
        // Apply initial view if not already set by other scripts
        const initial = panel.getAttribute('data-current-view') || panel.getAttribute('data-dev-view') || 'mlcx';
        switchView(initial);
      });
    })();
    </script>

    <!--
       A final safety net to ensure that Dev Lab subviews (Library Editor and Dictionaries) are properly
       initialised. In some builds the panels are inserted into the DOM asynchronously after the
       layout has switched to "dev" mode, which means that calls to initDevLabLibraryEditor() and
       initDevLabDictionaries() may run too early and exit without wiring up controls. This
       helper listens for the "layoutchange" event and then repeatedly attempts to invoke the
       initialisers until the expected UI elements (like the "Add New" button in the editor) are
       enabled. It will stop retrying once the Library Editor add button is active or after a
       limited number of attempts. This has no effect on other layouts and only runs when the
       dev layout becomes active.
    -->
    <script>
    (function ensureDevlabInitialised(){
      // Maximum number of retries to avoid endless loops
      const MAX_ATTEMPTS = 20;
      // Delay between retries (ms)
      const RETRY_DELAY  = 400;
      // Attempt counters scoped by layout session
      let attemptCounter = 0;

      function tryInit() {
        attemptCounter++;
        // If the Library Editor add-new button exists and is not disabled, we consider the
        // editor initialised and stop further attempts.  This button is disabled by default
        // until initDevLabLibraryEditor() enables it.
        const addBtn = document.querySelector('.devlab-view-editor .lib-add-new');
        const editorReady = addBtn && !addBtn.disabled;
        if (editorReady) {
          return;
        }
        // Call the original init functions if available.  Use try/catch to avoid aborting
        // if they throw, as they may rely on partially loaded DOM.
        try {
          if (typeof initDevLabLibraryEditor === 'function') {
            initDevLabLibraryEditor();
          }
        } catch (err) {
          console.warn('[DevLab] ensureDevlabInitialised: Library Editor init attempt failed:', err);
        }
        try {
          if (typeof initDevLabDictionaries === 'function') {
            initDevLabDictionaries();
          }
        } catch (err) {
          console.warn('[DevLab] ensureDevlabInitialised: Dictionaries init attempt failed:', err);
        }
        // Retry again if we haven't exceeded attempts
        if (attemptCounter < MAX_ATTEMPTS) {
          setTimeout(tryInit, RETRY_DELAY);
        }
      }

      document.addEventListener('layoutchange', function(evt){
        if (evt && evt.detail && evt.detail.mode === 'dev') {
          // Reset attempt counter for new dev session
          attemptCounter = 0;
          // Defer initial call slightly to allow DOM injection to occur
          setTimeout(tryInit, RETRY_DELAY);
        }
      });
    })();
    </script>

    <!--
      A simplified fallback implementation for the Dev Lab Library Editor. Some builds ship the
      editor interface but do not bind any of the controls. This script provides basic
      functionality for adding, editing, duplicating, archiving and deleting templates. It is
      deliberately lightweight and does not include advanced filters or jargon analysis but
      ensures that the primary controls are usable.  It runs only after the layout switches to
      dev mode and will not interfere with a working implementation because it checks whether
      the Add New button has already been bound.
    -->
    <script>
    (function fallbackLibraryEditorSimple(){
      function initialiseFallback() {
        const view = document.querySelector('.devlab-view-editor');
        if (!view) return;
        const addBtn = view.querySelector('.lib-add-new');
        // Only run if the Add New button exists and has not been bound by this fallback before
        if (!addBtn || addBtn.dataset.simpleBound) return;
        addBtn.dataset.simpleBound = 'true';

        // Mark the Add New button to indicate the fallback initialised.  This
        // visual cue helps confirm that the fallback executed successfully.
        try {
          const originalLabel = addBtn.textContent || '';
          if (!/\(f\)/i.test(originalLabel)) {
            addBtn.textContent = originalLabel.trim() + ' (f)';
          }
        } catch (_) {}

        // Ensure global libraries exist
        if (typeof window.repliesLibrary === 'undefined') window.repliesLibrary = [];
        if (typeof window.phrasesLibrary === 'undefined') window.phrasesLibrary = [];

        // Reference UI elements
        const listContainer = view.querySelector('.lib-template-list');
        const searchInput  = view.querySelector('.lib-search');
        const groupFilter  = view.querySelector('.lib-group-filter');
        const statusButtons = view.querySelectorAll('.lib-status-button');
        const bulkActionButtons = view.querySelectorAll('.lib-bulk-actions button');
        const editorTitle  = view.querySelector('#editor-title');
        const editorGroup  = view.querySelector('#editor-group');
        const editorText   = view.querySelector('#editor-text');
        const editorActive = view.querySelector('#editor-active');
        const saveBtn      = view.querySelector('.editor-save');
        const dupBtn       = view.querySelector('.editor-duplicate');
        const archBtn      = view.querySelector('.editor-archive');
        const deleteBtn    = view.querySelector('.editor-delete');

        // Enable previously disabled controls for interactivity.  When a control
        // was rendered with a `disabled` attribute, simply setting the
        // `disabled` property to false may not remove the attribute.  To
        // guarantee the control becomes clickable, remove the attribute as
        // well.
        [searchInput, groupFilter, editorGroup, editorText, editorActive, saveBtn, dupBtn, archBtn, deleteBtn, addBtn].forEach(el => {
          if (!el) return;
          el.disabled = false;
          try { el.removeAttribute('disabled'); } catch(_){}
        });
        statusButtons.forEach(btn => {
          btn.disabled = false;
          try { btn.removeAttribute('disabled'); } catch(_){}
        });
        bulkActionButtons.forEach(btn => {
          btn.disabled = false;
          try { btn.removeAttribute('disabled'); } catch(_){}
        });

        // Insert a simple library type toggle (Replies vs Phrases) if not already present.  Some
        // builds omit controls to switch between the replies and phrases libraries, so we
        // dynamically insert our own.  The toggle consists of two buttons that update
        // `currentLibraryType` when clicked and re-render the list.  Active state is shown
        // by applying the class `lib-status-active`.
        const leftPane = view.querySelector('.devlab-editor-left');
        if (leftPane && !leftPane.querySelector('.lib-type-toggle')) {
          const typeContainer = document.createElement('div');
          typeContainer.className = 'lib-type-toggle';
          typeContainer.style.display = 'flex';
          typeContainer.style.gap = '8px';
          typeContainer.style.marginBottom = '8px';
          const repliesBtn = document.createElement('button');
          repliesBtn.type = 'button';
          repliesBtn.className = 'lib-type-btn';
          repliesBtn.dataset.type = 'replies';
          repliesBtn.textContent = 'Replies';
          const phrasesBtn = document.createElement('button');
          phrasesBtn.type = 'button';
          phrasesBtn.className = 'lib-type-btn';
          phrasesBtn.dataset.type = 'phrases';
          phrasesBtn.textContent = 'Phrases';
          // helper to set active class
          function updateTypeActive() {
            [repliesBtn, phrasesBtn].forEach(btn => {
              const isActive = btn.dataset.type === currentLibraryType;
              btn.classList.toggle('lib-status-active', isActive);
            });
          }
          repliesBtn.addEventListener('click', () => {
            currentLibraryType = 'replies';
            updateTypeActive();
            // Clear selection and filters when switching type
            selectedIds = [];
            currentId = null;
            selectedGroup = 'all';
            searchTerm = '';
            // Reset search input and group filter
            if (searchInput) searchInput.value = '';
            renderList();
            // Reset editor state
            if (editorTitle) editorTitle.textContent = 'Select a template';
            if (editorGroup) editorGroup.value = '';
            if (editorText) editorText.value = '';
            if (editorActive) editorActive.checked = false;
            // Disable editor until selection
            if (editorGroup) editorGroup.disabled = true;
            if (editorText) editorText.disabled = true;
            if (editorActive) editorActive.disabled = true;
            if (saveBtn) saveBtn.disabled = true;
            if (dupBtn) dupBtn.disabled = true;
            if (archBtn) archBtn.disabled = true;
            if (deleteBtn) deleteBtn.disabled = true;
          });
          phrasesBtn.addEventListener('click', () => {
            currentLibraryType = 'phrases';
            updateTypeActive();
            selectedIds = [];
            currentId = null;
            selectedGroup = 'all';
            searchTerm = '';
            if (searchInput) searchInput.value = '';
            renderList();
            if (editorTitle) editorTitle.textContent = 'Select a template';
            if (editorGroup) editorGroup.value = '';
            if (editorText) editorText.value = '';
            if (editorActive) editorActive.checked = false;
            if (editorGroup) editorGroup.disabled = true;
            if (editorText) editorText.disabled = true;
            if (editorActive) editorActive.disabled = true;
            if (saveBtn) saveBtn.disabled = true;
            if (dupBtn) dupBtn.disabled = true;
            if (archBtn) archBtn.disabled = true;
            if (deleteBtn) deleteBtn.disabled = true;
          });
          typeContainer.appendChild(repliesBtn);
          typeContainer.appendChild(phrasesBtn);
          leftPane.insertBefore(typeContainer, leftPane.firstChild);
          // Set initial active state
          updateTypeActive();
        }

        // Local state
        let currentLibraryType = 'replies';
        let currentId = null;
        // Additional state for filters and selection.  searchTerm stores the current
        // search string, selectedGroup tracks the group filter and statusMode
        // determines whether active or archived items are shown.  selectedIds
        // holds the identifiers of any rows selected via the checkboxes for
        // bulk actions.
        let searchTerm = '';
        let selectedGroup = 'all';
        let statusMode = 'active';
        let selectedIds = [];

        function getLibrary() {
          return currentLibraryType === 'replies' ? window.repliesLibrary : window.phrasesLibrary;
        }

        // Helper: update editor group dropdown based on current library groups
        function updateEditorGroupDropdown() {
          if (!editorGroup) return;
          const lib = getLibrary() || [];
          // collect unique groups
          const groups = [];
          lib.forEach(it => {
            const g = String(it.group || '').trim();
            if (g && !groups.includes(g)) groups.push(g);
          });
          // Always include General if no groups exist
          if (!groups.includes('General')) groups.unshift('General');
          editorGroup.innerHTML = '';
          groups.forEach(g => {
            const opt = document.createElement('option');
            opt.value = g;
            opt.textContent = g.charAt(0).toUpperCase() + g.slice(1);
            editorGroup.appendChild(opt);
          });
        }

        function updateGroupOptions() {
          // Populate the group filter select based on groups present in the
          // current library. Always include an "all" option.  Preserve
          // selectedGroup if possible.
          if (!groupFilter) return;
          const lib = getLibrary() || [];
          const groups = ['all'];
          lib.forEach(it => {
            const g = String(it.group || '').trim();
            if (g && !groups.includes(g)) groups.push(g);
          });
          groupFilter.innerHTML = '';
          groups.forEach(g => {
            const opt = document.createElement('option');
            opt.value = g;
            // Capitalise first letter for nicer display
            opt.textContent = g === 'all' ? 'All groups' : g.charAt(0).toUpperCase() + g.slice(1);
            if (g === selectedGroup) opt.selected = true;
            groupFilter.appendChild(opt);
          });
          // Update editor group dropdown whenever group filter options change
          updateEditorGroupDropdown();
        }

        function updateBulkButtons() {
          // Enable or disable bulk action buttons based on number of selected items
          const count = selectedIds.length;
          bulkActionButtons.forEach(btn => {
            btn.disabled = count === 0;
          });
        }

        function renderList() {
          // Build list of items applying search, group and status filters. This
          // function replaces the original simple implementation and adds
          // checkboxes for multi-selection as well as search and group
          // filtering support.
          const lib = getLibrary();
          listContainer.innerHTML = '';
          // Ensure group options reflect current library contents
          updateGroupOptions();
          let items = Array.isArray(lib) ? lib.slice() : [];
          // Filter by status
          items = items.filter(it => {
            if (statusMode === 'active') return !!it.active;
            if (statusMode === 'archived') return !it.active;
            return true;
          });
          // Filter by group
          if (selectedGroup && selectedGroup !== 'all') {
            items = items.filter(it => String(it.group || '').toLowerCase() === selectedGroup.toLowerCase());
          }
          // Filter by search term
          if (searchTerm) {
            const q = searchTerm.toLowerCase();
            items = items.filter(it => {
              return (String(it.id).toLowerCase().includes(q) ||
                      String(it.text || '').toLowerCase().includes(q));
            });
          }
          if (!items || items.length === 0) {
            listContainer.innerHTML = '<p class="lib-empty-state">No templates match your criteria.</p>';
            // Also ensure bulk buttons are disabled when nothing matches
            selectedIds = [];
            updateBulkButtons();
            return;
          }
          items.forEach(item => {
            const row = document.createElement('div');
            row.className = 'lib-template-item';
            row.style.display = 'flex';
            row.style.alignItems = 'center';
            row.style.cursor = 'pointer';
            // Checkbox for multi-select
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'lib-select-checkbox';
            checkbox.style.marginRight = '6px';
            checkbox.dataset.id = item.id;
            checkbox.checked = selectedIds.includes(item.id);
            checkbox.addEventListener('change', () => {
              const id = item.id;
              if (checkbox.checked) {
                if (!selectedIds.includes(id)) selectedIds.push(id);
              } else {
                const idx = selectedIds.indexOf(id);
                if (idx >= 0) selectedIds.splice(idx, 1);
              }
              updateBulkButtons();
            });
            row.appendChild(checkbox);
            // Label showing id and truncated text
            const label = document.createElement('span');
            label.textContent = `${item.id}: ${String(item.text || '').slice(0, 30)}`;
            row.appendChild(label);
            // Row click selects for editing but not when clicking checkbox
            row.addEventListener('click', (e) => {
              if (e.target && e.target.tagName === 'INPUT') return;
              currentId = item.id;
              if (editorTitle) editorTitle.textContent = `Editing: ${item.id}`;
              if (editorGroup) editorGroup.value = item.group || '';
              if (editorText) editorText.value = item.text || '';
              if (editorActive) editorActive.checked = !!item.active;
              // Enable editor controls since an item is selected
              if (editorGroup) editorGroup.disabled = false;
              if (editorText) editorText.disabled = false;
              if (editorActive) editorActive.disabled = false;
              if (saveBtn) saveBtn.disabled = false;
              if (dupBtn) dupBtn.disabled = false;
              if (archBtn) archBtn.disabled = false;
              if (deleteBtn) deleteBtn.disabled = false;
            });
            listContainer.appendChild(row);
          });
          updateBulkButtons();
        }

        // Helper to add a new item to the current library
        function addNewItem() {
          const lib = getLibrary();
          const prefix = currentLibraryType === 'replies' ? 'reply_' : 'phrase_';
          const newId = `${prefix}${lib.length + 1}`;
          const newItem = { id: newId, group: 'General', text: '', active: true };
          lib.push(newItem);
          renderList();
          currentId = newId;
          if (editorTitle) editorTitle.textContent = `Editing: ${newId}`;
          if (editorGroup) editorGroup.value = 'General';
          if (editorText) editorText.value = '';
          if (editorActive) editorActive.checked = true;
          // Enable editor controls when a new item is created
          if (editorGroup) editorGroup.disabled = false;
          if (editorText) editorText.disabled = false;
          if (editorActive) editorActive.disabled = false;
          if (saveBtn) saveBtn.disabled = false;
          if (dupBtn) dupBtn.disabled = false;
          if (archBtn) archBtn.disabled = false;
          if (deleteBtn) deleteBtn.disabled = false;
        }

        // Wire Add New button via dedicated event.  Direct binding may fail if the
        // button is overlaid or replaced by other scripts, so we also listen for
        // click events bubbling up to the view and trigger our addNewItem() when
        // a .lib-add-new element is clicked.
        if (addBtn) {
          addBtn.addEventListener('click', (e) => {
            e.preventDefault();
            addNewItem();
          });
        }
        // Fallback: capture any click on a .lib-add-new within the editor view
        view.addEventListener('click', function(evt) {
          const btn = evt.target && evt.target.closest('.lib-add-new');
          if (!btn) return;
          evt.preventDefault();
          addNewItem();
        });

        // Search filter: update searchTerm and re-render list
        if (searchInput) {
          searchInput.addEventListener('input', (evt) => {
            searchTerm = evt.target.value || '';
            renderList();
          });
        }

        // Group filter: update selectedGroup and re-render list
        if (groupFilter) {
          groupFilter.addEventListener('change', (evt) => {
            selectedGroup = evt.target.value || 'all';
            renderList();
          });
        }

        // Status buttons: toggle active/archived filters
        if (statusButtons && statusButtons.length) {
          statusButtons.forEach(btn => {
            btn.addEventListener('click', () => {
              const mode = btn.getAttribute('data-mode');
              if (!mode) return;
              statusMode = mode;
              // Update active class on buttons
              statusButtons.forEach(b => {
                b.classList.toggle('lib-status-active', b === btn);
              });
              renderList();
            });
          });
        }

        // Bulk actions: delete selected templates
        const bulkDeleteBtn  = view.querySelector('.bulk-delete');
        const bulkArchiveBtn = view.querySelector('.bulk-archive');
        const bulkRestoreBtn = view.querySelector('.bulk-restore');
        const bulkDupBtn     = view.querySelector('.bulk-duplicate');
        if (bulkDeleteBtn) {
          bulkDeleteBtn.addEventListener('click', () => {
            const lib = getLibrary();
            selectedIds.forEach(id => {
              const idx = lib.findIndex(it => it.id === id);
              if (idx >= 0) {
                lib.splice(idx, 1);
              }
            });
            selectedIds = [];
            // Clear editor if current item was deleted
            if (currentId && !lib.find(it => it.id === currentId)) {
              currentId = null;
              if (editorTitle) editorTitle.textContent = 'Select a template';
              if (editorGroup) editorGroup.value = '';
              if (editorText) editorText.value = '';
              if (editorActive) editorActive.checked = false;
            }
            renderList();
          });
        }
        if (bulkArchiveBtn) {
          bulkArchiveBtn.addEventListener('click', () => {
            const lib = getLibrary();
            selectedIds.forEach(id => {
              const item = lib.find(it => it.id === id);
              if (item) item.active = false;
            });
            selectedIds = [];
            renderList();
          });
        }
        if (bulkRestoreBtn) {
          bulkRestoreBtn.addEventListener('click', () => {
            const lib = getLibrary();
            selectedIds.forEach(id => {
              const item = lib.find(it => it.id === id);
              if (item) item.active = true;
            });
            selectedIds = [];
            renderList();
          });
        }
        if (bulkDupBtn) {
          bulkDupBtn.addEventListener('click', () => {
            const lib = getLibrary();
            selectedIds.forEach(id => {
              const orig = lib.find(it => it.id === id);
              if (!orig) return;
              const prefix = currentLibraryType === 'replies' ? 'reply_' : 'phrase_';
              const newId = `${prefix}${lib.length + 1}`;
            lib.push({ id: newId, group: orig.group, text: `${orig.text} (copy)`, active: true });
            });
            selectedIds = [];
            renderList();
          });
        }

        // Wire save action
        if (saveBtn) {
          saveBtn.addEventListener('click', () => {
            if (!currentId) return;
            const lib = getLibrary();
            const item = lib.find(t => t.id === currentId);
            if (!item) return;
            item.group = editorGroup ? editorGroup.value : item.group;
            item.text  = editorText ? editorText.value : item.text;
            item.active = editorActive ? !!editorActive.checked : item.active;
            renderList();
          });
        }

        // Wire duplicate action
        if (dupBtn) {
          dupBtn.addEventListener('click', () => {
            if (!currentId) return;
            const lib = getLibrary();
            const orig = lib.find(t => t.id === currentId);
            if (!orig) return;
            const prefix = currentLibraryType === 'replies' ? 'reply_' : 'phrase_';
            const newId = `${prefix}${lib.length + 1}`;
            lib.push({ id: newId, group: orig.group, text: `${orig.text} (copy)`, active: true });
            renderList();
          });
        }

        // Wire archive toggle action
        if (archBtn) {
          archBtn.addEventListener('click', () => {
            if (!currentId) return;
            const lib = getLibrary();
            const item = lib.find(t => t.id === currentId);
            if (!item) return;
            item.active = !item.active;
            if (editorActive) editorActive.checked = item.active;
            renderList();
          });
        }

        // Wire delete action
        if (deleteBtn) {
          deleteBtn.addEventListener('click', () => {
            if (!currentId) return;
            const lib = getLibrary();
            const idx = lib.findIndex(t => t.id === currentId);
            if (idx >= 0) {
              lib.splice(idx, 1);
              currentId = null;
              if (editorTitle) editorTitle.textContent = 'Select a template';
              if (editorGroup) editorGroup.value = '';
              if (editorText) editorText.value = '';
              if (editorActive) editorActive.checked = false;
              renderList();
            }
          });
        }

        // Initial render
        renderList();
      }

      // Listen for dev layout activation to initialise fallback.  When the layout
      // switches into dev mode (e.g. via Alt+D or similar), the editor view is
      // injected into the DOM.  We schedule a call to initialiseFallback to
      // wire up the controls.  Using a small delay ensures that the DOM is
      // fully rendered before we bind events.
      document.addEventListener('layoutchange', function(evt) {
        if (evt && evt.detail && evt.detail.mode === 'dev') {
          setTimeout(initialiseFallback, 600);
        }
      });

      // Additionally initialise the fallback once after page load.  Some builds
      // render the Dev Lab editor by default without dispatching a layoutchange
      // event, which means the above listener will never fire.  A delayed
      // invocation ensures that the fallback runs in these scenarios too.  The
      // guard on the Add New button prevents double-binding.
      if (document.readyState === 'complete') {
        setTimeout(initialiseFallback, 1200);
      } else {
        window.addEventListener('load', () => {
          setTimeout(initialiseFallback, 1200);
        });
      }

      // Also initialise fallback when the Library Editor tab is clicked.  This
      // catches cases where the user switches views without a layout change.
      document.addEventListener('click', function(evt){
        const btn = evt.target && evt.target.closest('.devlab-toggle-btn');
        if (btn && btn.getAttribute('data-view') === 'editor') {
          setTimeout(initialiseFallback, 300);
        }
      });

      // Periodically attempt to initialise the fallback a few times.  If the
      // editor view is injected without any events firing, this interval will
      // eventually bind the controls.  It stops once the Add New button has
      // been bound or after several attempts.
      let fallbackAttempts = 0;
      const fallbackInterval = setInterval(() => {
        const viewCheck = document.querySelector('.devlab-view-editor');
        const addCheck  = viewCheck && viewCheck.querySelector('.lib-add-new');
        if (addCheck && !addCheck.dataset.simpleBound) {
          initialiseFallback();
        }
        fallbackAttempts++;
        if (fallbackAttempts >= 8 || (addCheck && addCheck.dataset.simpleBound)) {
          clearInterval(fallbackInterval);
        }
      }, 800);
    })();
    </script>

    <!--
      A helper to ensure the dictionaries view initialises correctly. Some builds do not bind
      the dictionary UI on tab click, leaving the lists empty and counts stuck on
      "loading". This script listens for clicks on the Dictionaries tab and then invokes
      initDevLabDictionaries() several times with a small delay to give the DOM time to
      render. It stops retrying once the counts panel no longer shows a loading message.
    -->
    <script>
    (function ensureDictionariesInitialised(){
      function tryInit() {
        const counts = document.getElementById('dictCounts');
        // If counts element exists and does not contain 'loading', assume initialisation succeeded
        if (counts && !/loading/i.test(counts.textContent || '')) {
          return;
        }
        try {
          if (typeof initDevLabDictionaries === 'function') {
            initDevLabDictionaries();
          }
        } catch (e) {
          console.warn('[DevLab] ensureDictionariesInitialised: init attempt failed:', e);
        }
        // schedule another attempt if still loading
        attempts++;
        if (attempts < MAX_ATTEMPTS) {
          setTimeout(tryInit, RETRY_DELAY);
        }
      }
      const MAX_ATTEMPTS = 10;
      const RETRY_DELAY  = 300;
      let attempts = 0;
      document.addEventListener('click', function(evt){
        const btn = evt.target && evt.target.closest('.devlab-toggle-btn');
        if (btn && btn.getAttribute('data-view') === 'dict') {
          attempts = 0;
          setTimeout(tryInit, 200);
        }
      });
      // Also attempt when switching layout to dev – dictionary may be the default view from previous session
      document.addEventListener('layoutchange', function(evt){
        if (evt && evt.detail && evt.detail.mode === 'dev') {
          attempts = 0;
          setTimeout(tryInit, 400);
        }
      });
    })();
    </script>

    <!--
      Simplified fallback implementation for the Dictionaries panel. In some builds the
      underlying data sources (ENGINE_ASSETS, jargonPatterns, UKUS_RULES) are not available,
      resulting in an empty dictionary UI. This fallback injects a small set of sample
      jargon and UK⇄US entries and wires up basic interactivity so users can browse and
      inspect them. It only activates when the Dictionaries panel becomes visible and
      will not override a working implementation.
    -->
    <script>
    (function fallbackDictionaries(){
      const sampleJargon = [
        { id:'j1', term:'ASAP', expansion:'As Soon As Possible', severity:'HIGH', notes:'Avoid abbreviations for clarity.' },
        { id:'j2', term:'FYI', expansion:'For Your Information', severity:'MED', notes:'Spell out on first use.' },
        { id:'j3', term:'TBC', expansion:'To Be Confirmed', severity:'LOW', notes:'Use only when necessary.' }
      ];
      const sampleUkus = [
        { id:'u1', us:'color', uk:'colour', type:'Spelling', notes:'UK spelling retains the u.' },
        { id:'u2', us:'organize', uk:'organise', type:'Spelling', notes:'Use s instead of z.' },
        { id:'u3', us:'meter', uk:'metre', type:'Spelling', notes:'Different spelling conventions.' }
      ];
      function initFallback() {
        const view = document.querySelector('.devlab-view-dict');
        if (!view || view.dataset.fallbackBound) return;
        // If the native dictionary has populated counts, do not activate fallback
        const countsEl = document.getElementById('dictCounts');
        if (countsEl && countsEl.textContent && !/loading/i.test(countsEl.textContent)) return;
        view.dataset.fallbackBound = 'true';

        // Get UI elements
        const sectionButtons = view.querySelectorAll('.dictSectionBtn');
        const listPanel = document.getElementById('dictList');
        const emptyState = document.getElementById('dictEmptyState');
        const detailPanel = document.getElementById('dictDetail');
        const detailEmpty = document.getElementById('dictDetailEmpty');
        const detailTitle = document.getElementById('detailTitle');
        const detailBody  = document.getElementById('detailBody');
        const detailNotes = document.getElementById('detailNotes');
        const counts      = document.getElementById('dictCounts');

        // Additional topbar controls
        const searchInput   = document.getElementById('dictSearch');
        const scopeSelect   = document.getElementById('dictScope');
        const copyViewBtn   = document.getElementById('dictCopyView');
        const copyItemBtn   = document.getElementById('dictCopyItem');
        const copyJargonBtn = document.getElementById('dictCopyJargon');
        const copyUkusBtn   = document.getElementById('dictCopyUkus');
        const exportBtn     = document.getElementById('dictExportJson');

        // Search state: holds the current search term.  When non-empty it
        // filters items in the list by matching term, expansion, us/uk or notes.
        let searchTerm = '';

        // Helper to copy arbitrary text to the clipboard.  Uses the
        // asynchronous Clipboard API where available and falls back to
        // document.execCommand for older environments.
        function copyTextToClipboard(text) {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(text).catch(() => {});
          } else {
            const ta = document.createElement('textarea');
            ta.value = text;
            // Hide the textarea off-screen
            ta.style.position = 'fixed';
            ta.style.left = '-9999px';
            document.body.appendChild(ta);
            ta.focus();
            ta.select();
            try { document.execCommand('copy'); } catch(e) {}
            document.body.removeChild(ta);
          }
        }

        // Apply search filter to a list of items.  Returns items that
        // contain the searchTerm in their fields depending on the current
        // section (jargon or UKUS).  If searchTerm is empty, returns the
        // original list unchanged.
        function applyFilters(items) {
          if (!searchTerm) return items;
          const q = searchTerm.toLowerCase();
          return items.filter(item => {
            if (section === 'jargon') {
              return (item.term && item.term.toLowerCase().includes(q)) ||
                     (item.expansion && item.expansion.toLowerCase().includes(q)) ||
                     (item.notes && item.notes.toLowerCase().includes(q));
            } else {
              return (item.us && item.us.toLowerCase().includes(q)) ||
                     (item.uk && item.uk.toLowerCase().includes(q)) ||
                     (item.notes && item.notes.toLowerCase().includes(q));
            }
          });
        }

        let section = 'jargon';
        let selectedKey = null;

        function updateCounts() {
          if (counts) counts.textContent = `Jargon: ${sampleJargon.length} • UKUS: ${sampleUkus.length}`;
        }
        function renderList() {
          listPanel.innerHTML = '';
          let items = section === 'jargon' ? sampleJargon : sampleUkus;
          items = applyFilters(items);
          if (!items || items.length === 0) {
            if (emptyState) emptyState.style.display = '';
            if (copyItemBtn) copyItemBtn.disabled = true;
            return;
          }
          if (emptyState) emptyState.style.display = 'none';
          items.forEach(item => {
            const row = document.createElement('button');
            row.type = 'button';
            row.className = 'dictItem';
            row.style.display = 'flex';
            row.style.justifyContent = 'space-between';
            row.style.alignItems = 'center';
            row.style.marginBottom = '4px';
            // Primary text
            const primary = document.createElement('div');
            primary.className = 'dictItemPrimary';
            if (section === 'jargon') {
              primary.textContent = `${item.term} → ${item.expansion}`;
            } else {
              primary.textContent = `${item.us} → ${item.uk}`;
            }
            const badge = document.createElement('div');
            badge.className = 'dictItemBadge';
            badge.textContent = section === 'jargon' ? item.severity : item.type;
            badge.style.marginLeft = '8px';
            badge.style.fontSize = '0.8rem';
            badge.style.opacity = '0.8';
            row.appendChild(primary);
            row.appendChild(badge);
            row.addEventListener('click', () => {
              selectedKey = item.id;
              renderList();
              renderDetail(item);
            });
            if (selectedKey === item.id) row.classList.add('is-selected');
            listPanel.appendChild(row);
          });
          // Update copy item button state based on selection
          if (copyItemBtn) copyItemBtn.disabled = !selectedKey;
        }
        function renderDetail(item) {
          if (!detailPanel || !detailTitle || !detailBody || !detailNotes) return;
          // Hide empty notice and show detail panel
          if (detailEmpty) detailEmpty.style.display = 'none';
          detailPanel.style.display = '';
          detailTitle.textContent = section === 'jargon' ? item.term : `${item.us} → ${item.uk}`;
          detailBody.textContent  = section === 'jargon' ? item.expansion : '';
          detailNotes.textContent = item.notes || '';
          // Enable copy item button now that a detail is selected
          if (copyItemBtn) copyItemBtn.disabled = false;
        }
        function clearDetail() {
          if (detailPanel) detailPanel.style.display = 'none';
          if (detailEmpty) detailEmpty.style.display = '';
          // Disable copy item button when nothing is selected
          if (copyItemBtn) copyItemBtn.disabled = true;
          selectedKey = null;
        }
        sectionButtons.forEach(btn => {
          btn.addEventListener('click', () => {
            const next = btn.dataset.dictSection;
            if (next && next !== section) {
              section = next;
              selectedKey = null;
              // update active class
              sectionButtons.forEach(b => b.classList.toggle('is-active', b.dataset.dictSection === section));
              clearDetail();
              updateCounts();
              renderList();
            }
          });
        });

        // Wire up search input to filter dictionary entries
        if (searchInput) {
          searchInput.addEventListener('input', () => {
            searchTerm = searchInput.value || '';
            renderList();
            clearDetail();
          });
        }

        // Scope select allows switching between jargon and UK⇄US quickly.  When
        // set to "jargon" or "ukus" it triggers the same behaviour as
        // clicking the section buttons.  When set to "all" no section
        // change occurs but the list is re-rendered to apply search.
        if (scopeSelect) {
          scopeSelect.addEventListener('change', () => {
            const val = scopeSelect.value;
            if (val === 'jargon' || val === 'ukus') {
              section = val;
              selectedKey = null;
              sectionButtons.forEach(b => b.classList.toggle('is-active', b.dataset.dictSection === section));
              clearDetail();
              updateCounts();
              renderList();
            } else {
              // 'all' just re-render the current section
              renderList();
              clearDetail();
            }
          });
        }

        // Copy the current filtered view of the dictionary to the clipboard
        if (copyViewBtn) {
          copyViewBtn.addEventListener('click', () => {
            let items = section === 'jargon' ? sampleJargon : sampleUkus;
            items = applyFilters(items);
            const lines = items.map(item => {
              return section === 'jargon'
                ? `${item.term} → ${item.expansion}`
                : `${item.us} → ${item.uk}`;
            });
            copyTextToClipboard(lines.join('\n'));
          });
        }

        // Copy a sample paste-test string for jargon entries
        if (copyJargonBtn) {
          copyJargonBtn.addEventListener('click', () => {
            const tokens = sampleJargon.map(it => it.term).join(' ');
            copyTextToClipboard(tokens);
          });
        }

        // Copy a sample paste-test string for UK⇄US entries
        if (copyUkusBtn) {
          copyUkusBtn.addEventListener('click', () => {
            const tokens = sampleUkus.map(it => `${it.us}/${it.uk}`).join(', ');
            copyTextToClipboard(tokens);
          });
        }

        // Copy the selected dictionary item's details
        if (copyItemBtn) {
          copyItemBtn.disabled = true;
          copyItemBtn.addEventListener('click', () => {
            if (!selectedKey) return;
            let item;
            if (section === 'jargon') {
              item = sampleJargon.find(it => it.id === selectedKey);
              if (item) {
                copyTextToClipboard(`${item.term} → ${item.expansion}\n${item.notes || ''}`);
              }
            } else {
              item = sampleUkus.find(it => it.id === selectedKey);
              if (item) {
                copyTextToClipboard(`${item.us} → ${item.uk}\n${item.notes || ''}`);
              }
            }
          });
        }

        // Export the entire sample dictionary as JSON for inspection
        if (exportBtn) {
          exportBtn.disabled = false;
          exportBtn.addEventListener('click', () => {
            const data = { jargon: sampleJargon, ukus: sampleUkus };
            copyTextToClipboard(JSON.stringify(data, null, 2));
          });
        }
        // Initial render
        clearDetail();
        updateCounts();
        renderList();
      }
      // Listen for dictionaries tab click and init fallback
      document.addEventListener('click', function(evt){
        const btn = evt.target && evt.target.closest('.devlab-toggle-btn');
        if (btn && btn.getAttribute('data-view') === 'dict') {
          setTimeout(initFallback, 250);
        }
      });
      // Also init when entering dev mode in case the dictionaries view is already selected
      document.addEventListener('layoutchange', function(evt){
        if (evt && evt.detail && evt.detail.mode === 'dev') {
          setTimeout(initFallback, 400);
        }
      });
    })();

    // Copy-paste test outputs mirrored from JADO
    // Intentionally static – used as MLCX test harness
    // Safe to update later when Dictionaries become read-only reference UI
    function getJadoJargonCopyText() {
      return `Jargon

NCD → no claims discount (NCD)

NCB → no claims discount (also called no claims bonus)

FNOL → when you first told us about the incident

QNOL → when you first told us about the incident

TPO → third party only cover

TPFT → third party, fire and theft cover

TPPD → damage to someone else's property

T/L → total loss (written off)

LEI → legal expenses cover

MLEI → motor legal expenses cover

PH → the policyholder

ND → named driver

TP → the other driver / the other person

TPI → the other driver's insurer (TPI)

V5C → your V5C logbook (vehicle registration document)

Category S → Category S (structural damage)

Category N → Category N (non‑structural damage)

MTA → a change to your policy (mid-term adjustment)

SOP → our internal guidelines

MID → the Motor Insurance Database (MID)

VRN → your car's registration number (VRN)

DVLA → the DVLA (the UK body that looks after vehicle and driver records)

DPA → data protection law (Data Protection Act)

CiVC → customers in vulnerable circumstances

AMC → our accident management company (who arrange repairs and hire cars)

policyholder → policyholder (the person who owns the policy)

named driver → named driver (someone listed on the policy who can drive the car)

multi-car account → an account with more than one car or policy

comprehensive cover → comprehensive cover (the widest level of cover, including your own car)`;
    }

    function getJadoUkUsCopyText() {
      return `US → UK

realize → realise

realization → realisation

recognize → recognise

authorize → authorise

apologize → apologise

specialize → specialise

capitalize → capitalise

organize → organise

finalize → finalise

analyze → analyse

color → colour

flavor → flavour

honor → honour

labor → labour

valor → valour

favor → favour

behavior → behaviour

neighbor → neighbour

odor → odour

traveling → travelling

traveled → travelled

canceled → cancelled

counseling → counselling

reveled → revelled

enrollment → enrolment

center → centre

meter → metre

theater → theatre

defense → defence

license → licence

offense → offence

check → cheque

airplane → aeroplane

tire → tyre

gray → grey

curb → kerb

program → programme

catalog → catalogue

aluminum → aluminium

mold → mould

focused → focussed

focusing → focussing

modeled → modelled

modeling → modelling

repair center → repair centre

rental car → hire car

gasoline → petrol

zip code → postcode

highway → motorway

traffic circle → roundabout

practice → practise

license → licence

defense → defence

program → programme

liter → litre

fiber → fibre

jewelry → jewellery

maneuver → manoeuvre

plow → plough

aging → ageing

cozy → cosy

learned → learnt

spelled → spelt

dreamed → dreamt

burned → burnt

smelled → smelt

leaped → leapt

fit → fitted

gotten → got

while → whilst`;
    }

    // Wire up copy-paste test buttons
    document.addEventListener('DOMContentLoaded', function() {
      const jargonTestBtn = document.getElementById('devCopyJargonTest');
      const ukusTestBtn = document.getElementById('devCopyUkusTest');

      if (jargonTestBtn) {
        jargonTestBtn.addEventListener('click', async function() {
          try {
            await navigator.clipboard.writeText(getJadoJargonCopyText());
            const orig = jargonTestBtn.textContent;
            jargonTestBtn.textContent = 'Copied!';
            setTimeout(() => { jargonTestBtn.textContent = orig; }, 800);
          } catch (err) {
            console.warn('Copy failed:', err);
          }
        });
      }

      if (ukusTestBtn) {
        ukusTestBtn.addEventListener('click', async function() {
          try {
            await navigator.clipboard.writeText(getJadoUkUsCopyText());
            const orig = ukusTestBtn.textContent;
            ukusTestBtn.textContent = 'Copied!';
            setTimeout(() => { ukusTestBtn.textContent = orig; }, 800);
          } catch (err) {
            console.warn('Copy failed:', err);
          }
        });
      }
    });
    </script>
    
